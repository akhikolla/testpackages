---
title: "Efficient Bayesian generalized linear models with time-varying coefficients"
author: "Jouni Helske"
date: "15 May 2020"
output:
html_document: default
bibliography: walker.bib
link-citations: true
vignette: |
  %\VignetteIndexEntry{Efficient Bayesian generalized linear models with time-varying coefficients}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(walker)
```

## Introduction

Varying coefficient regression models are extension to basic linear regression models where instead of constant but unknown regression coefficients, the underlying coefficients are assumed to vary over "time" according to random walk. In their simplest form these models can be used to model regression models with additional time series component, and they also allow robust modelling of phenomenas where the effect size of the predictor variables can vary during the period of the study. The `R` [@R] package `walker` provides an efficient method for fully Bayesian inference of such models, where the main computations are performed using the Markov chain Monte Carlo (MCMC) algorithms provided by `Stan` [@stan, @rstan]. This also allows the use of many general diagnostic and graphical tools provided by several `Stan` related `R` packages such as `ShinyStan` [@shinystan].

More specifically, the linear model with time-varying coefficients is defined as
$$
\begin{aligned}
y_t &= x'_t \beta_t + \epsilon_t, \quad t = 1,\ldots, n\\
\beta_{t+1} &= \beta_t + \eta_t,
\end{aligned}
$$
where $y_t$ is the observation at time $t$, $x_t$ contains the corresponding predictor variables, $\beta_t$ is a $k$ dimensional vector of regression coefficients at time $t$, $\epsilon_t \sim N(0, \sigma^2_{\epsilon})$, and $\eta_t \sim N(0, D)$, with $D$ being $k \times k$ diagonal matrix with diagonal elements $\sigma^2_{i,\eta}$, $i=1,\ldots,k$. Denote the unknown parameters of the model by $\beta = (\beta'_1, \ldots, \beta'_n)'$ and $\sigma = (\sigma_{\epsilon}, \sigma_{1, \eta}, \ldots, \sigma_{k, \eta})$. We define priors for first $\beta_1$ as $N(\mu_{\beta_1}, \sigma_{\beta_1})$, and for $\sigma_i \sim N(\mu_{\sigma_i}, \sigma_{\sigma_i})$, $i=1,\ldots,k+1$, truncated to positive values.

Although in principle writing this model as above in `Stan` is straightforward, standard implementation can lead to some computational problems (see the illustration in next Section). An alternative solution used by `walker` is based on the marginalization of the regression coefficients $\beta$ during the MCMC sampling by using the Kalman filter. This provides fast and accurate inference of marginal posterior $p(\sigma | y)$. Then, the corresponding joint posterior $p(\sigma, \beta | y) = p(\beta | \sigma, y)p(\sigma | y)$ can be obtained by simulating the regression coefficients given marginal posterior of standard deviations. This sampling can be performed for example by simulation smoothing algorithm by @durbin. Note that we have opted to sample the $\beta$ parameters given $\sigma$'s, but it is also possible to obtain somewhat more accurate summary statistics such as mean and variance of these parameters by using the standard Kalman smoother for computation of $\textrm{E}(\beta| \sigma, y)$ and $\textrm{Var}(\beta| \sigma, y)$, and using the law of total expectation.

In this vignette we first introduce the basic use using simple linear regression model with first order random walk, and then discuss extensions to second order random walk, as well as how to deal with non-Gaussian data.

## Illustration

Let us consider a observations $y$ of length $n=100$, generated by random walk (i.e. time varying intercept) and two predictors. This is rather small problem, but it was chosen in order to make possible comparisons with the "naive" `Stan` implementation. For larger problems (in terms of number of observations and especially number of predictors) it is very difficult to get naive implementation to work properly, as even after tweaking several parameters of the underlying MCMC sampler, one typically ends up with divergent transitions or low BMFI index, meaning that the results are not to be trusted. 

First we simulate the coefficients and the predictors:

```{r example}
set.seed(1)
n <- 100
beta1 <- cumsum(c(0.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 <- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.15)))
x1 <- rnorm(n, mean = 2)
x2 <- cos(1:n)
rw <- cumsum(rnorm(n, 0, 0.5))
ts.plot(cbind(rw, beta1 * x1, beta2 * x2), col = 1:3)
```

```{r observations}
signal <- rw + beta1 * x1 + beta2 * x2
y <- rnorm(n, signal, 0.5)
ts.plot(cbind(signal, y), col = 1:2)
```

Then we can call function `walker`. The model is defined as a formula like in `lm`, and we can give several arguments which are passed to `sampling` method of `rstan`, such as number of iteration `iter` and number of chains `chains` (default values for these are 2000 and 4). In addition to these, we use arguments `beta` and `sigma`, which define the prior distributions for $\beta_1$ and $\sigma$ respectively. These arguments should length two vectors, where the first value defines the prior mean, and the second value defines the prior standard deviation.

```{r walker}
fit <- walker(y ~ -1 + rw1(~ x1 + x2, beta = c(0, 10), sigma = c(0, 10)), 
  refresh = 0, chains = 2, sigma_y = c(0, 10), seed = 1)
```

We sometimes get a few (typically one) warning message about numerical problems, as the sampling algorithm warms up, but this is nothing to be concerned with (if more errors occur, then a Github issue for `walker` package is more than welcome). 

The output of `walker` is `walker_fit` object, which is essentially a list with `stanfit` from `Stan`'s `sampling` function, and the original observations `y` and the covariate matrix `xreg`. Thus we can use all the ready made tools for postprocessing `stanfit` objects:

```{r pars}
print(fit$stanfit, pars = c("sigma_y", "sigma_rw1"))
library(bayesplot)
mcmc_areas(as.matrix(fit$stanfit), regex_pars = c("sigma_y", "sigma_rw1"))
```

Let's check how well our estimates of $\beta$ coincide with the true values (the solid lines correspond to true values):

```{r plot_with_true_betas}
betas <- summary(fit$stanfit, "beta_rw")$summary[, "mean"]

ts.plot(cbind(rw, beta1, beta2, matrix(betas, ncol = 3)),
  col = rep(1:3, 2), lty = rep(1:2, each = 3))
```

There is also simpler (and prettier) `ggplot` based plotting function for coefficients:

```{r plot_pretty_betas}
plot_coefs(fit, scales = "free") + theme_bw()
```

### Posterior predictive checks

The `walker` function also returns samples from the posterior predictive distribution $p(y^{\textrm{rep}} | y) = \int p(y^{\textrm{rep}} | \beta, \sigma, y) p(\beta, \sigma | y) \textrm{d}\beta\textrm{d}\sigma$. This can be used to used for example in assessment of model fit to the data. By comparing the replication series (mean and 95% quantiles in black) and the original observations (in red) we see that very good overlap, which is not that suprising given that we know the correct model:

```{r ppc}
pp_check(fit)
```

### Out-of-sample prediction

It is also possible to obtain actual forecasts given new covariates $x^{new}$:

```{r prediction}
new_data <- data.frame(x1 = rnorm(10, mean = 2), x2 = cos((n + 1):(n + 10)))
pred <- predict(fit, new_data)
plot_predict(pred)
```

## Extensions: Smoother effects and non-Gaussian models

When modelling regression coefficients as a simple random walk, the posterior estimates of these coefficients can have large short-term variation which might not be realistic in practice. One way of imposing more smoothness for the estimates is to switch from random walk coefficients to integrated second order random walk coefficients:
$$
\beta_{t+1} = \beta_t + \nu_t,\\
\nu_{t+1} = \nu_t + \eta_t.
$$
This is essentially local linear trend model [@harvey] with restriction that there is no noise on the $\beta$ level. This model can be estimated by switching `rw1` function inside of the walker formula to `rw1`, with almost identical interface, but now $\sigma$ correspond to the standard deviations of the slope terms $\nu$. The prior for $\nu$ most also be defined. Using RW2 model, the coefficient estimates of our example model are clearly smoother:

```{r walker_rw2}
fit_rw2 <-walker(y ~ -1 + 
    rw2(~ x1 + x2, beta = c(0, 10), sigma = c(0, 10), nu = c(0, 10)), 
  refresh = 0, chains = 2, sigma_y = c(0, 10))
plot_coefs(fit_rw2, scales = "free") + theme_bw()
```

So far we have focused on simple Gaussian linear regression. The above treatment cannot be directly extended to non-Gaussian models such as Poisson regression, as the marginal log-likelihood is intractable. However, it is possible to use relatively accurate Gaussian approximations, and the resulting approximate posterior can then be weighted using importance sampling type correction [@vihola], leading to exact inference. Function `walker_glm` extends the the package to handle Poisson and binomial observations using the aforementioned methodology.

## Comparison with naive approach

We now compare the efficiency of the "naive" implementation and the state space approach. For this, we use function `walker_rw1`, which supports only basic random walk models. We can perform the same analysis with naive implementation by setting the argument `naive` to `TRUE`:

```{r naive}
naive_fit <- walker_rw1(y ~ x1 + x2, seed = 1, refresh = 0, chains = 2,
  beta = cbind(0, rep(5, 3)), sigma = cbind(0, rep(2, 4)),
  naive = TRUE, control = list(adapt_delta = 0.95, max_treedepth = 15))
```

Let's run the state space version again:
```{r kalman}
kalman_fit <- walker_rw1(y ~ x1 + x2, seed = 1, refresh = 0, chains = 2,
   beta = cbind(0, rep(5, 3)), sigma = cbind(0, rep(2, 4)),
   naive = FALSE)
```

```{r times}
print(naive_fit$stanfit, pars = c("sigma_y", "sigma_b"))
print(kalman_fit$stanfit, pars = c("sigma_y", "sigma_b"))
sum(get_elapsed_time(naive_fit$stanfit))
sum(get_elapsed_time(kalman_fit$stanfit))
```

With naive implementation we get smaller effective sample sizes and much higher computation time, as well as some indications of divergence problems, even with adjusted step size (argument `adapt_delta`).


## Discussion

In this vignette we illustrated the benefits of marginalisation in the context of time-varying regression models. The underlying idea is not new; this approach is typical in classic Metropolis-type algorithms for linear-Gaussian state space models where the marginal likelihood $p(y | \theta)$ (where $\theta$ denotes the hyperparameters i.e. not the latents states such as $\beta$'s in current context) is used in the computation of the acceptance probability. Here we rely on readily available Hamiltonian Monte Carlo based `Stan` software, thus allowing us to enjoy the benefits of diverse tools of the `Stan` community. 

The motivation behind the `walker` was to test the efficiency of importance sampling type weighting method of @vihola in a dynamic generalized linear model setting within the HMC context. Although some of our other preliminary results have suggested that naive combination of the HMC with IS weighting can provide rather limited computational gains, in case of GLMs with time-varying coefficients so called global approximation technique [@vihola] provides fast and robust alternative to standard HMC approach of `Stan`.

## Acknowledgements

This work has been supported by the Academy of Finland research grants 284513, 312605, and 311877.

## References
