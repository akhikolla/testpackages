<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Overview of the <em>vcpen</em> package for Penalized Variance Components</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Overview of the <em>vcpen</em> package for Penalized Variance Components</h1>

<p>A penalized likelihood model is used to estimate variance components with an elastic-net penalty function that applies both L1 and L2 penalties to the variance components, using the function <code>vcpen()</code>.  Each variance component multiplies a kernel matrix, and we provide the function <code>kernel_linear()</code> to compute linear kernel matrices, but users are welcome to use their own functions to compute kernel matrices. </p>

<p>The function <code>vcpen()</code> allows the user to provide intitial starting values for the variance components. If no initial values are provided, the default is to use our funcion <code>minque()</code> to calculate initial values. For linear mixed models, MINQUE is the first iteration of restricted maximum likeihood estimation (REML), and iterative updates of MINQUE converge to  REML estimation.</p>

<pre><code class="r">require(vcpen)
</code></pre>

<h1>Preparing to run <em>vcpen</em></h1>

<h2>Sample dataset</h2>

<p>Below provides snapshots of an example dataset. The response is the outcome variable, covmat is a matrix of adjusting covariates, and dose is a matrix of the dose of a minor allele for SNPs (dose values of 0, 1, 2). The doseinfo illustrates how the SNPs (columns of dose) map into groups, for creating kernel matrices for each group. A kernel matrix for n subjects is an nxn matrix that measures similarity of the dose values for each pair of subjects.</p>

<pre><code class="r">data(vcexample)
ls()
</code></pre>

<pre><code>[1] &quot;covmat&quot;   &quot;dose&quot;     &quot;doseinfo&quot; &quot;response&quot;
</code></pre>

<pre><code class="r">head(dose)
</code></pre>

<pre><code>  snp1 snp2 snp3 snp4 snp5 snp6 snp7 snp8 snp9 snp10 snp11 snp12 snp13 snp14
1    0    0    0    0    1    1    1    0    0     1     1     0     0     1
2    1    0    0    0    0    1    0    0    0     0     2     0     0     1
3    0    0    0    0    1    0    0    0    0     1     0     0     0     0
4    1    0    0    0    1    0    0    1    1     0     0     0     0     0
5    0    0    0    0    0    1    0    0    0     1     0     0     1     0
6    0    0    0    0    1    0    0    0    0     0     1     0     0     0
  snp15 snp16 snp17 snp18 snp19 snp20 snp21 snp22 snp23 snp24 snp25 snp26 snp27
1     1     0     1     1     0     1     2     0     0     0     0     1     0
2     2     1     0     1     0     1     0     0     0     0     0     0     0
3     0     0     0     0     0     0     0     1     1     1     0     1     0
4     0     1     0     0     1     1     0     0     0     0     0     0     0
5     0     0     0     0     0     0     1     0     0     1     0     1     0
6     1     0     0     0     0     0     0     1     0     0     1     0     0
  snp28 snp29 snp30 snp31 snp32 snp33 snp34 snp35 snp36 snp37 snp38 snp39 snp40
1     0     0     0     0     0     1     0     0     0     0     0     0     1
2     0     0     1     0     0     0     1     0     0     0     0     1     0
3     0     1     0     0     0     0     0     0     0     0     1     1     0
4     1     1     0     0     0     0     0     0     0     0     0     1     0
5     0     0     0     0     0     1     1     0     0     0     0     0     1
6     0     0     0     0     0     0     0     1     0     0     0     0     0
  snp41 snp42 snp43 snp44 snp45 snp46 snp47 snp48 snp49 snp50 snp51 snp52 snp53
1     1     0     1     0     1     1     0     1     1     0     0     0     0
2     0     1     0     1     0     1     0     1     0     0     0     0     0
3     0     1     0     0     0     1     1     0     0     0     0     0     0
4     0     0     0     0     0     1     0     0     0     0     0     1     0
5     0     1     0     1     0     0     0     1     0     1     1     1     0
6     0     1     0     0     1     0     1     0     0     0     0     2     0
  snp54 snp55 snp56 snp57 snp58 snp59 snp60 snp61 snp62 snp63 snp64 snp65 snp66
1     0     0     1     0     0     0     0     0     0     0     0     0     0
2     0     0     0     0     0     1     0     0     1     0     0     1     0
3     0     0     1     0     0     0     0     0     1     0     0     0     0
4     0     0     0     0     1     0     1     0     1     0     0     1     0
5     0     0     0     0     0     0     0     0     1     0     0     0     0
6     1     0     1     0     1     0     0     0     0     2     0     1     0
  snp67 snp68 snp69 snp70
1     0     0     0     0
2     0     1     0     0
3     1     0     0     0
4     0     0     0     0
5     0     0     0     0
6     0     0     0     0
</code></pre>

<pre><code class="r">head(doseinfo)
</code></pre>

<pre><code>  index vcname
1     1    vc1
2     1    vc1
3     1    vc1
4     1    vc1
5     1    vc1
6     1    vc1
</code></pre>

<pre><code class="r">response[1:10]
</code></pre>

<pre><code> [1]  0.54166685  0.07233516 -1.03718603 -1.16407584  1.17964672  0.14994286
 [7]  1.82625006 -2.83793412 -0.18631904  1.53431587
</code></pre>

<h2>Make kernel matrices</h2>

<p>The  example below illustrates how to loop over groups (indicated by doseinfo) to create linear kernel matrices for each group. Note that the  number of variance components is the number of groups plus 1, because the last group is for the residual variance component, which will have a kernel matrix that is the identity matrix. </p>

<pre><code class="r">nvc &lt;- 1 + length(unique(doseinfo[, 2]))
id &lt;- 1:nrow(dose)

## vcs for genetic kernel matrices
Kerns &lt;- vector(&quot;list&quot;, length = nvc)
for (i in 1:(nvc - 1)) {
    ## below uses kernel_linear, but users can replace this with their choice of
    ## function to create other types of kernel matrices.
    Kerns[[i]] &lt;- kernel_linear(dose[, grep(i, doseinfo[, 2])])
    rownames(Kerns[[i]]) &lt;- id
    colnames(Kerns[[i]]) &lt;- id
}
## vc for residual variance requires identity matrix
Kerns[[nvc]] &lt;- diag(nrow(dose))
rownames(Kerns[[nvc]]) &lt;- id
colnames(Kerns[[nvc]]) &lt;- id
</code></pre>

<h1>Penalized estimation of VCs</h1>

<h2>Default settings.</h2>

<p>Run with default settings, which uses <code>minque()</code> to estimate initial values for variance components and default <code>frac1=0.8</code>.</p>

<pre><code class="r">fit &lt;- vcpen(response, covmat, Kerns)
summary(fit)
</code></pre>

<pre><code>vcpen object
  N-subjects = 100
  N-VC = 5

  Model fits over lambda penalty grid:

   lambda iter   logl loglpen   bic min_bic
1    0.10   49 -155.2   160.5 333.4   FALSE
2    0.09   30 -154.7   159.9 332.4   FALSE
3    0.08   24 -154.3   159.3 331.5   FALSE
4    0.07   20 -153.9   158.7 330.8   FALSE
5    0.06   18 -153.6   158.0 330.2   FALSE
6    0.05   16 -153.3   157.2 329.7   FALSE
7    0.04   15 -153.1   156.4 329.3   FALSE
8    0.03   14 -152.9   155.6 328.9   FALSE
9    0.02   13 -152.8   154.7 328.6   FALSE
10   0.01   13 -152.7   153.7 328.5    TRUE
11   0.00  110 -152.7   152.7 333.0   FALSE

  VC estimates by lambda penalties:

   lambda     vc1    vc2       vc3       vc4    vc5
1    0.10 0.06318 0.1301 0.000e+00 0.000e+00 1.0854
2    0.09 0.07712 0.1535 0.000e+00 2.435e-20 1.0523
3    0.08 0.09139 0.1779 0.000e+00 0.000e+00 1.0231
4    0.07 0.10522 0.2020 0.000e+00 0.000e+00 0.9996
5    0.06 0.11933 0.2269 1.448e-20 0.000e+00 0.9796
6    0.05 0.13405 0.2530 0.000e+00 0.000e+00 0.9622
7    0.04 0.14992 0.2813 0.000e+00 0.000e+00 0.9466
8    0.03 0.16730 0.3123 0.000e+00 0.000e+00 0.9326
9    0.02 0.18676 0.3472 0.000e+00 1.028e-21 0.9200
10   0.01 0.20925 0.3875 2.605e-22 0.000e+00 0.9082
11   0.00 0.23670 0.4372 2.420e-13 5.713e-03 0.8910

Estimates with min BIC:
beta:
[1] 0.628 1.097
VC estimates:
      vc1    vc2       vc3 vc4    vc5
10 0.2092 0.3875 2.605e-22   0 0.9082
</code></pre>

<h2>Changing penalty fraction:</h2>

<p>Perform the same run as above, but with lower penalty fraction.</p>

<pre><code class="r">fit.frac1 &lt;- vcpen(response, covmat, Kerns, frac1 = 0.1)
summary(fit.frac1)
</code></pre>

<pre><code>vcpen object
  N-subjects = 100
  N-VC = 5

  Model fits over lambda penalty grid:

   lambda iter   logl loglpen   bic min_bic
1    0.10   25 -154.2   157.4 331.5   FALSE
2    0.09   14 -154.1   157.1 331.1   FALSE
3    0.08   15 -153.8   156.7 330.7   FALSE
4    0.07   14 -153.6   156.3 330.3   FALSE
5    0.06   14 -153.4   155.9 329.9   FALSE
6    0.05   13 -153.3   155.5 329.5   FALSE
7    0.04   13 -153.1   155.0 329.2   FALSE
8    0.03   13 -152.9   154.5 328.9   FALSE
9    0.02   12 -152.8   154.0 328.7   FALSE
10   0.01   12 -152.7   153.4 328.5    TRUE
11   0.00  110 -152.7   152.7 333.0   FALSE

  VC estimates by lambda penalties:

   lambda     vc1    vc2      vc3       vc4    vc5
1    0.10 0.09851 0.1707 0.00e+00 0.000e+00 1.0213
2    0.09 0.10547 0.1832 0.00e+00 0.000e+00 1.0101
3    0.08 0.11416 0.1988 0.00e+00 0.000e+00 0.9959
4    0.07 0.12345 0.2158 0.00e+00 0.000e+00 0.9825
5    0.06 0.13371 0.2347 0.00e+00 0.000e+00 0.9694
6    0.05 0.14496 0.2556 0.00e+00 0.000e+00 0.9569
7    0.04 0.15772 0.2797 0.00e+00 0.000e+00 0.9445
8    0.03 0.17232 0.3076 3.16e-23 0.000e+00 0.9324
9    0.02 0.18924 0.3406 0.00e+00 1.706e-23 0.9208
10   0.01 0.20977 0.3815 0.00e+00 0.000e+00 0.9091
11   0.00 0.23670 0.4372 2.42e-13 5.713e-03 0.8910

Estimates with min BIC:
beta:
[1] 0.628 1.097
VC estimates:
      vc1    vc2 vc3 vc4    vc5
10 0.2098 0.3815   0   0 0.9091
</code></pre>

<h1>Demo of using <code>minque()</code> outside of <code>vcpen()</code></h1>

<p>This demonstrates how users can use <code>minque()</code> as a general approach to approximate REML variance components. Increasing <code>n.iter</code> will cause the resulting variance components to be closer to the fully interative REML estimates.</p>

<pre><code class="r">vcinit &lt;- minque(response, covmat, Kerns, n.iter = 2)
names(vcinit)
</code></pre>

<pre><code>[1] &quot;vc&quot;        &quot;beta&quot;      &quot;residuals&quot;
</code></pre>

<pre><code class="r">vcinit$beta
</code></pre>

<pre><code>          [,1]
[1,] 0.6279622
[2,] 1.0961475
</code></pre>

<pre><code class="r">vcinit$vc
</code></pre>

<pre><code>          [,1]
[1,] 0.2279593
[2,] 0.4254118
[3,] 0.0000000
[4,] 0.0000000
[5,] 1.0161211
</code></pre>

<h1>References</h1>

<p>Schaid DJ, Sinnwell JP, Larson NB, Chen J (2020). Penalized Variance Components for Association of Multiple Genes with Traits. Genet Epidemiol, To Appear.</p>

</body>

</html>
