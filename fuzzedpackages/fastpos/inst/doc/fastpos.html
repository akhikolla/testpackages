<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Johannes Titz" />


<title>Introduction to fastpos</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to fastpos</h1>
<h4 class="author">Johannes Titz</h4>
<h4 class="date">August, 2020</h4>



<p>The R package <em>fastpos</em> provides a fast algorithm to calculate the required sample size for a Pearson correlation to stabilize within a sequential framework <span class="citation">(Schönbrodt &amp; Perugini, 2013, 2018)</span>. Basically, one wants to find the sample size at which one can be sure that 1-α percent of many studies will fall into a specified corridor of stability around an assumed population correlation and stay inside that corridor if more participants are added to the study. For instance, find out <em>how many</em> participants per study are required so that, out of 100k studies, 90% would fall into the region between .4 to .6 (a Pearson correlation) and not leave this region again when more participants are added (under the assumption that the population correlation is .5). This sample size is also referred to as the <em>critical point of stability</em> for the specific parameters.</p>
<p>This approach is related to the AO-method of sample size planning <span class="citation">(e.g. Algina &amp; Olejnik, 2003)</span> and as such can be seen as an alternative to power analysis. Unlike AO, the concept of <em>stability</em> incorporates the idea of sequentially adding participants to a study. Although the approach is young, it has already attracted a lot of interest in the psychological research community, which is evident in over 800 citations of the original publication <span class="citation">(Schönbrodt &amp; Perugini, 2013)</span>. Still, to date, there exists no easy way to use the stability approach for individual sample size planning because there is no analytical solution to the problem and a simulation approach is computationally expensive with <span class="math inline">\(\mathcal{O}(n^2)\)</span>. The presented package overcomes this limitation by speeding up the calculation of correlations and achieving <span class="math inline">\(\mathcal{O}(n)\)</span>. For typical parameters, the theoretical speedup should be at least around a factor of 250. An empirical benchmark for a typical scenario even shows a speedup of about 400, paving the way for a wider usage of the <em>stability</em> approach (see <a href="https://github.com/johannes-titz/fastpos" class="uri">https://github.com/johannes-titz/fastpos</a>).</p>
<div id="using-fastpos" class="section level2">
<h2>Using <em>fastpos</em></h2>
<p>Since you have found this page, I assume you either want to (1) calculate the critical point of stability for your own study or (2) explore the method in general. If this is the case, read on and you should find what you are looking for. Let us first load the package and set a seed for reproducibility:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">library</span>(fastpos)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">set.seed</span>(<span class="dv">19950521</span>)</span></code></pre></div>
<p>In most cases you will just need the function <strong>find_critical_pos</strong> which will give you the critical point of stability for your specific parameters.</p>
<p>Let us reproduce Schönbrodt and Perugini’s quite famous and oft-cited table of the critical points of stability for a precision of 0.1. We reduce the number of studies to 10k so that it runs fairly quickly.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">find_critical_pos</span>(<span class="dt">rhos =</span> <span class="kw">seq</span>(.<span class="dv">1</span>, <span class="fl">.7</span>, <span class="fl">.1</span>), <span class="dt">sample_size_max =</span> <span class="fl">1e3</span>,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>                  <span class="dt">n_studies =</span> <span class="fl">10e3</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co">#&gt; Warning in find_critical_pos(rhos = seq(0.1, 0.7, 0.1), sample_size_max = 1000, : 37 simulation[s] did not reach the corridor of</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">#&gt;             stability.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co">#&gt; Increase sample_size_max and rerun the simulation.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="co">#&gt;   rho_pop 80%   90%    95% sample_size_min sample_size_max lower_limit</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">#&gt; 1     0.1 253 361.0 479.05              20            1000         0.0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co">#&gt; 2     0.2 237 339.0 445.00              20            1000         0.1</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="co">#&gt; 3     0.3 212 304.1 402.00              20            1000         0.2</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="co">#&gt; 4     0.4 184 261.0 346.00              20            1000         0.3</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="co">#&gt; 5     0.5 142 205.1 273.00              20            1000         0.4</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="co">#&gt; 6     0.6 103 147.0 200.00              20            1000         0.5</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a><span class="co">#&gt; 7     0.7  64  96.0 127.05              20            1000         0.6</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="co">#&gt;   upper_limit n_studies n_not_breached precision precision_rel</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="co">#&gt; 1         0.2     10000             14       0.1         FALSE</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="co">#&gt; 2         0.3     10000             16       0.1         FALSE</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="co">#&gt; 3         0.4     10000              5       0.1         FALSE</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="co">#&gt; 4         0.5     10000              1       0.1         FALSE</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span class="co">#&gt; 5         0.6     10000              0       0.1         FALSE</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="co">#&gt; 6         0.7     10000              1       0.1         FALSE</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="co">#&gt; 7         0.8     10000              0       0.1         FALSE</span></span></code></pre></div>
<p>The results are very close to Schönbrodt and Perugini’s table (see <a href="https://github.com/nicebread/corEvol" class="uri">https://github.com/nicebread/corEvol</a>). Note that a warning is shown, because in some simulations the corridor of stability was not reached. As long as this number is low, this should not affect the estimates much. But if you want to get more accurate estimates, then increase the maximum sample size.</p>
<p>If you want to dig deeper, you can have a look at the functions that <strong>find_critical_pos</strong> builds upon. <strong>simulate_pos</strong> is the workhorse of the package. It calls a C++ function to calculate correlations sequentially and it does this pretty quickly (but you know that already, right?). A rawish approach would be to create a population with <strong>create_pop</strong> and pass it to <strong>simulate_pos</strong>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>pop &lt;-<span class="st"> </span><span class="kw">create_pop</span>(<span class="fl">0.5</span>, <span class="dv">1000000</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>pos &lt;-<span class="st"> </span><span class="kw">simulate_pos</span>(<span class="dt">x_pop =</span> pop[,<span class="dv">1</span>],</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>                    <span class="dt">y_pop =</span> pop[,<span class="dv">2</span>],</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>                    <span class="dt">n_studies =</span> <span class="dv">10000</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>                    <span class="dt">sample_size_min =</span> <span class="dv">20</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>                    <span class="dt">sample_size_max =</span> <span class="dv">1000</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>                    <span class="dt">replace =</span> T,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>                    <span class="dt">lower_limit =</span> <span class="fl">0.4</span>,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>                    <span class="dt">upper_limit =</span> <span class="fl">0.6</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="kw">hist</span>(pos, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1000</span>), <span class="dt">xlab =</span> <span class="kw">c</span>(<span class="st">&quot;Point of stability&quot;</span>),</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>     <span class="dt">main =</span> <span class="st">&quot;Histogram of points of stability for rho = .5+-.1&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmYAAAHMCAIAAADwIfPIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAgAElEQVR4nO3deWAM5x/H8e8m2dyHCIkjIcQdxH0TZ1HUUVVU61Z39dCDtrTa0rp6qVJXq+iltD9aRQl11hVxJeqIW4hELrl3fn/kkEQ2JtmVTOL9+is7M/vMd5+Z2c/uzOwTnaIoAgAAHsaiqAsAAKB4IDIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiszCc3hUQEBAQcOxqUvbp0ecPBAQEBAQcvBibNiFgbBmdTqfT9fk+pfCrLE5Cvx9S00GXpsWnVx/RWrS8OQqnB7JS0xs5lsn7oVkUZj9oc3+4F3ooIDcnwgxmX1fM+YMBAQEBAUcuJ5i97WLCqqgLeCy836nDj6kirRfe2DOlXJbppxcP7DD/kojP9GPnPmggImUbPfX009EizSqr/iwTd/HfQ5d03s2aetubv3CNUrbPmbTm7D2Rsi2HD2vXsKHjI1pPATaHFM4WMUcPPIo68+6xB+eaWkNh7QladuqL/h0WXH5weo/V8ZuG2JptNVFB38+Y+Pqif26kiEjj2RcPv+lttraLEyJTU3zHrPhlTL6ecfmbQa1ePlhrxpmTM2s9oqK05+aZM3dFRKq9uHjFLL9Ht578bw4ppC1ihh54JHXm3WMPzDW5hsLaE7Ts7t27IiKONdp3qu2SZXpTL8uci6YmJSQbxNLaVp+/04tXf5sycMyXe2+lmlZpiUBkasrds3sDryeLlKntX9dDlz5RSYi4euny9chUp3KVq1QuY5c+Xbl1ctfp42sXH0wViQv9NyDgpmuNNn4V0reoEn/zbPCl8HhL5wo+tbxd9Q+uKyXiwomztwyuVX1rutsmXz++92ykiGvNNn7lrUQk/PSuk7cUcazSrEll67sXT51PrFivVhlrERFJirp26dK1iFTXSj7e5Z2zNp31WfYpkRdP/BduXbF2nYqOaTXH3Th95mqqR83aXs4P2/GM1n/37N7Ao6dvpy0UdjIgINK5WstGnjZZn5xehq1XoxY+zkrs9TPBl2NsKvrW9XLUSU55dVSOzZHt1Un8reAzoQnOVWpWLWtn8dAtYmQjPqoeSG+iAHuO8Y2bQafTiShxN86cuRRjXaFO3UpO999/c92Bc5vrqzuVowYXF5foqChFdGVqt8vy3OjzB45eSRCx927azNshZ2tG+yGvzZrXvp3nMtl6IJcdIFvfP/QANJPUyMgYEZEaw5ZufKt6nouGL36i7KRd8vS65F8G5uud/+SGZXvvlu/46uwJurlPzwsyodoSQMGj92zax73WC29kn77/1coiIuIz/VjahJ0vuomISO/VyYqiKMq9U2te6lrt/hu9zrF619c2hqYoiqIkr+udY1t2WhypKIoS9e9XI1uUu/8OoHP06fb6LxcS76/XcHPL1DYe6QeNpWvTib8FfNhIRESeWBGdtkj6KZ0qU3fseaeJo4j4vHFMUZSIfz4e0NAt89OrZZlmIxYfic5sePPzdiIi3q/9E7J8YFW7tNW7NHplyx3l1h8vN3VNe2exrtJ/+ekko72Vd/0ZXXRf84VXcrTwxwv2IiKuo9cf/rRfVYf07rOvMWDZqQTVK3pwc2S+un1XNkxqXDq9F5zqDVv3X3IeWySvjfioeqBAe85DNm76enX9VwYtGVQjo2m7av2WBMUb6THjD3Op4fU3GutERCpM3GPIXGnYF/4WIiJlR27LuccY64eHblYj+3Y2uS6TvkbLAT9cznUHULtfZd9Slw7vNCrwenLuz7ov/Ov2IiLS+evw5Kgrpw7t//f09XuGXBe9/YW/iMjT6x7aaA7Hvv9k47l7iqL8l/5VvvHsi/lsosQgMgtDemTWnbA++wGxaICHiBiNzOS9kyuJiDjX6T3hzXfffXNcjxoOImLp89qBFEVJDVoz/ZWulUREpGzbsdOnT1/5b7ySeOT9pmlRVapO1+fHjBrQyivtA275AT/eTC/nylcd064cWVZoPmDkyP6NPVyqVCkjIiJPfncvbZm/R7uKiJTt1qOZhej01lbV3jimXPqqo5OIiH2dAW99NOulrl5WIiLuL/wem97yjjGlRURKd+rW1MWzSesG5dK/+viMeaO/m0u1lq1qpaembadvrufaVQ+t/8JvH02f2KmiiIh4dBg/ffr0r/dF5Whk+6hSIiLWPtUqudTs+tzwge2qpF3T0dWYeihZ5Yoe2ByZr+6Jp1o7uPg0b9u0cvqlM7tOi68pRrZI3hvxEfVAQfach27c9N6wqlWnhmvNrs8NH9ypWtq3Pl21Vw4m5dpjxh/mVkPo1531IiLlX/onNX2dd5Z1thQR8bo/KVOu/aBms+a6b+eQ6zLp9Tu0eyLHDmCftgOo3a+y+W92YzGq0zeRue4kWZyb00BERGq17+adceXSoVrvuXsjHli0wJF5v1gik8gsDM8+cFEhOyOReWaWr4iIy8g/M95cr64b12vA0LHvbU7/VpF+DIjvjDNpE64v6WAtIqJv8eGZ9E+1d34eWFZERCpNPWBQFEU5/X4dERGxaf/55VRFUZTkcwvbpH8m7rE6PlslOp1Lu1n/3EpUUhITU27/MrZ1s0b167Sesc+gKIpyb20/GxERh6F/Ktnrl+pT9kQrinJzRY+0tw+xbjk3JElRkk+9n/Z11qL/D7l96lZTv6JcnNtcRET8Zv+Xa39nllFr6oG0N/zIXwe7p72PjdqSrHpFRt7xpdyAdVdSFUWJD5xWP+3L1pPfxRnZIg/fiI+gBwqw5+Rj49Z549+0Vxu9aVgFERFxGfFHcl49lvvDB2qI/qmfo4hIxcm7015n5KqeehERn2lHc3uZD/ZDfjZrtn07Z8O5LqNiB1C3+bK6vGKwn1Ev/hr94DOyO/RG2qkqEbGwL+OeeS7dufOyS4qiKPGXj2R8RN842U9EpN072zOmHLtm/GxPbohMIrNQFDAyo9b0shURsSzj1/vF6QtW/e/AhbvZj+2cbzrR3/ZK+xbXbdndzIUMOyekfYX0m3VGUZTolT3S1tp9eeYy91b1THtezsiUihP3ZP94b0iIvBJ8dG/Aju3bts7vk7ZQz+8Tsj+r/vtn0yaELWorIiK67stj0qYceauKiIi0mBf6YEepqV9RH5lZDuzUv0a7ZO0EVSsy8o5fc/qJjKcEvZv28aPuB8G5bxEVG/ER9ED+95z0FanZuE3mZG45w7YXXdX0mMrIVJK2jHIXEak4aa9BUZS4NX1t03anECPdlaMf8rdZH9i3s8h1mYfvACo3nzkd/2pgjx49evR84cPtN1MUxRD+zxtN0j4AV3vzsHK/i3Llv/i2Envx3yxnvgJO385jZUSmwu0/haj1/KsBkz2yTDj4RrU2Cy4ZXd55wPylfwaP/f6/8OO/LTn+2xIRsSpTv+ekeV+906V8rveP3Lh61SAi4lK58v1753SenhVFwkWuX78uUivizh0REXGsWDFzGbvKlcuKhOXSYi1f38xbG5SbW2dNmLJgw5koJftCipJjQqVKaafcpHTp0iIiUsbb2zHLlIsiycnJBas/t9edOwtv70qZf1esWF4kSuTOnTumrqhatWoZf5Ypk/ZmmOurEZF8b0Tz9ED+9xz1G9eicmWvzMLKl/cQiczoVZPpu4we6r1sbui19T/t/bRV062/b00Q0bUc+kINdc/PX+9l3beNyXUZ4ztAATbfvfN7dqTd9puLsn7dmnvl/SZdf9y6TeOyPHZr8/7rPRcM+DVZzh0+HCWNrcv4+Pqm/e47NeJi8I174uzp65VeXZXSVnJx1fAO753KeLrlcxtSvu+T5xofb0RmYbKwtLLK2uOWD7lv0qr686tPdX9j+//+2PHP/oMH9x86HRYetHFGjzNJe05+0CyXbWdvn3aR8l5cnCKS0XpMTIyIiDg4OIiIXp926ibh3r37y8TExOZegqNj5k/dbq4Y3mfGlnixrv3CgvkvtvR0sT02u/3QNbdzeZalZY7v1RYWqu5qV1O/eoZ79xJE0n/wFxub9gptbW1NXVGWjZh272Se8rcRzdQD+d5z1G/cXHvVxiaXG3YLwKLZ6JF+8945fn39L/vmJ/61PU7Eqv2w5yo//Jkikt/ey7JvG5XrMsZ3gAJsvus/T+n11hEjq+/0TWT6hXljDInR4WFhYbd0FZtUS/t4KtalSzuI3E3P8QrD1pwcljYj/Mv2ZSftki5zA7PeMXsyr+aRE6P/aJmSGHnlbESZzsNfn7tiw+5TN26dmNveXiQ55Lc/Q7ItaDCkDfRRsWHDsiIiyQf2H8n8bnBt377LIiLWjRrVFRGPKlXsRERSjh7NuFtcCdy7P+6h1ez7++94EZFmEz6Z0L1Vo3q+LhGXIkx+jdmoqT8fjh48mPHl78aRIzdERHTVqvmYf0UPytgi+diIIuYrLN97Tj42btZePXo0rVerV6+W+8Jq3O8rEak+YrS/pcjVTZtWbtt2R8S229ABHsafm90j36yPoAC7So39jUr7xVcOEcH/BAQEBAQE3UgVOfFBc4/KNeo37f7J4fQhiVKDdu29KyLiVrNmznuKc1P33ePJ9yV+1zvnKpAVkaldEd/3LV26Ut2GfWftvBKXKqIkxt1LTDGIiEW5cmk3FNilf6i9GLAp8Oatm5HJ7V4cX89KRM4tGjt1fdD18Bun//johfcDUkR0niMm9XUQEUv/J7vai4gEfzlhxuZTl0OD1k998atzD/+hYMZJ1rMBf5y+ce3E+im93z1qYy0icjk0VMnzqWrpVNSfD2Grp0z58cT1W5f2fTV+dkCqiFi379ujlPlXdF/OLXLz4RvR/D1QgD3HUf3GDftuypQfg67furR/8YSPdqaKiL5d7yfz/Cqkrq/ShpOsMGRMD3uR86tnrD4v4tBnWH/1TT+yzfoIC6g4eEmu490FBAQEBMzvkcuX3H/ndO/QoUOHDq9vjhfxe/Y5X0sRObfw2adnLF37/eJpvXt/fEZEdFVHjGj/8KNa0k9+ZbC00OVchRgiLgSmOXMzXkRE4m+cTpvw321jVyRKrKK+mPpYKODvMhOCFnTMeFfVWVpmfLwp1fy9g+n3ZyqnPmhw/1NPzeknFCUpeEWfyjl/OG3h0XH+4YznKCkn57dxyjJXV6bn2Gc8RSSX238yfiGqKErCv2/Vznq+1bnFx1u/7mojIqKzder21bVcnpXx8zuPCTvTW7k4N+2e+sZGbt1RUb/a238suowY6Z31U7pjyznHkvKxorzvXlEURbmRfgdLzRkZN4Tk3CIqNqL5eyD/e87hh2/cbSNdRET03ceM8s66qEOzDw5n3P2cr9t/ctl706rfNCzj21HpoX8a+TmjsX7I/2bNVa7LqNoB1Gw+0/w5NC15u34ToyiKknzy8y5uOb77WJTruvBofM4nxuz4ZOTIkSMX/2v0rqfcVxGzsqsY0Xxurvd9l2BcyywMdfz9/VNF6nlmH2FEnH1a+Pt7i1Sskv5ZslSN1v7+USJpo5/Y1Ht5y4k2G9f8tPXIhRvhseLs4Vm1Uffnh/aq65pxhNR57ddfDR99u+9SvE2ZKm07lRPR1xy+4WSbP75dtXF30KWIJL2rp2+rns8P6123VOZRZen7yl+Hqnz26bp/LsRYl/PtOHTyON3Hnl+LiFhZWeZWiYiI2DT9YPc+n/lfbwm6kehSo+2QyROf9LEeuDFq7rpjdyw92jd2zuVZOve6/v53RUpXz/iqYOvV2N/fUaRmJbtc+0pF/WLr1cjf31akmpE20hkcOi4+OLrZgiV/Hr+e5FKt3cDJk/rUzHwzU7GiHC8nlz6xrtjA319EKmUOTJNzi6jYiObvgfzvOZWb+j9s49p7N/X3T5bSXcctWTm08YKlW4JuJDv7tB04eVLfWhk7dt49lrMDH9x706rvPnSg+6pFt0QqDBrWJccxk92D/ZD/zZqrXJdRtQOo2XymKV2rrb9/vEj98pYiIla+k/463/HXJSu3Hj936XaSQ8U6rXoOHdG33oP7l2OHqcs6FGAVluXq+/vnPg57HS/zXMQuPnRKzpsdUfIpSdE3r1y6rng2rpb2G4GY5d1LjdpikDJjA24v9i/i6kwXMLZMhyV3RHqvTt44hE+Fxc75eS1qTD1okGrTjp79sKGqk4tA4eBa5mPoxNv1XSpUq9+kw4vfnYlKTY4O2fDavG0GESnbq1cev+ECHq2oS0HHD+9YMaH/ewcNIo7d3pxMXkJj+Aj+GKo35fOXfu/z2cmrPw+t8/MwnaSdaLCrNXrF7CfN98+CgHw6NLtdlyVRaX+X7rLwy+Gqb5UFCgmR+Tgq+8SnB8/0Wbfy512nLoXdTbFzr9rAv9+wIZ1Lyr/cVHOxCtpTvlm/PpevJdh41G4/9OWxnbw4BwbN4VomAACq8DkOAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABViEwAAFQhMgEAUIXIBABAFSITAABVrIq6AK2LiIg4evSo6e00bNjQzc3N9HYAAEWFyHyIb7/9dt68eZUqVTKlkcuXL0+ZMmXq1KnmqgoAUPiIzIcwGAxdunR57bXXTGlk4cKFBoPBXCUBAIoE1zIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUtRqYhJSVVKeoiAADITiORmXr78PczR/VsUcuzlK2lpV5vZWntVK56k65D316+52ZyUVcHAICIVVEXICKpwUt6+Y/fadW4c9duw3p5lnW21+tS4mPCr50L2vftpHZfLZ+5Zfu7zeyLukwAwONNA5EZ/dMbLx9uvezkD8N9rB+YmXJ989j2vccs6B/4dp0iqA0AgAwaODF75uhR2z4Tc8tLEbGq0GP66MbH9x24V9hlAQCQjQYi08nJKe7atShjsw3Xr4dZOznZFGZJAAA8QAORWaffM9W3Tn363Q3HwxKz3yibdOfMnwsGDl0UN2DwE5ZFVB0AAGk0cC1T6k7f8O21ARP7N5hl6eThWbGss521LjUhJvz6lRt3kxxqPDP3j0W9XYq6SADA404LkSnW1QcvO9r7nYPbt+8LDAkNi4xLFL29i7tn9fotO3dp4+Oiga/CAIDHniYiU0RE51C5Re+RLXqLiCElRbG0stQVdUkAAGShkS9wDGUAANA6LXzLZCgDAEAxoIHIZCgDAEBxoIETswxlAAAoDjQQmQxlAAAoDjQQmQxlAAAoDjRwLZOhDAAAxYEWItNsQxlERUVt27ZNUXL//9S3bt0aPny4vT233gIACkITkSlinqEMLly48NNPPxmbu2PHDh8fn27duplSZsEoihIfHx8ZGWliO6VKldLpGOIBAIqGRiIz9fbhdYu+/mHLnsDg0BtRiQbR6R3dK9f0a9VtwOiJL7Qpp1fVSsOGDfOIzJYtW5YqVcpsJefH8ePH165du3DhQlMaiY+P//777wcMGGCuqgAA+aKFyCz5QxmkpKSMHz9+xIgRpjTyzjvvxMXFmaskAEB+aSAyGcoAAFAcaOBHJgxlAAAoDjQQmQxlAAAoDjQQmQxlAAAoDjRwLZOhDAAAxYEWItNsQxkAAPDoaCIyRbINZQAAgAZp4wucIeyfZe+9PHbCW19uv5osknLpf9OfbuJT3qOSb8unXl59Irqo6wMAQBPfMu/9Nb5Zj6Xh7tUryuolP5zessbjlac/T+48YEA7u7sntn7zQovAuNM7x1Yu6jIBAI83DURmxA/zlyU++9P51f3LKdfWPtNq4ggL/Ru7Amc1shERSZr6XqtGH395cOzc5kVdKADgsaaBE7MXzp617fZ8/3IWIpYVB4/vfiek1MBhjTJ+h2ldd1C/upeCgxOKtEYAADQQmQ4ODklRURmRWK6ch3h4eGSZHx0do3dwyHVsIAAACo0GIrNa+/bumz98ZcO5GIOI1J15UtkyyjFjZvzZFbNWXWzaookGCgUAPNY0kET6tu98PSplVb8aw35MzT4ndfOocrVH/l3utY9HexdJaQAAZNLA7T8i5Xp+dThk6N9XyuUYFc+yatc3Pu/z9NCeNR2KpjAAADJpIjJFxN6reS+vB6bWfmZa7SIoBgCAB2ngxCwAAMUBkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACoYiwy40/v2nE+xlCotQAAoGHGIjNux4xO1Twqtxr0xuLNJ++kFGpNAABokLHILDNy3eGN84bWCN/0dp965Ss06DN53i+HricWam0AAGiI0WuZduUb9x7/waptp8JuBf85f6Dn1Z+ntK9UrmaX0bO+23MloTBLBABACx5++4+Va81Oz7/55fodezbOfcJi/7J3h7b1qdxq3IoTMYVQHgAAWvHQyEwKO/bb51OfbeFVtkrXdw+X6z9z5Y6Dm9+utHNC615fFkaBAABog5WR6UrMhV2/rl27ds0vfwfftffx7z9m8Scv9G/r7aATEenwww59hyoLRSYWYqkAABQlY5F559sRHV466tP+mSkrlwx9ul1l+xzzK7RoWVX3qIsDAEA7jEWmY+cPdoc2auuVPSoVRdHp0pKywUdngh9xbQAAaIixa5m2tZq5bRr6xIdHs06MWzXQ98X11wqhLAAAtMbo7T9Xl4ybfMC5Rtms0/QNG5deN37m30mPvi4AADTGWGSm/BOwp+nLC57xyjrRusGrrz0ZtXt3SCEUBgCAthiLzIS4OIONjU3OyZZOTvb37t17xEUBAKA9Rm//adSo+qRVX/z7wgfNnDKmKTGBn8/bEN/oi9qPohIl7sqRf/YGBofeiIxNVPT2Lh6Va/q18m9exYn/tgIA0ABjkSmNXv508E99WnquadS0biVXm+To8CunDwVetfZfsPsZZzMXYQjb8cGYsZ/8/l+c6KwdXBzt9bqU+Jio2CSD2FbuPOXzZbOeqmy0UAAACoXxb3Bln1x+NPDnt3tXt4m5Fhp6M9aqSreXl+4+ue3leuZOr3ML+/RYcNV/zubDlyITE2Ij79y6FR4Rk5gYdfnYnwt7Jyzr1/H1PfFmXicAAPmUZ/w51+k39dN+Ux9xCSE/rjrSZv71b0aWyT7dytmrQbexn7WvGl+139Jt89o8xQlaAEARyisylZjQQ4dOXroZlWhQsky2rdmlf1MP85UQGRnpVLVqGWOzbWvV8o7bdjtexMF86wQAIL+MRmZy4Nz2nd7cF2F4YI7bhJ1mjcya9erFTFv12632vd1zGYIv9siSNYerdv6MvAQAFC2jkfnXp++fqPPm5sXjWlQqZZ3tlKjO2s6sJbgOfG/6lx2frhPU65lebfyqeZZ1trPWpSbEhF87f3L/Hz9vPGb73PrXmpp1lQAA5JuxyIy9eTO23ci3nqzr+OhrsGk2Y9cRv08/+frnle8tvxqTnD7Z0r5creadRy1f+vJzfq6PvgoAAPJk9HeZDRtVX3jhgiL1C+X/ldjX7DNteZ9pIin3IiIi4xJFb+9SurSjNf8sBQCgFUZPzDae9v3QIW9NWP76yz0bVXazy3JqVmdhaWlh/ixjKAMAgKYZi8zIlS/0mLMzNvq3PxbnnOU2YWf4l+3NWQRDGQAAtM9YEtk1GTprTner3L5N2vrWNG8N5xb26bEgaciczeuealXfq5Q+fZ0p0VdO7tu88sN3+nVMDDi5oI15bzoCACB/jEWmbb3eY+sVTgkMZQAAKA7yjCElOuSvFbNfHzd00DML9ouIhJ8KvJqc1zMKQs1QBrdvM2IeAKBoGY/MhOMLutbw7fbinLXb/978y7/XRCR1z+w2LV/cHGXeEmrWqxezadVvt5Rc56YNZVC/PkMZAACKltG7ai4sGvvm2XaLjy4e0VBZ3L7sHhERy97vzfiwzue/zu8x3Iw/lGQoAwBAcWAsMhN27zzo/9b/Rjd0EwnPnKrz6dql8qKQ8yJNzFgDQxkAAIoBY5FpUBSxtLR8YHp0dLTOyfw/yjTPUAZ79uwZNmyYouR+ivfGjRu3bt0yR7UAgMeRsci0b96i3phPXlvf+cunvTMnxgcv/nhdfKtVvo+iEjMMZdCiRYutW7cam9u/f393d3fzFAsAePwYvZZZZ9LC8T/07F99Y/XGvvpzEv1x93bvHtkfYvHksn09bc1chLmGMrCysqpataqxuTY2NmasGQDwuDH+Da5Ux8+O/Rfw+ei2lZ3dqzepYGvw8J+44kDQhuFVzX1e9tzCPj0WXPWfs/nwpcjEhNjIO7duhUfEJCZGXT7258LeCcv6dXx9D78xAQAUsTy/vFlX9B83x3/cIy6BoQwAAMWBschMDt3/18k7ucxQDBaVWj7pV9Z8JagZymDb7XgRfpoJAChCxiIzatNbvSbtynVWmYkBt7/wN18JNevVi5m26rdb7Xu753LKN20og86fkZcAgHaNTVMAACAASURBVKJlLDJLD//5Sp/E+4+VpOgbwbuWz/vR5uW1n5kxL4WhDAAAxYOxyLRwKOuZ44udV9U6zZrbdq318sbQH/ua80sfQxkAAIqBfP4bSrd69Rxm7D8lfZuZtwzzDGUAAMCjk5+7UA33Lv2xavPlMmWM3qpjCsO9W6Hnr8ZZl3av6OVVsZxbZl7GhWz/Ycd/SY9inQAAqGYsMu8s7e6YnYOtjaN3j8V3ek1+zuhoAQUUG7hksG8pR48q1bzKlG885PP9d7IOeXf7f28Pev+vaDOvEwCA/DE6YF6zYTNndso6RWfl4FaxRouuHWs5m7eE1MCPBo3f4jhy3poeNWzC9q36eKp/86Nrd67o78UPMQEA2mEsMu0aPPtag8Ip4eKWP0LafnRz6Vh3EZGeTw/s90m/JwZ3nuS0d1HXR3IKGACAAjAWmYln/94QGGFlkdf9Nzb9+/cyQwmRkZEOVarcHy/ducnrG/+I69Sp/5Mef+94t5mjGVYBAIDJjEVm7LYPBk0MyPu5booSnvcSqlSrWTN+7fqtUV2fcMmY5Njivc0/32rb94kuSb9uHGGGdQAAYCpjlwvdJvwaMM2/1YAP1wYcCw69du3imWM7f/h4cItGg5cduXU7zVnzlOA6aOpoi+W96/u/tzPL4Otlnvzqnz/HyRddfLt9/Z95VgQAgAmM/i7z0JyRmzr+HjitTvqp2QoVvGs1aN/JtXPV97b3/22Qi7HnFYBdly/3/s9z2qdxidn+q5iuTMfZu093W/zOG3NvO9pwKxAAoGgZS6KYwMALVX0e+D9fZerUdjh6NNjcVVh6Pjn9u60fdXvgyqm+ov/kFQeuRG4aXdrc6wQAIF+MRaZ92bL2ASu/OhGX9ReSqdc2Lv39ppubW2FUBgCAphg7MWvZ/eW3fPxf9fNY2KBJHU83FxtDzM1zgYdPhrn0+e6FaoVaIgAAWmD0EqFN4+n/BG35bHxnL8uYa+dDzl2Nsav51Bsr9hz/eUiFwiwQAABtyGtYdruqXSd90nVSodUCAICG5fmfTJTokK2//Pr3oeAr4X6Tf36lpYSfCkyo0cBTX1jVAQCgGcYjM+H4gqe6vr7tjkNFb6foc4lPi0jqntltJln/eHJFD3P+xgQAgOLA6LXMC4vGvnm23eKjNyOu7n+zUdo0y97vzSi35vNfIwurOgAANMNYZCbs3nnQ/62vRjd0s8wyVefTtUvlkJDzhVEZAACaYiwyDYoilpaWD0yPjo7W6fIaqx0AgJLJ6FAGzVvU+/uT19aHZhn2VeKDF3+8Lr5VK9/CqAwAAE0xevtPnUkLx//Qs3/1jdUb++rPSfTH3du9e2R/iMWTy/b1tDX2JAAASizjo52X6vjZsf8CPh/dtrKze/UmFWwNHv4TVxwI2jD8gYFnAQB4DBj7lpl8cOnUzW4T3x83x39coRYEAIA2Gf2WeWn7119sPmsozFoAANAwY5Gp7/vhqsFXFoz+dHPgpdsxiSlZpBoUI08CAKDkMhaZkd+/+dKPhw+sfqVnQ293Z1t9Fh6TdxVqiQAAaIGxa5l2jZ97+73O1tZ6ywdu9rH1rfmIiwIAQHuMRaZt/X6T6hdqJQAAaFrOE7PbPhzy7qawLBPiA3+c992BiMKsCQAADcoZmSHb1vxxMibLhLg9i6cu2H6rMGsCAECDjA9lAAAAsiAyi41Tp06NGDFCZxq9Xr9v376ifikAUCwZ/xfT0JikpKT333+/b9++pjQyceLEiAiuTANAQfAtEwAAVXL5lnn39PaNG09mPIoJCpeoM39v3BicMcWmapvu9csUTnkAAGhFLpF5fvW4vquzTzo1se/azAduE3aGf9n+0ZYFAIDW5IzMiQHKxCIpBAAAbeNaJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACooqkB81Jjb148F3ojMjZR0du7eFSu7lPRWV/URQEAICJaiUzDzYDP3p656Jc956NSs0y2cKzUss+Yt2dN7eZtXWS1AQAgItqIzLubRrfos96pz5h3VrTy8/Es62yv16XEx4RfOxe0b/N3C3s02bvs8Obh3rqirhMA8FjTQGRe/37OKsc3Dx/+oKFN9hmNW3Z86vnJ49s9UWf6gn+Gf96uaMoDAEBENHH7z6WLF0u37ZIzLzNYVHqqZ4MbZ8/GFm5RAADkoIHI9PT0jDi4LyTVyOyIPXtOu3p5ORZqTQAA5KSBE7Negyc/9eGwTp1vTh3bu41fNc+yznbWutSEmPBr50/u/2Plwi+2Vp52sFNRVwkAeNxpIDLF47m1/yhvvTTzncGfxxiyzdHZebUZPG/33PF+WqgTAPBY00YU2dUe8unWIXMjzp84ERIaFhmXKHp7F3fP6nX9arrbFnVxAACIaCUy0+hdPCpUjEmysEsfysCzvCt5CQDQCm1EJkMZAAA0TwuRyVAGAIBiQAORyVAGAIDiQAO/y2QoAwBAcaCByGQoAwBAcaCBE7MMZQAAKA40EJkMZQAAKA60EUVmGsrg9u3bGzduVBTF2NykpCQzVQwAeOxoIzLTmDyUwa1btw4fPmxsbmxs7L1790yuEgDwmNJGZJppKANfX98lS5YYmxsUFFSqVCmTawUAPKa0EJkMZQAAKAY0EJkMZQAAKA408LtMhjIAABQHGohMhjIAABQHGjgxy1AGAIDiQAORyVAGAIDiQBtRZKahDAAAeHS0EZlp9KV9Gvn7NMo5OSX6xtV7jpXKOWnguisA4PFVDGLo6tK+VQZ+G1HUZQAAHnPFIDIBANACDZyYvRqw5JfAeOPzI/65WXjFAABghAYi88Kv77z8ZaSNtaWR+UpqkrQu1IoAAHiQBk7Mthw5tr5ji4+C7iXkLmR2s6IuEQAALUSm3m/68kl3Zgz//Kzh4QsDAFBENBCZIjZN3v1x5dPWl67k+r+hbSrUbV6nnL6wiwIAIBsNXMsUEbGp1/+VekbmlR+87MDgQq2mBFMUJTY2NjIy0pRGrK2tHRwczFUSABQXGolMFJLg4OCRI0daWZm03e/duxcYGOjr62uuqgCgWCAyHy+pqamffPKJv7+/KY0MHjw4Li7OXCUBQHGhiWuZAABoH5EJAIAqRCYAAKoQmQAAqEJkAgCgCpEJAIAqRCYAAKoQmQAAqEJkAgCgCpEJAIAqRCYAAKoQmQAAqEJkAgCgCpEJAIAqRCYAAKoQmQAAqEJkAgCgCpEJAIAqVkVdAIqf6Ojo7777bufOnaY0otfrJ02apNfrzVUVADxqRCby7fbt21euXImPjzelkZ9++qlfv37e3t5mKgoAHjkiEwUxcODAevXqmdLCli1bzFUMABQOrmUCAKAKkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqhCZAACoQmQCAKAKkQkAgCpEJgAAqjDGLIrG7du3q1SpYmIjdnZ2d+/etba2NktJAJA3IhNFw2Aw/PXXXxUqVDClkaZNm6akpBCZAAoHJ2YBAFCFyAQAQBUiEwAAVbiWiWLMYDDs3LnTxsbGlEbc3d3r169vrpIAlGBEJoqxpKSk999/38Ki4CdLDAZDSEjI3bt3zVgVgJKKyETxtmjRIltb2wI//d69e506dTJjPQBKMK5lAgCgCpEJAIAqRCYAAKoQmXisJSUlJScn60zm5+dX1C8FwCPH7T94rKWmplpYWJw4ccKURq5duzZu3DhzlQRAszQVmamxNy+eC70RGZuo6O1dPCpX96norC/qooCHiYmJuXr1qo+Pj4nt+Pv7r1ixwiwlAXgUtBGZhpsBn709c9Eve85HpWaZbOFYqWWfMW/PmtrNm3G3oV1xcXGlS5detGiRKY2EhISsW7fOXCUBeBS0EJl3N41u0We9U58x76xo5efjWdbZXq9LiY8Jv3YuaN/m7xb2aLJ32eHNw711RV0nYJSVlZWnp6cpLYSGhp47d27AgAGmNBIZGRkUFOTo6GhKIyIyZsyYN954w8RGgJJHA5F5/fs5qxzfPHz4g4Y5hj1r3LLjU89PHt/uiTrTF/wz/PN2RVMeUChu3brl6OjYokULUxr5888/q1SpMnPmTFMaWbt27apVqy5cuGBKI2FhYampqSb+c7ekpKSOHTvWqVPHlEZu3rxpaWlpZWXSe11qamqDBg1M/Ddztra2dnZ2prSAIqdTFKWIS9j/asWn7q29vdjfyPyrn7bx2jIsZsuoh35y3rVrV9++fY3NjYuL+/3337t27Zqv6r766qtXXnnFxFFM4+LirKysTGwkNjbW2traxIM2JibGzs7OxLePmJgYe3t7S0tLUxqJjo52dHQ0Zay7tEacnJx0uoKfgVAUJSEhwcQ3stTU1ISEBAcHB1MaSU5OTkpKMrGRxMTE1NRUe3t7UxqJj49PTk42pQXkSqfTOTs7m7jPx8fH29ramrLPpzVienjHxMSkpKSY2MgTTzzx119/mdhIYdJAZF5Z2Nx7dZ/Th96qmetbcMQP/auNd10X8c3Do05RlDwGC01KSvLw8MhvdQaDISoqKr/PyiElJUWn05mYMcnJyVZWViYeKomJiSYmt4gkJSWZ/l+dzdJIcnKyXm/qHWLaeTlmacT0TawoSkpKiokdm5qaqiiKiR/OUlJSLCwsTMyYpKQkvV5v4oGjne1bwg6cYvfNWwORKWFr+voOO1Rv/NSxvdv4VfMs62xnrUtNiAm/dv7k/j9WLvxiq8O0g4fe9tPAOWQAwGNMC5EpEn/m+7demrni7/MxhmzTdXZebQa/OW/u+GauRVQZAADptBGZaZIjzp84ERIaFhmXKHp7F3fP6nX9aroX/J9UAABgRlqKTAAANIwxZgEAUIXIBABAFSITAABViEwAAFThx44PsWfPnu3bt5s47lcJExISUrVqVdN/Cl1iGAyGM2fO+Pr6FnUhGhIeHp6cnFy+fPmiLkRDgoODfXx8OHAypaamRkZGTps2ragLyQfumH2IV199dfv27SaO/FnCbNy4sVWrVu7u7kVdiFbExMRs2rRp0KBBRV2IhgQGBiYlJTVr1qyoC9GQ9evXt2/f3s3NragL0Yq7d+8GBASEhYUVdSH5QGQ+xPz582/cuDFv3ryiLkRDmjdv/sUXX/BumOnixYudOnUycRzzEmbOnDlRUVGzZ88u6kI0pGHDhitXrmzQoEFRF6IVISEhvXv3Dg4OLupC8oFrmQAAqEJkAgCgCpEJAIAqRCYAAKoQmQAAqEJkAgCgCpEJAIAqROZD6PV6KyvGSMrGysqKPsmKDnkQB86D2E9yKI4dwlAGD5GQkJCamurg4FDUhWhIRESEq6urTqcr6kI05M6dO4zqkhUHzoPYSR5U7PqEyAQAQBVOzAIAoAqRCQCAKkQmAACqEJkAAKhCZAIAoAqRCQCAKkQmAACqEJkAAKhCZAIAoAqRCQCAKpYzZ84s6ho0LCn8bGDQubAkh7Kudo/Tp4vEyEvBp87eTLB2dnHQZx9KNiXyYlBQyLV7NmXcHCxF7aySIuq/fQdOxTpWLmufZeK9G2eOn7oYrjiXdbHJMe5uHrNKgKTw/wKDzt9JdXArZWuRY47RA6ckH1NKwp1LZ079F5b4mB84CZeP7D0WYVfZ3THHTl+wTtBW/ygw4ur/pjRzs7RydCttb2ldsfOcfVFFXVGhSDm3blyLspZi7ehkqxOnOs8uPR6fMS9y13udyust7FzdHK0sy7R89a8wRcWskiPit+c9RGye25A5JfnsmhfqOlnond1K2VrY+fT/OihRxayS4Nbfb7bz0Oud3ErZWthW6rXgyL2MOXkcOCX5mEo8tWJoQ1dbV+/adaqWtnWu88yXh+My5j1GB07yjYCPn65uJyK9Vydnm1OwTtBc/xCZRlz7ppO9TeOpf4clK0ri5fUjqlmUG/FX3MOfV9yd+KCBlW3DV7dcSVSUlLDdU5vYWPrOOKkoiqJEbXiutEW1Ub+GJihK8q2AVxvaOD/1XfjDZpUc0VtHeFasUCFLZBpOz2pgVarD7MORqYoSd2ZZXw+L6tMOpTxkVklwY3l3Z5d27x+4k6IocWcW9SgttWecMChKngdOiT6mAmf4Wrj2+OZ8gqIoSuLlVf3K6rym7DMoymN14FxY2snVxW/4wkmtckZmwTpBg/1DZObuv9mNxW3E1qSMxxGruun1vVdHF2VNheHO/97q1WPm35mvO35NXwtpuyhMUZTIb7pa2j71XWYXJGwa5iLNF17Oe1aJEbdjQtVSPZfN650lMve/WlF8ph3NXObinCZSeuSfKXnPKgGC3q2Z9dUZ7oSeDbuXqih5Hjgl+pgK/7K96Pp8n/niUn4ZaCkNPz6vPF4Hzrnflvx5KUmJ+aZrjsgsWCdosX9K2sUEM0nYt++YrkXbNvqMCa6tW9dJ3rPnYFEWVRhK9/zo900zOma+bisbG0tJSkoSkX/37Uv1a9vWKWOWTevWTeTQnr2Jec4qIRIOzHhxVcUPPn/BI8vEy/v2XXNq07ZB5gTv1q0rRuzZcybPWSXA5W3bQjx7PdVQibkSdHD/4XMRTpWru9tZSJ4HTsk+ppwrVnRUrl69nvH4zs2bqdYVKpSRx+vA8XlqTLdK+lxmFKwTtNg/RGauLoeGGty8vOzuT/H09JQ7oaGxRVdTUQhbs2qLoVHvnp4iEaGhMeLl5Xl/ZilPTwdDaOiVvGaVDMnHZo1eVGr61+OqZLubITQ0VCp6eWWZ5unpKaGhoXnOKgGCg4OlfOLO530r1evWr0fr6uUrd/34QKxIngdOyT6m9D2nfdwx9ONnxn3+yx9/bvjmzWc/ONZq5nsDnB/vAydTwTpBk/1DZOYqLi5O7OyyHN1ia2+vk9jYEnF4qxR/YsHgl/6q8NqXL1WTtC7R29lZZVnA3t5eYmNj85pVEqSe+Hj0AsNLX79WJ8fR8uBeYm9vL4mxsSl5zSoB7t6NkqOrNngsCom4fi0ibP9bVfa8NXT20ZQ8D5wSfkxZ1X76nSktrq2c/tJLL7009dPTNUe/8Ww9a3mcD5wsCtYJmuwfIjNXer1eUlNTs0wxpKQootfnds6hRIraN6ub/5uX+qz986OW9iK5dYmkpKSIXq/Pa1bxZzj76egP74xZ/E6jB17Ng687JSVFdHq9ZV6zSgh9rzc/6uBuISKlWrzzwRD3s2vWHs7zwCnZx1TKwWkdunxpM+tE2LX/zl6+fX5ZzU392o7dEvv4HjjZFKwTNNk/RGau3N3d5U54eJYp4eHhYu3hUarISipMNzeNb9P5k+hhv+9Z2b9S+i5S2t3d0hAeHnl/qZTw8Cjx8PDIa1axd3P5pHdPNh3SxfBvQEBAQMCuM+FiCDsZEHDwYqy4u7tL+AN7ibuHhy6vWSVA6dKuUrpcOeuMx1a1avnI1cuXlbwOnJJ9TO1a9vWZaqNmjqie9vmyYq/3JrS4/t2yTYmP64GTXcE6QZP9Q2Tmyr1ePffEU6fOZU4wBAWdkrp+fiXmS4Jxcfun93xmrcv07bsWdCt3/x3eul69mnLq1Kn7C54MCjJU8PMrk9esYi/8TmL5ctfXTRmV5sXlgZJyYNGoUdM2XpEa9erZ3Dh1KiJz4figoHOWfn51Ja9ZJUDdunUl7OLF+MwJd+/elTLu7rq8DpwSfUyl3r0bKy4uLvenODo6Smp0dNzjeuBkV7BO0Gb/FOXtuhqWuH2sh9SafjT9pvHIXwe7WfjNDinaogpD/O7JlS18Jv5998FZgW/Xlgojt8WmPUrYPbmqVHppf+pDZpUsyauz/sjk7g99HK3aLLxgSHt4bWknO5uu39x4yKwS4NLnrays2392MW0Lp5yYWVfn2G9thJLngVOij6ngmXXF8anv7mQ8vvfXaHep8Mo+RXkcD5wHf2RSwE7QYP8QmcZcXd3Hw7Jc2/EfLJz/9nP1nfW1X94ZU9Q1PXoX5rXQi0/fmXOz+T3YoCiKErFlVBVL18ZDZyxY+P7olmUsKz6/IWMojjxmlSjZI1NJOb3Q38nau/srcz795PWnqts6NPvweNJDZ5UA8Qfebmhr5d3t5dnzP5zgX97CofnHp9LfyPI4cEryMRWxeZSXpXPDF2Yt/X7tyvmT25fXl+37ffpHpMfmwLm5e9ncuXPnzv3wmZoivoM+njt37ty5v55MUpSCdoL2+kenKEpRfsnVsuQr2xbNX7n9TIRVhcZ9Jrw2tIlribgQlacjc3u+uvmB+9H83/37vY6WImK4tf+beV//ERSmlPHtNua1F9uVzzyrlsesEiR129ud5tp9sHV6m4wp8SEbP/107Z4LMXbeLZ+d8uoztR1ExawSICbohwVf/Hzg0j0H75b9X5oy0Nc5Y04eB05JPqaUqBM/frF0y7ELtwylvet1GDp5WPMyGRe+HpMDJ2Tpcy+uvZZjYss3/5zdzU4K2gla6x8iEwAAVbj9BwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMQK2rn7bRZaF3KletUfeXVhyJVB7+3B/663Sdv777KMpKPb2kf72yDrYO/b+/Z75W8yg46yxjfwMlklVRFwAUL83e3rmot6OIKIl3rx7/Y+F7I1vtvrL/8IxGlnk+rdXL69YlN3V4aPOn3qvdI2Z16Lwm6iv656vp6293WXXogycq2apZvgCryM7Ya8k23eS1ABpEZAL54lS5QZMmpdL+btq6c2f365We+eyrne8u66zL62mVWg+spKL12CNHzkqN/FV0584dqdnuyXo+ZVUtXpBVZGfstWSdbvpaAA3ixCxgCqdGjapL5OXLMWkPY48tn9ClTnlHG2v7Mj6tBn+482b6SdusJy1/ftbK8tl1lza+3rlmGXv7UpUaD/j03ygROTmzrtPQ/xkuzW+q07X59Gr2FeXecuDbtXT9fxDZPd5dp+u2LDbLEwxXtswc0Lyqh5OtnUv52h1GLfo35sFVJIasfbV34yplnWztSnv5dp28+nTWc7sWCSeWjmjhXcrWxsmr6XNfHY198LVklTk961ocHBx1pYZsSri/2PUv/C1se5jS6UBRITIBU6RevHhFHMuXdxQRuf7d4A5jNtqPWn3owqWTf8z0Pf5Btyc/OvPAlU693spwfM7Yb0u/8tOB04d+es5m8yvDF5wS8X376N7XqkqlKXvj43dM8sz6FGMt+80Mil/7jEjbL67Gx/9vuOP9Z9xcOrzvwltdl+wMvhwa+Ns7tf99tdvkzfE5VhH82bAx38b0Wbbr1IWQ3V/3jV45tNc7e1My2zi98JUNVaavP3h87/J+ht8m9H59d5KqTsm6lsgj0/2iNq7ZnBnFtzdu2GvXY0h+OxrQBAWAOlcWthbp9E1k2iNDYtTVf9e8WN9GV2XSzgRFUZT/ZvmJTbdldzKWT9g83FXKTdmjKIqy7mmRTovTnrrhORux77UmIn2xmFU9Rbp/G6coinLoDR+p/OqhnGvOq2Xl52dF/BffzvGUv0e7Sv33T2c8TLwRcvJKVLLxVSiKkvLb807iO+OMklGwvtM3YenzUndPLi8uY7YacrwWY39nWcvVBa0s7PutjUlrKHxZZ0un5zbE5d7FgLbxLRPIl79Hu6bdMGth4+LZbPj/3Cb8uHVuexsRST569ITUaNmydMaiNk2b1pObgYFhuTRTo3lz1/Q/HUuXtpbIyEjj68xXy+ka9njK8+RHT/V8Zd6a7SdvJ1mXq+Hr6Zz3vQuWnp7lJDw8/H6Rbdq4p/9p4edXV6KCg2/m2UKuKj43tFPS5jUbo0REIv+3IcCl35An7fPfDlD0iEwgX5q/u/vYsWPHjh0LDAq5Gh13bcf8Z6rZiIhIXHS0QVxdXe8vW6pUKZGYmJhcmnFwuH/HqU6nE0XJ45cq+Wo5nWvv5fu3ftTNYvfC0U/UK1e2Rq/p/7ucknMh5WbA3FHdGvmUK+Voa21t1WzOf9lmu7m5Zf7t6OgoEhcXZ3yNRrk/O6y7xda16++IxPzv1+1uA57vYl2AZoCiR2QC+eLoVa9BgwYNGjTwq1ejolPWr22OLi6W2b8tRkREiLi4uJi8zgK1bOnZ6eUvfj98LTIs6PcZjc7Mffq5RRezL3Hpy2d7vLPPfcJ3+8+HRccnphx8o1q2+VFRUZl/x8XFiTg5ORWkfpe+w/rYbfth/Z24PzZsKzNoSIe8f5ADaBaRCZiJVZOmDSRk376IjAnxBw4ESeWmTdX9+MO8Lcdd2rd5z8VUERGbsvV6vLL41bbJgYGnsy2TfGDHnnutJs4b2bqKm4O1pVze/c+lbAucPXQoIzOVoKCT4lanjkeBXoBdz6EDXHauX7t6/V8VBj/fmrcdFFfsu4C5VBn+aj+HbTNHfbbz7PUb5/Ytf/H1nwz+r72Ynx/zu7q6ys3DO/49E3w160nX/LectP+TQU/0m/Dt3uArN65dOLLx49X/OrRr1yjbKsLcvCvI8U1rDl0Ju3Zmx1cjxh11ry+RFy/cFUk7UexybNHYxXvOXb92ZvNbry2/UeX559sW8IVYdxk2yCPg3bc2ez83pFE++gPQFiITMBuPQd/t/KZ3zNeDGnpX9uvzydV283dsnFglPy34DHplUJXAmZ38X1gRbFLLrgNXbf2k8blPBrSs6V2t8VNvHaj93h+rhpfPvgqXad+93/LyJx2rV2nQZ9aZzvOXffbKAK/dY6t0+OJ8cnKy6FrN+Lz9v692qu3TYOBapd/S3z5qoXrsk5wvxKL1sOcr373rM2RI/fz0B6AtujzvOgAAs4j5/YXqz954L3TbiwU7twtoAQPmAXiUEu9ev3E1cM2ro9e5vrxvOHmJYo0TswAepZMLOtZqPGhZwsB1m2c15cclKN44MQsAgCp8ywQAQBUibUO9/gAAAG5JREFUEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQBUiEwAAVYhMAABUITIBAFCFyAQAQJX/A3by+ARHCEs1AAAAAElFTkSuQmCC" /><!-- --></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">quantile</span>(pos, <span class="kw">c</span>(.<span class="dv">8</span>, <span class="fl">.9</span>, <span class="fl">.95</span>), <span class="dt">na.rm =</span> T)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">#&gt; 80% 90% 95% </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co">#&gt; 141 208 276</span></span></code></pre></div>
<p>Note that no warning message appears if the corridor is not reached, but instead an NA value is returned. Pay careful attention if you work with this function, and adjust the maximum sample size as needed.</p>
<p><strong>create_pop</strong> creates the population matrix by using a method described on SO (<a href="https://stats.stackexchange.com/questions/15011/generate-a-random-variable-with-a-defined-correlation-to-an-existing-variables/15040#15040" class="uri">https://stats.stackexchange.com/questions/15011/generate-a-random-variable-with-a-defined-correlation-to-an-existing-variables/15040#15040</a>). This is a much simpler way than Schönbrodt and Perugini’s approach, but the results do not seem to differ. If you are interested in how population parameters (e.g. skewness) affect the point of stability, you should instead refer to the population generating functions in Schönbrodt and Perugini’s work.</p>
</div>
<div id="parallelization" class="section level2">
<h2>Parallelization</h2>
<p>Since version 0.4.0 <em>fastpos</em> supports multiple cores. My first attempts to implement this were quite unsuccessful because of several reasons: (1) Higher-level parallelism in R makes it difficult to show progress in C++, which is where the important and time-demanding calculations happen (2) some parallelizing solutions do not work on all operating systems (e.g. mcpbapply) (3) overhead can be quite large, especially for a small number of simulation runs.</p>
<p>I thought the best solution is is to directly parallelize in C++. I tried to do it with <em>RcppThread</em>, but in the end this was even slower than singlethreading. I assume that a more experienced C++ programmer could make it work but to me parallelizing in C++ feels a bit like torture.</p>
<p>My final solution was quite simple and pragmatic: to use <em>futures</em>. I divide the number of studies by the available cores, then start n_cores - 1 futures with n_studies/n_cores simulations each in a multisession plan. Meanwhile the main R process also starts a simulation, wich shows a progress bar in C++. All simulations end at approximately the same time, the progress bar finishes and the futures resolve. The points of stability are combined and the rest of the program works as for the singlethreaded version.</p>
<p>Speed benefits are non-existent for a small numbers of studies, since <em>fastpos</em> is already too fast:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>onecore &lt;-<span class="st"> </span><span class="cf">function</span>() {<span class="kw">find_critical_pos</span>(<span class="fl">0.5</span>)}</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>multicore &lt;-<span class="st"> </span><span class="cf">function</span>() {<span class="kw">find_critical_pos</span>(<span class="fl">0.5</span>, <span class="dt">n_cores =</span> future<span class="op">::</span><span class="kw">availableCores</span>())}</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(<span class="kw">onecore</span>(), <span class="kw">multicore</span>(), <span class="dt">times =</span> <span class="dv">10</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">#&gt; Unit: milliseconds</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="co">#&gt;         expr      min       lq     mean   median       uq      max neval cld</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co">#&gt;    onecore() 999.9301 1028.469 1092.582 1096.347 1117.159 1306.267    10   a</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="co">#&gt;  multicore() 956.1311 1024.522 1267.423 1092.255 1125.526 3027.130    10   a</span></span></code></pre></div>
<p>When increasing the number of studies, the benefit becomes visible, but the difference is not gigantic:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>onecore &lt;-<span class="st"> </span><span class="cf">function</span>() {<span class="kw">find_critical_pos</span>(<span class="fl">0.5</span>, <span class="dt">n_studies =</span> <span class="fl">1e5</span>)}</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>multicore &lt;-<span class="st"> </span><span class="cf">function</span>() {<span class="kw">find_critical_pos</span>(<span class="fl">0.5</span>, <span class="dt">n_studies =</span> <span class="fl">1e5</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>                                           <span class="dt">n_cores =</span> future<span class="op">::</span><span class="kw">availableCores</span>())}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(<span class="kw">onecore</span>(), <span class="kw">multicore</span>(),</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>                               <span class="dt">times =</span> <span class="dv">10</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="co">#&gt; Unit: seconds</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="co">#&gt;         expr      min       lq     mean   median       uq       max neval cld</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a><span class="co">#&gt;    onecore() 7.948525 8.203709 9.314504 8.951659 9.881046 12.846380    10   b</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a><span class="co">#&gt;  multicore() 5.288073 5.884233 6.867288 6.565180 8.083799  8.321451    10  a</span></span></code></pre></div>
<p>The test was done on my local computer with 4 cores.</p>
</div>
<div id="how-fast-is-fastpos" class="section level2">
<h2>How fast is <em>fastpos</em>?</h2>
<p>In the introduction I boldly claimed that <em>fastpos</em> is much faster than the original implementation of Schönbrodt and Perugini (<em>corEvol</em>). The theoretical argument goes as follows:</p>
<p><em>corEvol</em> calculates every correlation from scratch. If we take the sum formula for the correlation coefficient</p>
<p><span class="math display">\[r_{xy} = \frac{n\sum x_i y_i - \sum x_i \sum y_i}
{\sqrt{n\sum x_i^2-(\sum x_i)^2} 
 \sqrt{n\sum y_i^2-(\sum y_i)^2}}\]</span></p>
<p>we can see that several sums are calculated, each consisting of adding up <span class="math inline">\(n\)</span> (the sample size) terms. This has to be done for every sample size from the minimum to the maximum one. Thus, the total number of added terms for one sum is:</p>
<p><span class="math display">\[\sum _{n_\mathrm{min}}^{n_\mathrm{max}}n = \sum_{n=1}^{n_\mathrm{max}}n - \sum_{n=1}^{n_\mathrm{min}-1}n = n_\mathrm{max}(n_\mathrm{max}+1)/2 -(n_\mathrm{min}-1)(n_\mathrm{min}-1+1)/2\]</span></p>
<p>On the other hand, <em>fastpos</em> calculates the correlation for the maximum sample size first. This requires to add <span class="math inline">\(n\)</span> numbers for one sum. Then it subtracts one value from this sum to find the correlation for the sample size <span class="math inline">\(n-1\)</span>, which happens repeatedly until the minimum sample size is reached. Overall the total number of terms for one sum amounts to:</p>
<p><span class="math display">\[n_\mathrm{max}+n_\mathrm{max}-n_\mathrm{min}\]</span></p>
<p>The ratio between the two approaches is:</p>
<p><span class="math display">\[\frac{n_\mathrm{max}(n_\mathrm{max}+1)/2 -(n_\mathrm{min}-1)n_\mathrm{min}/2}{2n_\mathrm{max}-n_\mathrm{min}} \]</span></p>
<p>For the typically used <span class="math inline">\(n_\mathrm{max}\)</span> of 1000 and <span class="math inline">\(n_\mathrm{min}\)</span> of 20, we can expect a speedup of about 250. This is only an approximation for several reasons. First, one can stop the process when the corridor is reached, which is done in <em>fastpos</em> but not in <em>corEvol</em>. Second, the main function of <em>fastpos</em> was written in C++ (via <em>Rcpp</em>), which is much faster than R. In a direct comparison between <em>fastpos</em> and <em>corEvol</em> we can expect <em>fastpos</em> to be at least 250 times faster. For a quick empirical benchmark see the README-file of the package on github: <a href="https://github.com/johannes-titz/fastpos" class="uri">https://github.com/johannes-titz/fastpos</a></p>
</div>
<div id="faq" class="section level2">
<h2>FAQ</h2>
<div id="what-does-fastpos-do-if-the-corridor-of-stability-is-not-reached-for-a-simulation-study" class="section level3">
<h3>What does <em>fastpos</em> do if the corridor of stability is not reached for a simulation study?</h3>
<p>In this case <em>fastpos</em> will return an NA value for the point of stability. When calculating the quantiles, <em>fastpos</em> will use the maximum sample size, which is a more reasonable estimate than ignoring the specific simulation study altogether.</p>
</div>
<div id="why-does-fastpos-produce-different-estimates-to-corevol" class="section level3">
<h3>Why does <em>fastpos</em> produce different estimates to <em>corEvol</em>?</h3>
<p>If the same parameters are used, the differences are rather small. In general, differences cannot be avoided entirely due to the random nature of the whole process. Even if the same algorithm is used, the estimates will vary slightly from run to run. The other more important aspect is how studies are treated where the point of stability is not reached: <em>corEvol</em> ignores them, while <em>fastpos</em> assumes that the corridor was reached at the maximum sample size. Thus, if the parameters are the same, <em>fastpos</em> will tend to produce larger estimates, which is more accurate (and more conservative). But note that if the corridor of stability is not reached, then you should increase the maximum sample size. Previously, this was not feasible due to the computational demands, but with <em>fastpos</em> it usually can be done.</p>
</div>
</div>
<div id="issues-and-support" class="section level2">
<h2>Issues and Support</h2>
<p>If you find any bugs, please use the issue tracker at:</p>
<p><a href="https://github.com/johannes-titz/fastpos/issues" class="uri">https://github.com/johannes-titz/fastpos/issues</a></p>
<p>If you need answers on how to use the package, drop me an e-mail at johannes at titz.science or johannes.titz at gmail.com</p>
</div>
<div id="contributing" class="section level2">
<h2>Contributing</h2>
<p>Comments and feedback of any kind are very welcome! I will thoroughly consider every suggestion on how to improve the code, the documentation, and the presented examples. Even minor things, such as suggestions for better wording or improving grammar in any part of the package, are more than welcome.</p>
<p>If you want to make a pull request, please check that you can still build the package without any errors, warnings, or notes. Overall, simply stick to the R packages book: <a href="https://r-pkgs.org/" class="uri">https://r-pkgs.org/</a></p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references hanging-indent">
<div id="ref-algina2003">
<p>Algina, J., &amp; Olejnik, S. (2003). Sample size tables for correlation analysis with applications in partial correlation and multiple regression analysis. <em>Multivariate Behavioral Research</em>, <em>38</em>, 309–323. <a href="https://doi.org/10.1207/S15327906MBR3803_02">https://doi.org/10.1207/S15327906MBR3803_02</a></p>
</div>
<div id="ref-schonbrodt2013">
<p>Schönbrodt, F. D., &amp; Perugini, M. (2013). At what sample size do correlations stabilize? <em>Journal of Research in Personality</em>, <em>47</em>, 609–612. <a href="https://doi.org/10.1016/j.jrp.2013.05.009">https://doi.org/10.1016/j.jrp.2013.05.009</a></p>
</div>
<div id="ref-schonbrodt2018">
<p>Schönbrodt, F. D., &amp; Perugini, M. (2018). Corrigendum to “At What Sample Size Do Correlations Stabilize?” [J. Res. Pers. 47 (2013) 609–612]. <em>Journal of Research in Personality</em>, <em>74</em>, 194. <a href="https://doi.org/10.1016/j.jrp.2018.02.010">https://doi.org/10.1016/j.jrp.2018.02.010</a></p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
