% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_lambda.R
\name{plot_lambda}
\alias{plot_lambda}
\alias{plot_lambda.glmsmurf}
\title{Plot Goodness-of-Fit Statistics or Information Criteria}
\usage{
plot_lambda(x, ...)

\method{plot_lambda}{glmsmurf}(
  x,
  xlab = NULL,
  ylab = NULL,
  lambda.opt = TRUE,
  cv1se = TRUE,
  log.lambda = TRUE,
  ...
)
}
\arguments{
\item{x}{An object for which the extraction of goodness-of-fit statistics or information criteria is meaningful. 
E.g. an object of class '\code{\link[=glmsmurf-class]{glmsmurf}}', typically the result of a call to \code{\link{glmsmurf}} or \code{\link{glmsmurf.fit}}.}

\item{...}{Additional arguments for the \code{\link[graphics:plot.default]{plot}} function.}

\item{xlab}{Label for the x-axis. The default value is \code{NULL} which means that \code{substitute(log(lambda))} is used when \code{log.lambda=TRUE}
and \code{substitute(lambda)} when \code{log.lambda=FALSE}.}

\item{ylab}{Label for the y-axis. The default value is \code{NULL} which means that the y-axis label is 
determined based on method that was used to select lambda.}

\item{lambda.opt}{Logical indicating if the optimal value of lambda should be indicated on the plot 
by a vertical dashed line. Default is \code{TRUE}.}

\item{cv1se}{Logical indicating if the standard errors should be indicated on the plot 
when cross-validation with the one standard error rule is performed (e.g. "cv1se.dev"). Default is \code{TRUE}.}

\item{log.lambda}{Logical indicating if the logarithm of lambda is plotted on the x-axis, default is \code{TRUE}.}
}
\description{
Function to plot the goodness-of-fit statistics or information criteria
             as a function of lambda when lambda is selected in-sample, out-of-sample or using cross-validation.
}
\details{
This plot can only be made when lambda is selected in-sample, out-of-sample or using cross-validation (possibly with the one standard error rule), 
         see the \code{lambda} argument of \code{\link{glmsmurf}}.
}
\examples{

\donttest{
# Munich rent data from catdata package
data("rent", package = "catdata")

# The considered predictors are the same as in 
# Gertheiss and Tutz (Ann. Appl. Stat., 2010).
# Response is monthly rent per square meter in Euro

# Urban district in Munich
rent$area <- as.factor(rent$area)

# Decade of construction
rent$year <- as.factor(floor(rent$year / 10) * 10)

# Number of rooms
rent$rooms <- as.factor(rent$rooms)

# Quality of the house with levels "fair", "good" and "excellent"
rent$quality <- as.factor(rent$good + 2 * rent$best)
levels(rent$quality) <- c("fair", "good", "excellent")

# Floor space divided in categories (0, 30), [30, 40), ...,  [130, 140)
sizeClasses <- c(0, seq(30, 140, 10))
rent$size <- as.factor(sizeClasses[findInterval(rent$size, sizeClasses)])

# Is warm water present?
rent$warm <- factor(rent$warm, labels = c("yes", "no"))

# Is central heating present?
rent$central <- factor(rent$central, labels = c("yes", "no"))

# Does the bathroom have tiles?
rent$tiles <- factor(rent$tiles, labels = c("yes", "no"))

# Is there special furniture in the bathroom?
rent$bathextra <- factor(rent$bathextra, labels = c("no", "yes"))

# Is the kitchen well-equipped?
rent$kitchen <- factor(rent$kitchen, labels = c("no", "yes"))



# Create formula with 'rentm' as response variable,
# 'area' with a Generalized Fused Lasso penalty,
# 'year', 'rooms', 'quality' and 'size' with Fused Lasso penalties,
# and the other predictors with Lasso penalties.
formu <- rentm ~ p(area, pen = "gflasso") + 
  p(year, pen = "flasso") + p(rooms, pen = "flasso") + 
  p(quality, pen = "flasso") + p(size, pen = "flasso") +
  p(warm, pen = "lasso") + p(central, pen = "lasso") + 
  p(tiles, pen = "lasso") + p(bathextra, pen = "lasso") + 
  p(kitchen, pen = "lasso") 

# Fit a multi-type regularized GLM using the SMuRF algorithm and select the optimal value of lambda 
# using cross-validation (with the deviance as loss measure and the one standard error rule).
# We use standardization adaptive penalty weights based on an initial GLM fit.
# The number of values of lambda to consider in cross-validation is
# set to 25 using the control argument (default is 50).
munich.fit.cv <- glmsmurf(formula = formu, family = gaussian(), data = rent, 
                          pen.weights = "glm.stand", lambda = "cv1se.dev",
                          control = list(lambda.length = 25L, ncores = 1L))


# Plot average deviance over cross-validation folds as a function of the logarithm of lambda
plot_lambda(munich.fit.cv)
# Zoomed plot
plot_lambda(munich.fit.cv, xlim = c(-8, -4), ylim = c(1550, 1750))
}
}
\seealso{
\code{\link{glmsmurf}}, \code{\link{glmsmurf-class}}
}
