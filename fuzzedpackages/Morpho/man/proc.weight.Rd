% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/proc.weight.r
\name{proc.weight}
\alias{proc.weight}
\title{calculate weights inverse to the distances from the specified observation.}
\usage{
proc.weight(data, number, ref, report = TRUE, reg = 0, log = FALSE,
  mahalanobis = FALSE, weightfun = NULL)
}
\arguments{
\item{data}{array containing landmark configurations}

\item{number}{integer: how many of the neighbours are to be involved.}

\item{ref}{integer: position in the array that is used as reference.}

\item{report}{logical: require report about name of the reference.}

\item{reg}{numeric: regularise mahalanobis distance by adding reg to the
diagonal of eigenvalues of the covariance matrix.}

\item{log}{logical: use the logarithm of the distances.}

\item{mahalanobis}{logical: use mahalanobis distance.}

\item{weightfun}{custom function that operates on a vector of distances (see examples) and generates weights accordingly.}
}
\value{
\item{data }{dataframe containing id, procrustes/mahalanobis distance
and weight according to the reference}
\item{reference }{returns observations' names if available}
\item{rho.all }{dataframe containing distances to references of all observations}
}
\description{
for calculation of a shape model by averaging the observations neighbouring
the configuration in question, it is necessary to calculate weights by
similarity.
}
\details{
distances of zero will get a weight of 1e12 (this is scaled to all weights
summing to one), thus weights for observations further away are converging
to zero.
}
\examples{

if (require(shapes)) {
proc <- procSym(gorf.dat)
##get weights for the the four specimen closest to the first observation.
weights <- proc.weight(proc$rotated,4,1)

##estimate the first specimen by weighted neighbour shapes.
estim <- proc$mshape*0;
for (i in 1:4)
{estim <-estim+proc$rotated[,,weights$data$nr[i]]*weights$data$weight[i]}

### visualise
plot(estim,asp=1)## show estimation
points(proc$rotated[,,1],col=3)##show original

## use a gaussian smoother to compute weights using a bandwidth of 0.05
gaussWeight <- function(r,sigma=0.05) {
   sigma <- 2*sigma^2
   return(exp(-r^2/ sigma))
}
weights <- proc.weight(proc$rotated,4,1,weightfun=gaussWeight)
}
}
