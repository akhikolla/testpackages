// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

// buildcov_deriv
Eigen::MatrixXd buildcov_deriv(Eigen::VectorXd& beta, arma::cube& dist, int l, const String& covmodel, const bool& nugget);
RcppExport SEXP _ARCokrig_buildcov_deriv(SEXP betaSEXP, SEXP distSEXP, SEXP lSEXP, SEXP covmodelSEXP, SEXP nuggetSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type dist(distSEXP);
    Rcpp::traits::input_parameter< int >::type l(lSEXP);
    Rcpp::traits::input_parameter< const String& >::type covmodel(covmodelSEXP);
    Rcpp::traits::input_parameter< const bool& >::type nugget(nuggetSEXP);
    rcpp_result_gen = Rcpp::wrap(buildcov_deriv(beta, dist, l, covmodel, nugget));
    return rcpp_result_gen;
END_RCPP
}
// log_objective_prior
double log_objective_prior(Eigen::VectorXd& beta, arma::cube& dist, Eigen::MatrixXd& RInv, Eigen::MatrixXd& X, const String& covmodel, const bool& nugget, const String& prior);
RcppExport SEXP _ARCokrig_log_objective_prior(SEXP betaSEXP, SEXP distSEXP, SEXP RInvSEXP, SEXP XSEXP, SEXP covmodelSEXP, SEXP nuggetSEXP, SEXP priorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type dist(distSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd& >::type RInv(RInvSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd& >::type X(XSEXP);
    Rcpp::traits::input_parameter< const String& >::type covmodel(covmodelSEXP);
    Rcpp::traits::input_parameter< const bool& >::type nugget(nuggetSEXP);
    Rcpp::traits::input_parameter< const String& >::type prior(priorSEXP);
    rcpp_result_gen = Rcpp::wrap(log_objective_prior(beta, dist, RInv, X, covmodel, nugget, prior));
    return rcpp_result_gen;
END_RCPP
}
// buildcov
Eigen::MatrixXd buildcov(Eigen::VectorXd& phi, arma::cube& dist, const String& covmodel, const bool& nugget);
RcppExport SEXP _ARCokrig_buildcov(SEXP phiSEXP, SEXP distSEXP, SEXP covmodelSEXP, SEXP nuggetSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type phi(phiSEXP);
    Rcpp::traits::input_parameter< arma::cube& >::type dist(distSEXP);
    Rcpp::traits::input_parameter< const String& >::type covmodel(covmodelSEXP);
    Rcpp::traits::input_parameter< const bool& >::type nugget(nuggetSEXP);
    rcpp_result_gen = Rcpp::wrap(buildcov(phi, dist, covmodel, nugget));
    return rcpp_result_gen;
END_RCPP
}
// compute_distance
arma::cube compute_distance(arma::mat& input1, arma::mat& input2);
RcppExport SEXP _ARCokrig_compute_distance(SEXP input1SEXP, SEXP input2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< arma::mat& >::type input1(input1SEXP);
    Rcpp::traits::input_parameter< arma::mat& >::type input2(input2SEXP);
    rcpp_result_gen = Rcpp::wrap(compute_distance(input1, input2));
    return rcpp_result_gen;
END_RCPP
}
// sample_mvt
arma::cube sample_mvt(const arma::mat& mu, const arma::mat& L, const arma::vec& sigma, double df, int nsample);
RcppExport SEXP _ARCokrig_sample_mvt(SEXP muSEXP, SEXP LSEXP, SEXP sigmaSEXP, SEXP dfSEXP, SEXP nsampleSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type L(LSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type sigma(sigmaSEXP);
    Rcpp::traits::input_parameter< double >::type df(dfSEXP);
    Rcpp::traits::input_parameter< int >::type nsample(nsampleSEXP);
    rcpp_result_gen = Rcpp::wrap(sample_mvt(mu, L, sigma, df, nsample));
    return rcpp_result_gen;
END_RCPP
}
// compute_S
double compute_S(const Eigen::Map<Eigen::MatrixXd>& output, const Eigen::Map<Eigen::MatrixXd>& Q);
RcppExport SEXP _ARCokrig_compute_S(SEXP outputSEXP, SEXP QSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type output(outputSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Q(QSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_S(output, Q));
    return rcpp_result_gen;
END_RCPP
}
// compute_Svec
Eigen::VectorXd compute_Svec(const Eigen::Map<Eigen::MatrixXd>& output, const Eigen::Map<Eigen::MatrixXd>& Q);
RcppExport SEXP _ARCokrig_compute_Svec(SEXP outputSEXP, SEXP QSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type output(outputSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Q(QSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_Svec(output, Q));
    return rcpp_result_gen;
END_RCPP
}
// compute_S_sum
double compute_S_sum(const Eigen::Map<Eigen::MatrixXd>& y_t, const Eigen::Map<Eigen::MatrixXd>& H_t, const Eigen::Map<Eigen::MatrixXd>& y_t1, const Eigen::Map<Eigen::MatrixXd>& RInv, const Eigen::Map<Eigen::MatrixXd>& K);
RcppExport SEXP _ARCokrig_compute_S_sum(SEXP y_tSEXP, SEXP H_tSEXP, SEXP y_t1SEXP, SEXP RInvSEXP, SEXP KSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t(y_tSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type H_t(H_tSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t1(y_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type RInv(RInvSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type K(KSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_S_sum(y_t, H_t, y_t1, RInv, K));
    return rcpp_result_gen;
END_RCPP
}
// compute_prediction
List compute_prediction(const Eigen::Map<Eigen::MatrixXd>& y_t, const Eigen::Map<Eigen::MatrixXd>& Ht, const Eigen::Map<Eigen::MatrixXd>& y_t1, const Eigen::Map<Eigen::MatrixXd>& yhat_t1, const Eigen::Map<Eigen::MatrixXd>& vhat_t1, const Eigen::Map<Eigen::MatrixXd>& RInv, const Eigen::Map<Eigen::MatrixXd>& Hnew, const Eigen::Map<Eigen::MatrixXd>& Wnew_t1, const Eigen::Map<Eigen::MatrixXd>& Rmo, const Eigen::Map<Eigen::MatrixXd>& R_sk);
RcppExport SEXP _ARCokrig_compute_prediction(SEXP y_tSEXP, SEXP HtSEXP, SEXP y_t1SEXP, SEXP yhat_t1SEXP, SEXP vhat_t1SEXP, SEXP RInvSEXP, SEXP HnewSEXP, SEXP Wnew_t1SEXP, SEXP RmoSEXP, SEXP R_skSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t(y_tSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Ht(HtSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t1(y_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type yhat_t1(yhat_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type vhat_t1(vhat_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type RInv(RInvSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Hnew(HnewSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Wnew_t1(Wnew_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Rmo(RmoSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type R_sk(R_skSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_prediction(y_t, Ht, y_t1, yhat_t1, vhat_t1, RInv, Hnew, Wnew_t1, Rmo, R_sk));
    return rcpp_result_gen;
END_RCPP
}
// conditional_simulation
Eigen::MatrixXd conditional_simulation(const Eigen::Map<Eigen::MatrixXd>& y_t, const Eigen::Map<Eigen::MatrixXd>& Ht, const Eigen::Map<Eigen::MatrixXd>& y_t1, const Eigen::Map<Eigen::MatrixXd>& RInv, const Eigen::Map<Eigen::MatrixXd>& Hnew, const Eigen::Map<Eigen::MatrixXd>& Wnew_t1, const Eigen::Map<Eigen::MatrixXd>& Rmo, const Eigen::Map<Eigen::MatrixXd>& R_sk);
RcppExport SEXP _ARCokrig_conditional_simulation(SEXP y_tSEXP, SEXP HtSEXP, SEXP y_t1SEXP, SEXP RInvSEXP, SEXP HnewSEXP, SEXP Wnew_t1SEXP, SEXP RmoSEXP, SEXP R_skSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t(y_tSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Ht(HtSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t1(y_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type RInv(RInvSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Hnew(HnewSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Wnew_t1(Wnew_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Rmo(RmoSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type R_sk(R_skSEXP);
    rcpp_result_gen = Rcpp::wrap(conditional_simulation(y_t, Ht, y_t1, RInv, Hnew, Wnew_t1, Rmo, R_sk));
    return rcpp_result_gen;
END_RCPP
}
// compute_param
List compute_param(const Eigen::Map<Eigen::MatrixXd>& y_t, const Eigen::Map<Eigen::MatrixXd>& Ht, const Eigen::Map<Eigen::MatrixXd>& y_t1, const Eigen::Map<Eigen::MatrixXd>& RInv);
RcppExport SEXP _ARCokrig_compute_param(SEXP y_tSEXP, SEXP HtSEXP, SEXP y_t1SEXP, SEXP RInvSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t(y_tSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type Ht(HtSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type y_t1(y_t1SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd>& >::type RInv(RInvSEXP);
    rcpp_result_gen = Rcpp::wrap(compute_param(y_t, Ht, y_t1, RInv));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_ARCokrig_buildcov_deriv", (DL_FUNC) &_ARCokrig_buildcov_deriv, 5},
    {"_ARCokrig_log_objective_prior", (DL_FUNC) &_ARCokrig_log_objective_prior, 7},
    {"_ARCokrig_buildcov", (DL_FUNC) &_ARCokrig_buildcov, 4},
    {"_ARCokrig_compute_distance", (DL_FUNC) &_ARCokrig_compute_distance, 2},
    {"_ARCokrig_sample_mvt", (DL_FUNC) &_ARCokrig_sample_mvt, 5},
    {"_ARCokrig_compute_S", (DL_FUNC) &_ARCokrig_compute_S, 2},
    {"_ARCokrig_compute_Svec", (DL_FUNC) &_ARCokrig_compute_Svec, 2},
    {"_ARCokrig_compute_S_sum", (DL_FUNC) &_ARCokrig_compute_S_sum, 5},
    {"_ARCokrig_compute_prediction", (DL_FUNC) &_ARCokrig_compute_prediction, 10},
    {"_ARCokrig_conditional_simulation", (DL_FUNC) &_ARCokrig_conditional_simulation, 8},
    {"_ARCokrig_compute_param", (DL_FUNC) &_ARCokrig_compute_param, 4},
    {NULL, NULL, 0}
};

RcppExport void R_init_ARCokrig(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
