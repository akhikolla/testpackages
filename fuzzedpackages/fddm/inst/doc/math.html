<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Kendal Foster and Henrik Singmann" />

<meta name="date" content="2020-11-04" />

<title>Mathematical Description of Methods</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
      code.sourceCode > span { display: inline-block; line-height: 1.25; }
  code.sourceCode > span { color: inherit; text-decoration: inherit; }
  code.sourceCode > span:empty { height: 1.2em; }
  .sourceCode { overflow: visible; }
  code.sourceCode { white-space: pre; position: relative; }
  div.sourceCode { margin: 1em 0; }
  pre.sourceCode { margin: 0; }
  @media screen {
  div.sourceCode { overflow: auto; }
  }
  @media print {
  code.sourceCode { white-space: pre-wrap; }
  code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
  }
  pre.numberSource code
    { counter-reset: source-line 0; }
  pre.numberSource code > span
    { position: relative; left: -4em; counter-increment: source-line; }
  pre.numberSource code > span > a:first-child::before
    { content: counter(source-line);
      position: relative; left: -1em; text-align: right; vertical-align: baseline;
      border: none; display: inline-block;
      -webkit-touch-callout: none; -webkit-user-select: none;
      -khtml-user-select: none; -moz-user-select: none;
      -ms-user-select: none; user-select: none;
      padding: 0 4px; width: 4em;
      color: #aaaaaa;
    }
  pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
  div.sourceCode
    {   }
  @media screen {
  code.sourceCode > span > a:first-child::before { text-decoration: underline; }
  }
  code span.al { color: #ff0000; font-weight: bold; } /* Alert */
  code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
  code span.at { color: #7d9029; } /* Attribute */
  code span.bn { color: #40a070; } /* BaseN */
  code span.bu { } /* BuiltIn */
  code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
  code span.ch { color: #4070a0; } /* Char */
  code span.cn { color: #880000; } /* Constant */
  code span.co { color: #60a0b0; font-style: italic; } /* Comment */
  code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
  code span.do { color: #ba2121; font-style: italic; } /* Documentation */
  code span.dt { color: #902000; } /* DataType */
  code span.dv { color: #40a070; } /* DecVal */
  code span.er { color: #ff0000; font-weight: bold; } /* Error */
  code span.ex { } /* Extension */
  code span.fl { color: #40a070; } /* Float */
  code span.fu { color: #06287e; } /* Function */
  code span.im { } /* Import */
  code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  code span.kw { color: #007020; font-weight: bold; } /* Keyword */
  code span.op { color: #666666; } /* Operator */
  code span.ot { color: #007020; } /* Other */
  code span.pp { color: #bc7a00; } /* Preprocessor */
  code span.sc { color: #4070a0; } /* SpecialChar */
  code span.ss { color: #bb6688; } /* SpecialString */
  code span.st { color: #4070a0; } /* String */
  code span.va { color: #19177c; } /* Variable */
  code span.vs { color: #4070a0; } /* VerbatimString */
  code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {background-color: #ffffff;max-width: 800px;margin-left: auto;margin-right: auto;margin-top: 0px;margin-bottom: 0px;padding-left: 5%;padding-right: 4%;padding-top: 10px;padding-bottom: 30px;overflow: visible;font-family: Verdana;font-size: 14px;line-height: 1.35;}#TOC {clear: both;margin: 0 0 10px 10px;padding: 4px;max-width: 400px;border: 1px solid #CCCCCC;border-radius: 5px;background-color: #f6f6f6;font-size: 13px;line-height: 1.3;}#TOC .toctitle {font-weight: bold;font-size: 15px;margin-left: 5px;}#TOC ul {padding-left: 40px;margin-left: -1.5em;margin-top: .25em;margin-bottom: .25em;}#TOC ul ul {margin-left: -2em;margin-top: 0px;margin-bottom: 6px;}#TOC li {list-style: disk outside;line-height: 1.4;margin-bottom: 5px;}#TOC li li {list-style: circle outside;line-height: 1.2;margin-bottom: 0px;}table {margin: 1em auto;border-width: 1px;border-color: #DDDDDD;border-style: outset;border-collapse: collapse;}table th {border-width: 2px;padding: 5px;border-style: inset;}table td {border-width: 1px;border-style: inset;line-height: 18px;padding: 5px 5px;}table, table th, table td {border-left-style: none;border-right-style: none;}table thead, table tr.even {background-color: #f7f7f7;}p {margin: 0.5em 0;}p.method {background-color: #fcfcfc;margin-left: 2em;margin-right: 2em;border-style: double;border-width: 4px;border-color: #b3fffa;border-radius: 5px;padding: 0.25em 0.75em 0.25em 1em;}span.math {font-size: 1em;}span.eqref{font-size: 0.75em;}blockquote {background-color: #f6f6f6;padding: 0.25em 0.75em;}hr {border-style: solid;border: none;border-top: 1px solid #777;margin: 28px 0;}hr.sec1 {margin-top: -1.5em;border-width: 2px;border-color: #aaaaaa;}dl {margin-left: 0;}dl dd {margin-bottom: 13px;margin-left: 13px;}dl dt {font-weight: bold;}ul {margin-top: 0;}ul li {list-style: disk outside;}ul ul {margin-bottom: 0;}ul ul li {list-style: circle outside;}pre, code {background-color: #f0f0f0;border-radius: 3px;color: #333;white-space: pre-wrap; }pre {border-radius: 3px;margin: 5px 0px 10px 0px;padding: 10px;}pre:not([class]) {background-color: #f7f7f7;}code {font-family: Consolas, Monaco, 'Courier New', monospace;font-size: 95%;}p > code, li > code {padding: 2px 0px;}div.indent2 {margin-left: 2%;}div.indent3 {margin-left: 3%;}div.figure {text-align: center;}img {background-color: #FFFFFF;padding: 2px;border: 1px solid #DDDDDD;border-radius: 3px;border: 1px solid #CCCCCC;margin: 0 5px;}h1 {margin-top: 0;padding-top: 15px;font-size: 175%;line-height: 40px;}h2 {border-bottom: 4px solid #dbdbdb;padding-top: 10px;padding-bottom: 2px;font-size: 145%;}h3 {border-bottom: 2px solid #e8e8e8;padding-top: 10px;font-size: 120%;}h4 {border-bottom: 1px solid #f7f7f7;margin-left: 8px;font-size: 105%;}h5, h6 {border-bottom: 1px solid #ccc;font-size: 105%;}a {color: #0033dd;text-decoration: none;}a:hover {color: #6666ff; }a:visited {color: #800080; }a:visited:hover {color: #BB00BB; }a[href^="http:"] {text-decoration: underline; }a[href^="https:"] {text-decoration: underline; }code > span.kw { color: #555; font-weight: bold; } code > span.dt { color: #902000; } code > span.dv { color: #40a070; } code > span.bn { color: #d14; } code > span.fl { color: #d14; } code > span.ch { color: #d14; } code > span.st { color: #d14; } code > span.co { color: #888888; font-style: italic; } code > span.ot { color: #007020; } code > span.al { color: #ff0000; font-weight: bold; } code > span.fu { color: #900; font-weight: bold; } code > span.er { color: #a61717; background-color: #e3d2d2; } </style>




</head>

<body>




<h1 class="title toc-ignore">Mathematical Description of Methods</h1>
<h4 class="author">Kendal Foster and Henrik Singmann</h4>
<h4 class="date">November 04, 2020</h4>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<div id="TOC">
<ul>
<li>
<a href="#background">Mathematical Background</a>
</li>
<li>
<a href="#dens">The Density Functions</a>
<ul>
<li>
<a href="#dens-lt">Large-Time</a>
</li>
<li>
<a href="#dens-st">Small-Time</a>
</li>
<li>
<a href="#dens-bt">Combining Large-Time and Small-Time</a>
</li>
</ul>
</li>
<li>
<a href="#references">References</a>
</li>
</ul>
</div>
<p>Function <code>dfddm</code> evaluates the density function (or probability density function, PDF) for the Ratcliff diffusion decision model (DDM) using different methods for approximating the full PDF, which contains an infinite sum. An empirical validation of the implemented methods is provided in the <a href="validity.html">Validity Vignette</a>. Timing benchmarks for the present methods and comparison with existing methods are provided in the <a href="benchmark.html">Benchmark Vignette</a>. Two examples of using <code>dfddm</code> for parameter estimation are provided in the <a href="example.html">Example Vignette</a>.</p>
<p>Our implementation of the DDM has the following parameters: <span class="math inline">\(a \in (0, \infty)\)</span> (threshold separation), <span class="math inline">\(v \in (-\infty, \infty)\)</span> (drift rate), <span class="math inline">\(t_0 \in [0, \infty)\)</span> (non-decision time/response time constant), <span class="math inline">\(w \in (0, 1)\)</span> (relative starting point), and <span class="math inline">\(sv \in (0, \infty)\)</span> (inter-trial-variability of drift). <br><br></p>
<div id="background" class="section level1">
<h1>Mathematical Background</h1>
<hr class="sec1">
<p>There are several different methods for approximating the PDF of the DDM, and there are three optional parameters in <code>dfddm</code> that can be used to indicate which method should be in the function call: <code>scale</code>, <code>n_terms_small</code>, and <code>summation_small</code>. For each method we describe, we include the parameter settings for the function call to <code>dfddm</code> so that it uses the desired method. As these parameters are optional, leaving them blank results in the <a href="#default-method">default method</a> that is indicated later in this vignette. For general purpose use, we recommend ignoring these optional parameters so that the default settings are used as this will be the fastest and most stable algorithm. Note that precedence for the optional parameters is first given to checking if the <a href="#default-method">default method</a> is selected. If not, precedence is then given to the <code>scale</code> parameter value; for example, <code>scale = &quot;large&quot;</code> will ignore the <code>summation_small</code> input value.</p>
<p>Since the DDM is widely used in parameter estimation usually involving numerical optimization, significant effort has been put into making the evaluation of its density as fast as possible. However, the density function for the DDM is notorious for containing an unavoidable infinite sum; hence, the literature has produced a few different methods of approximating the density. This vignette details the various methods used in the literature to approximate the infinite sum in the density function for the DDM.</p>
<p>The author of the seminal book where the density function originates, <span class="citation">Feller (1968)</span> explains the derivation from first principles. In this derivation there is a step that requires taking a limit, and <span class="citation">Feller (1968)</span> provides two different – but equivalent – limiting processes that yield two different – but equal – forms of the density function. Each of these forms contains an infinite sum and are known individually as the large-time approximation and the small-time approximation because the former is on average faster when calculating the density for large response times and the latter is on average faster when calculating the density for small response times.</p>
<p>When the drift rate is held constant (i.e. <span class="math inline">\(sv = 0\)</span>), the density function for the DDM is often written in a factorized form <span class="citation">(Navarro and Fuss 2009)</span>: <span class="math display">\[\begin{equation}
    f(t ~|~ v, a, w) = \frac{1}{a^2} \exp \left( -vaw -\frac{v^2 t}{2} \right) f_i \left( \frac{t}{a^2} ~\Big\vert~ 0, 1, w \right), \nonumber
\end{equation}\]</span> where <span class="math inline">\(f_i(\frac{t}{a^2} | 0, 1, w)\)</span> determines whether the large-time or small-time model will be used: <span class="math display">\[\begin{equation}
\begin{aligned}
    f_{i=\ell} (t ~|~ 0, 1, w) &amp;= \pi \sum_{j = 1}^{\infty} j \exp \left( -\frac{j^2 \pi^2 t}{2a^2} \right) \sin \left( j w \pi \right),\\
    f_{i=s} (t ~|~ 0, 1, w) &amp;= \frac{1}{\sqrt{2 \pi t^3}} \sum_{j = -\infty}^{\infty} (w + 2j) \exp \left( -\frac{(w + 2j)^2}{2t} \right).
\end{aligned}
\nonumber
\end{equation}\]</span></p>
<p>In an effort to simplify the terms inside the infinite summations as much as possible, we instead rewrite the constant drift rate density function as two separate functions without the factorization: <span class="math display">\[\begin{align}
    f_\ell(t | v, a, w) &amp;= \frac{\pi}{a^2} e^{ \left( -vaw-\frac{v^2 t}{2} \right)}
                                             \sum_{j = 1}^{\infty} j \sin \left( j w \pi \right) \exp{ \left( -\frac{j^2 \pi^2 t}{2a^2} \right)}, \label{eq:con-l} \\
  f_s(t | v, a, w) &amp;= \frac{a}{\sqrt{2 \pi t^3}} e^{ \left( -vaw-\frac{v^2 t}{2} \right)}
                                          \sum_{j = -\infty}^{\infty} (w + 2j) \exp{ \left( -\frac{a^2}{2t} \left( w + 2j \right)^2 \right)}. \label{eq:con-s}
\end{align}\]</span></p>
<p>In addition to having large-time and small-time variants, there exist two mathematically equivalent formulations for the infinite summation in the small-time density functions. The details and proof of equivalence of these two formulations will be provided in the paper accompanying <code>fddm</code>, but we will continue to use the traditional formulation for the remainder of this vignette.</p>
<p>Now allowing the drift rate to vary across trials (i.e. <span class="math inline">\(sv &gt; 0\)</span>), we should have two density functions. However, as only the small-time variable drift rate density function has been available in the literature <span class="citation">(Blurton, Kesselmeier, and Gondan 2017)</span>, we provide the derivation of the large-time variable drift rate density function in the <code>fddm</code> paper. The large-time and small-time variable drift rate density function are: <span class="math display">\[\begin{align}
f_\ell(t | v, \eta^2, a, w) &amp;= \frac{\pi}{a^2 \sqrt{1 + \eta^2 t}}
                               \exp{ \left( \frac{\eta^2 a^2 w^2 -2vaw -v^2 t}{2 (1 + \eta^2 t)} \right)}
                                                             \sum_{j = 1}^{\infty} j \sin \left( j w \pi \right) \exp{ \left( -\frac{j^2 \pi^2 t}{2a^2} \right)}, \label{eq:var-l}\\
f_s(t | v, \eta^2, a, w) &amp;= \frac{a}{\sqrt{2 \pi t^3 \left( 1 + \eta^2 t \right)}}
                                                        \exp{ \left( \frac{\eta^2 a^2 w^2 -2vaw -v^2 t}{2 (1 + \eta^2 t)} \right)}
                                                        \sum_{j = -\infty}^{\infty} (w + 2j) \exp{ \left( -\frac{a^2}{2t} \left( w + 2j \right)^2 \right)}. \label{eq:var-s}
\end{align}\]</span></p>
<p>Immediately of note is that the infinite summation for each time scale is the same regardless of the inclusion of variability in the drift rate. It then follows that there exists a term <span class="math inline">\(M\)</span> such that the density function for the constant drift rate multiplied by <span class="math inline">\(M\)</span> yields the density function for the variable drift rate. That is, <span class="math inline">\(M \cdot f(t | v, a, w) = f(t | v, a, w, \eta^2)\)</span> from the above equations; this value <span class="math inline">\(M\)</span> works for converting both the large-time and small-time constant drift rate densities to variable drift rate densities. Although we do not use this term, it may be useful in adapting current algorithms to easily outputting the density with variable drift rate. Note that there are some issues with simply scaling the constant drift rate density, so please see the <a href="#validity.html">Validity Vignette</a> for more information about the potential problems with this conversion. The multiplicative term <span class="math inline">\(M\)</span> is given below: <span class="math display">\[\begin{equation}
  M = \frac{1}{\sqrt{1 + \eta^2 t}} \exp \left( vaw + \frac{v^2 t}{2} + \frac{\eta^2 a^2 w^2 -2vaw -v^2 t}{2 (1 + \eta^2 t)} \right). \nonumber
\end{equation}\]</span></p>
</div>
<div id="dens" class="section level1">
<h1>The Density Functions</h1>
<hr class="sec1">
<p>The main issue of these families of density functions is that they all contain an infinite sum that must be approximated. Since there is no closed form analytical solution to this infinite sum, we instead calculate only a partial sum by truncating the sequence of terms after a certain point. We cannot actually calculate the true value of the density function, but we can mathematically prove that we can get arbitrarily close to the true value; the proof of this fact is provided in the paper accompanying the <code>fddm</code> package. The nature of this truncation has been the topic of many papers in the literature, but the underlying idea supporting all of the methods is the same: the user specifies an allowable error tolerance, and the algorithm calculates terms of the infinite sum until the result is within the allowed error tolerance of the true value.</p>
<p>The methods in the literature pre-calculate the number of terms required for the infinite sum to converge within the allowed error tolerance, and this number of terms is referred to as <span class="math inline">\(k_\ell\)</span> and <span class="math inline">\(k_s\)</span> for the large-time and small-time infinite sums, respectively. <span class="citation">Navarro and Fuss (2009)</span> include a method for calculating <span class="math inline">\(k_b\)</span>, the number of required terms for the infinite sum when combining the density functions of the two time scales. In addition to these existing methods, we add a novel method that does not perform this pre-calculation, and we also provide two new combinations of the large-time and small-time density functions. Note that in each method that pre-calculates the number of terms, the response time <span class="math inline">\(t\)</span> is scaled inversely by <span class="math inline">\(a^2\)</span>, that is <span class="math inline">\(t&#39; := \tfrac{t}{a^2}\)</span>. Also note that for the rest of this vignette, the ceiling function will be denoted by <span class="math inline">\(\lceil \cdot \rceil\)</span>.</p>
<div class="indent2">
<h2 id="dens-lt">Large-Time</h2>
<p>The large-time density functions, Equations <span class="math inline eqref"><span class="math inline">\(\eqref{eq:con-l}\)</span></span> and <span class="math inline eqref"><span class="math inline">\(\eqref{eq:var-l}\)</span></span>, have an infinite sum that runs for all of the positive integers. For a given error tolerance <span class="math inline">\(\epsilon\)</span>, <span class="citation">Navarro and Fuss (2009)</span> provide an expression for <span class="math inline">\(k_\ell\)</span>, the number of terms required for the large-time infinite sum to be within <span class="math inline">\(\epsilon\)</span> of the true value of the density function. Thus the infinite sum becomes finite: <span class="math display">\[\begin{equation} \label{eq:kl}
  \sum_{j = 1}^{k_\ell^\text{Nav}} j \sin \left( j w \pi \right) \exp{ \left( -\frac{j^2 \pi^2 t&#39;}{2} \right)}. \nonumber
\end{equation}\]</span></p>
<p>It remains to find the value of <span class="math inline">\(k_\ell^\text{Nav}\)</span> that ensures the truncated sum is <span class="math inline">\(\epsilon\)</span>-close to the true value. <span class="citation">Navarro and Fuss (2009)</span> provide a derivation in their paper that finds an upper bound for the tail of the sum, the sum of all terms greater than <span class="math inline">\(k_\ell^\text{Nav}\)</span> (i.e., the error). Then they back-calculate the number of terms required to force this upper bound on the error to be less than <span class="math inline">\(\epsilon\)</span>, since then the actual error must also be less than <span class="math inline">\(\epsilon\)</span>. The resulting number of terms is: <span class="math display">\[\begin{equation} \label{eq:kl-Nav}
    k_\ell^{\text{Nav}} \left( t&#39;, \epsilon \right) = \left\lceil \max \left\{ \sqrt{\frac{-2 \log(\pi t&#39; \epsilon)}{\pi^2 t&#39;}}, \frac{1}{\pi \sqrt{t&#39;}} \right\} \right\rceil.
\tag{L.1}
\end{equation}\]</span></p>
<p class="method">
This method is often viewed as the most inefficient of the available options in the literature; however, this method proves to be extremely efficient in particular areas of the parameter space (typically for large <span class="math inline">\(t&#39;\)</span>). The argument used to implement this method in <code>dfddm</code> is to set the parameter <code>scale = &quot;large&quot;</code> in the function call. In this case the other parameters, <code>n_terms_small</code> and <code>summation_small</code>, must be set to any string that does not start with <code>S</code> or <code>s</code> to avoid any potential clashes with overridden options.
</p>
<h2 id="dens-st">Small-Time</h2>
<p>The small-time approximations, Equations <span class="math inline eqref"><span class="math inline">\(\eqref{eq:con-s}\)</span></span> and <span class="math inline eqref"><span class="math inline">\(\eqref{eq:var-s}\)</span></span>, also contain an infinite sum, but this sum runs over all of the integers – from negative infinity to positive infinity. Given this infinite nature in both directions, it is impossible to rigorously define the number of terms required to achieve the <span class="math inline">\(\epsilon\)</span>-accuracy because we don’t know where to start counting the terms. To solve this issue, we rearrange the terms in the sum into the sequence <span class="math inline">\(\left\{ b_0, b_{-1}, b_1, \dots, b_{-j}, b_j, b_{-(j+1)}, b_{j+1}, \dots \right\}\)</span>; this allows us not only to count the terms in a sensible manner but also to define <span class="math inline">\(k_s\)</span> as the index of the sequence where the truncation should occur. Then we can write the truncated version of the sum: <span class="math display">\[\begin{equation} \label{eq:ks}
  \sum_{j = -k_s}^{k_s} (w + 2j) \exp{ \left( -\frac{a^2}{2t} \left( w + 2j \right)^2 \right)}. \nonumber
\end{equation}\]</span></p>
<p>To choose the small-time methods when using <code>dfddm</code>, set the optional parameter <code>scale = &quot;small&quot;</code> in the function call. You can also set the optional parameter <code>summation_small = &quot;2017&quot;</code> or <code>summation_small = &quot;2014&quot;</code>, but it is recommended to ignore this parameter so it retains its default value of “2017” that evaluates slightly faster than its counterpart. This parameter controls the style of summation used in the small-time approximation, and more details on the differences between these two styles can be found in the paper accompanying <code>fddm</code>. The final parameter, <code>n_terms_small</code>, will be discussed in the following three subsections.</p>
<div class="indent3">
<h3 id="dens-st-nav">Navarro &amp; Fuss</h3>
<p>Similarly to their large-time solution, <span class="citation">Navarro and Fuss (2009)</span> provide an expression for <span class="math inline">\(k_s\)</span> given an error tolerance <span class="math inline">\(\epsilon\)</span>. They follow a similar idea to their large-time derivation by bounding the error of the truncation with integrals then back-calculating the number of terms required to keep the error less than <span class="math inline">\(\epsilon\)</span>. The resulting approximation yields: <span class="math display">\[\begin{equation} \label{eq:ks-Nav}
  k_s^{\text{Nav}} \left( t&#39;, \epsilon \right) = \left\lceil \max \left\{ 2 + \sqrt{-2t&#39; \log(2 \epsilon \sqrt{2 \pi t&#39;})}, 1 + \sqrt{t&#39;} \right\} \right\rceil.
\tag{S.1}
\end{equation}\]</span></p>
<p class="method">
To use this method, set <code>n_terms_small = &quot;Navarro&quot;</code> and keep <code>scale = &quot;small&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance.
</p>
<h3 id="dens-st-gon">Gondan, Blurton, Kesselmeier</h3>
<p><span class="citation">Gondan, Blurton, and Kesselmeier (2014)</span> improve on the approximation provided by <span class="citation">Navarro and Fuss (2009)</span> by using fewer terms in the sum to achieve the same level of accuracy, translating into a faster computation time. Given the error tolerance <span class="math inline">\(\epsilon\)</span>, <span class="citation">Gondan, Blurton, and Kesselmeier (2014)</span> exploit the intrinsic nature of the terms in the infinite sum to derive a smaller value for <span class="math inline">\(k_s\)</span>. After a few terms of the sum have been evaluated, each remaining term is smaller in absolute value than the previous term. They combine this knowledge with the observation that the terms alternate in sign to produce the following required number of terms: <span class="math display">\[\begin{equation} \label{eq:ks-Gon}
\begin{aligned}
  k_s^{\text{Gon}} \left( t&#39;, w, \epsilon \right) &amp;= \left\lceil \max \left\{ \tfrac{1}{2} \left( \sqrt{2t&#39;} - w \right), \tfrac{1}{2} \left( \sqrt{-t&#39; (u_\epsilon - \sqrt{-2 u_\epsilon -2})} - w \right) \right\} \right\rceil,\\
  u_\epsilon &amp;= \min \left\{ -1, \log(2 \pi t&#39;^2 \epsilon^2) \right\}.
\end{aligned}
\tag{S.2}
\end{equation}\]</span></p>
<p class="method">
To use this method, set <code>n_terms_small = &quot;Gondan&quot;</code> and keep <code>scale = &quot;small&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance.
</p>
<h3 id="dens-st-swse">Stop When Small Enough (SWSE)</h3>
<p>If we consider the terms of the infinite sum as the sequence defined above, the series alternates in sign <span class="math inline">\((+, -, +, ...)\)</span>; moreover, the series eventually decreases monotonically (in absolute value) due to the exponential term. Combining and exploiting these two mathematical properties has been the cornerstone of the previous approximations, but we will instead truncate the sum using a novel method. This method does not pre-calculate the number of terms required to achieve the given error tolerance. Instead, the general idea of this method is to take full advantage of the alternating and decreasing nature of the terms in the infinite sum by applying a handy theorem (commonly known as Leibniz’s rule) to place an upper bound on the truncation error after including so many terms. It has been proven that this upper bound is in fact the absolute value of the next term in the sequence, thus we can truncate the infinite sum once one of its terms is less than the desired error tolerance, <span class="math inline">\(\epsilon\)</span>. Hence we do not consider the number of terms in the sum, rather just that the terms in the summation will eventually be small enough. The validity of this method is proven in the paper that accompanies the <code>fddm</code> package.</p>
<p class="method">
To use this method, set <code>n_terms_small = &quot;SWSE&quot;</code> and keep <code>scale = &quot;small&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance.
</p>
</div>
<h2 id="dens-bt">Combining Large-Time and Small-Time</h2>
<p>A sensible next approach to approximating the density of the DDM is to use some combination of the large-time and small-time density functions. As their names suggest, each density function approximation has a section of the parameter space where it outperforms the other one. Essentially these methods involve calculating the number of terms required for both the large-time and small-time density functions, then using whichever approximation requires fewer terms. The goal is to use each approximation where it is efficient and avoid the areas of the parameter space where the approximations perform poorly.</p>
<p>To use this method of evaluating the PDF, set the optional parameter <code>scale = &quot;both&quot;</code> in the function call. These methods include similar options to the small-time approximations from the previous section, and thus it is possible to set the optional parameters in a similar fashion to above. The value of <code>summation_small</code> triggers the same effect as above since it only affects the small-time approximation to the PDF; we recommend ignoring this parameter so it assumes its default value of “2017” that evaluates slightly faster than its counterpart. The final parameter, <code>n_terms_small</code>, will be discussed in the following three subsections. As there is only one option for the large-time approximation, there are no optional parameters to set for this part of the combined time scale approximation.</p>
<div class="indent3">
<h3 id="dens-bt-nav">Navarro Small &amp; Navarro Large</h3>
<p><span class="citation">Navarro and Fuss (2009)</span> initially suggested a method where you calculate both <span class="math inline">\(k_s^\text{Nav}\)</span> and <span class="math inline">\(k_l^\text{Nav}\)</span> and use whichever one has a smaller value. However, one issue with their original method arises when the user inputs a vector of response times. They calculate the maximum value of <span class="math inline">\(k_s^\text{Nav}\)</span> for all of the input response times and then compare that to the maximum value of <span class="math inline">\(k_l^\text{Nav}\)</span> for all of the input response times. They end up with one <span class="math inline">\(k_b^\text{Nav}\)</span> for all of the input response times, and this one value can be higher than normal for a response time due to the maximization of the approximation over all of the response times. This over-accuracy is not necessarily a bad thing, but it does mean that it is possible to get different densities for the same input response time depending on the other response times that have been input. To correct for this, we simply do not maximize <span class="math inline">\(k_s^\text{Nav}\)</span> or <span class="math inline">\(k_l^\text{Nav}\)</span> over all of the input response times and instead calculate one value of <span class="math inline">\(k_b^\text{Nav}\)</span> for each input response time. <span class="math display">\[\begin{equation} \label{eq:kb-Nav}
  k_b^\text{Nav} \left( t&#39;, w, \epsilon \right) = \min \left\{ k_s^{\text{Nav}}, k_l^{\text{Nav}} \right\}.
\tag{B.1}
\end{equation}\]</span></p>
<p class="method">
To use this method, set <code>n_terms_small = &quot;Navarro&quot;</code> and keep <code>scale = &quot;both&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance.
</p>
<h3 id="dens-bt-gon">Gondan Small &amp; Navarro Large</h3>
<p>This combination of methods has not been explored in the literature before, but it works very similarly to the combination above. The only difference is that we use the <span class="citation">Gondan, Blurton, and Kesselmeier (2014)</span> approximation for the small-time instead of the one provided by <span class="citation">Navarro and Fuss (2009)</span>. Since <span class="math inline">\(k_s^\text{Gon} \leq k_s^\text{Nav}\)</span>, this method will give approximations at least as fast as the above combination. <span class="math display">\[\begin{equation} \label{eq:kb-Gon}
  k_b^{\text{Gon}} \left( t&#39;, w, \epsilon \right) = \min \left\{ k_s^{\text{Gon}}, k_l^{\text{Nav}} \right\}.
\tag{B.2}
\end{equation}\]</span></p>
<p class="method">
To use this method, set <code>n_terms_small = &quot;Gondan&quot;</code> and keep <code>scale = &quot;both&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance.
</p>
<p><a id="default-method"></a></p>
<h3 id="dens-bt-swse">Stop When Small Enough (SWSE) Small &amp; Navarro Large</h3>
<p>This method uses the novel SWSE approximation to the small-time density function in conjunction with the Navarro large-time approximation to achieve consistent performance across the parameter space. Since the SWSE approximation to the small-time density function does not explicitly calculate <span class="math inline">\(k_s\)</span>, we only calculate <span class="math inline">\(k_\ell^{\text{Nav}}\)</span> and compare it to the new optional parameter <code>max_terms_large</code>. If <span class="math inline">\(k_\ell^{\text{Nav}}\)</span> <span class="math inline">\(\le\)</span> <code>max_terms_large</code>, then the Navarro large-time approximation is used. On the other hand, if <span class="math inline">\(k_\ell^{\text{Nav}}\)</span> <span class="math inline">\(&gt;\)</span> <code>max_terms_large</code>, then the SWSE small-time approximation is used. The user can set the optional parameter <code>max_terms_large</code> to any non-negative integer to alter the behavior of this method; the default value for this parameter is <span class="math inline">\(4\)</span>. Again, the validity of this method is proven in the paper that accompanies the <code>fddm</code> package.</p>
<p class="method">
Since this is the default method, all three of the optional parameters (<code>n_terms_small</code>, <code>scale</code>, and <code>summation_small</code>) can be ignored. For completeness, set <code>n_terms_small = &quot;SWSE&quot;</code> and keep <code>scale = &quot;both&quot;</code> in the function call. The parameter <code>summation_small</code> should be ignored so that it retains its default value to obtain the best performance. This method uses a fourth optional parameter, <code>max_terms_large</code>, and we recommend ignoring this parameter so that it retains its default value.
</p>
</div>
</div>
</div>
</div>
<div id="section" class="section level1 unlisted unnumbered">
<h1></h1>
<div id="r-session-info" class="section level4 unlisted unnumbered">
<h4>R Session Info</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">sessionInfo</span>()</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#&gt; R version 4.0.2 (2020-06-22)</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#&gt; Platform: x86_64-w64-mingw32/x64 (64-bit)</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt; Running under: Windows 10 x64 (build 19041)</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; </span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; Matrix products: default</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; </span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; locale:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; [1] LC_COLLATE=C                           </span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt; [2] LC_CTYPE=English_United Kingdom.1252   </span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#&gt; [3] LC_MONETARY=English_United Kingdom.1252</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">#&gt; [4] LC_NUMERIC=C                           </span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">#&gt; [5] LC_TIME=English_United Kingdom.1252    </span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co">#&gt; </span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co">#&gt; attached base packages:</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="co">#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     </span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="co">#&gt; </span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="co">#&gt; other attached packages:</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="co">#&gt; [1] ggplot2_3.3.2        reshape2_1.4.4       microbenchmark_1.4-7</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="co">#&gt; [4] RWiener_1.3-3        rtdists_0.11-2       fddm_0.2-2          </span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co">#&gt; </span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="co">#&gt; loaded via a namespace (and not attached):</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="co">#&gt;  [1] Rcpp_1.0.5       pillar_1.4.6     compiler_4.0.2   plyr_1.8.6      </span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co">#&gt;  [5] tools_4.0.2      digest_0.6.25    evd_2.3-3        evaluate_0.14   </span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="co">#&gt;  [9] lifecycle_0.2.0  tibble_3.0.3     gtable_0.3.0     lattice_0.20-41 </span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="co">#&gt; [13] pkgconfig_2.0.3  rlang_0.4.7      Matrix_1.2-18    yaml_2.2.1      </span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="co">#&gt; [17] mvtnorm_1.1-1    expm_0.999-5     xfun_0.18        withr_2.3.0     </span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co">#&gt; [21] dplyr_1.0.2      stringr_1.4.0    knitr_1.30       generics_0.0.2  </span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="co">#&gt; [25] vctrs_0.3.4      tidyselect_1.1.0 grid_4.0.2       ggnewscale_0.4.3</span></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="co">#&gt; [29] glue_1.4.2       R6_2.4.1         survival_3.2-7   rmarkdown_2.4   </span></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co">#&gt; [33] farver_2.0.3     purrr_0.3.4      magrittr_1.5     scales_1.1.1    </span></span>
<span id="cb1-32"><a href="#cb1-32"></a><span class="co">#&gt; [37] htmltools_0.5.0  ellipsis_0.3.1   splines_4.0.2    colorspace_1.4-1</span></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="co">#&gt; [41] labeling_0.3     stringi_1.5.3    gsl_2.1-6        munsell_0.5.0   </span></span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="co">#&gt; [45] msm_1.6.8        crayon_1.3.4</span></span></code></pre></div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-blurton2017first">
<p>Blurton, Steven P, Miriam Kesselmeier, and Matthias Gondan. 2017. “The First-Passage Time Distribution for the Diffusion Model with Variable Drift.” <em>Journal of Mathematical Psychology</em> 76: 7–12.</p>
</div>
<div id="ref-feller1968introduction">
<p>Feller, William. 1968. <em>An Introduction to Probability Theory and Its Applications: Volume I</em>. Vol. 1. John Wiley &amp; Sons.</p>
</div>
<div id="ref-gondan2014even">
<p>Gondan, Matthias, Steven P Blurton, and Miriam Kesselmeier. 2014. “Even Faster and Even More Accurate First-Passage Time Densities and Distributions for the Wiener Diffusion Model.” <em>Journal of Mathematical Psychology</em> 60: 20–22.</p>
</div>
<div id="ref-navarro2009fast">
<p>Navarro, Daniel J, and Ian G Fuss. 2009. “Fast and Accurate Calculations for First-Passage Times in Wiener Diffusion Models.” <em>Journal of Mathematical Psychology</em> 53 (4): 222–30.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
