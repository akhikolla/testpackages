<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Robert V. Baron and Daniel E. Weeks" />


<title>Mega2R Tutorial</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Mega2R Tutorial</h1>
<h4 class="author">Robert V. Baron and Daniel E. Weeks</h4>
<h4 class="date">September 29, 2020, 17:11</h4>



<div id="introduction" class="section level1">
<h1>1 Introduction</h1>
<div id="what-is-mega2" class="section level2">
<h2>1.1 What is Mega2</h2>
<p>The Mega2R package uses as input genetic data that have been reformatted and stored in a ‘SQLite’ database; this database is initially created by the standalone Mega2 C++ program. Here we give a quick overview of the Mega2 C++ program. For more information, please see the Mega2 documentation, which is available here: <a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html" class="uri">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a></p>
<p>During an association or linkage analysis project, one may need to analyze the data with several different programs. Unfortunately, it can often be quite difficult to get one’s data in the proper format desired by each different computer program. Not only must the data be converted to the proper format, but also the loci must be reordered into their proper order. Writing custom reformatting scripts can be error-prone and very time-consuming. To address these problems, we created Mega2.</p>
<p>Mega2 can read input data in several formats: LINKAGE format, PLINK format, IMPUTE format and VCF format. Mega2 allows one to augment these input formats with additional information, if desired. For example, trait locus penetrance information can be specified. The input data are read and validated once, then stored in a ‘SQLite’ database file.</p>
<p>Mega2 then takes the database file and, via a menu-driven interface, transforms it into various other file formats, thus greatly facilitating a variety of different analyses. In addition, for many of these options, it also sets up a shell script that then can automatically run these analyses (if you are using Mega2 in a Unix or Macintosh environment).</p>
<p>Mega2 is currently structured so that the user proceeds through a series of menus, both to create the database and later to process it, making choices in each menu (or accepting the default values), until the desired output files are created. After the desired output files are created, Mega2 exits. Mega2 can also be run in a hands-free mode, using a control or ‘batch’ file to specify these choices.</p>
<p>In addition to the ability to reformat data for a variety of analysis programs, other useful features of Mega2 include:</p>
<ol style="list-style-type: decimal">
<li><p>The ability to create publication-quality PDF plots of the results using our nplplot library.</p></li>
<li><p>The ability to create custom tracks of results for visualization in the UCSC genome browser.</p></li>
<li><p>The ability to run in an automated way using batch files.</p></li>
<li><p>The availability of our Genetic Map Interpolator for aiding in constructing genetic maps of markers.</p></li>
<li><p>The ability to align allele labels to a reference and to resolve strand issues.</p></li>
<li><p>The ability to simulate genotype errors.</p></li>
<li><p>Input and output support for Mega2 format files that contain informative header lines and are readable into R.</p></li>
<li><p>Input and output support for the widely-used PLINK format files.</p></li>
<li><p>Input and output support for Variant Call Format (VCF, BCF, compressed VCF) files, including flexible filtering on input.</p></li>
<li><p>Input support for IMPUTE2 GEN format files and binary IMPUTE2 BGEN format files.</p></li>
<li><p>The ability to automatically zero out selected genotypes for specific individuals in order to resolve Mendelian inconsistencies.</p></li>
<li><p>In most cases, in addition to generating appropriately re-formatted files, Mega2 also generates a shell script that will automatically run the desired program.</p></li>
<li><p>Creation of an HTML summary of the most recent run of Mega2, with links to input and output and log files.</p></li>
<li><p>Creation of extensive data analysis logs, both during database creation: (files MEGA2.DB.LOG and MEGA2.DB.ERR) and during each analysis: (files MEGA2.LOG and MEGA2.ERR).</p></li>
</ol>
<p>The features listed above and the documentation, <a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html" class="uri">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a>, describe the Mega2 executable, written in C++. The site <a href="https://watson.hgen.pitt.edu/register/" class="uri">https://watson.hgen.pitt.edu/register/</a> provides Mega2 binaries for a number of different platforms including Windows 7 and 10 as well as the GPL-3 source. (The source for Mega2 as well as Mega2R can be found at <a href="https://bitbucket.org/dweeks/mega2" class="uri">https://bitbucket.org/dweeks/mega2</a> BitBucket site.)</p>
</div>
<div id="what-is-mega2r" class="section level2">
<h2>1.2 What is Mega2R</h2>
<p>Since Mega2 now produces a ‘SQLite’ database, it is now easy to load the data that Mega2 has processed into R. This is what Mega2R and this tutorial is all about.</p>
<p>Mega2R loads and manipulates data frames containing genotype, phenotype, and family information from the input ‘SQLite’ database. In addition, we have developed C++ functions to decompress needed subsets of the genotype data, on the fly, in a memory efficient manner.<br />
We have also created several more functions that illustrate how to use the data frames as well as perform useful functions: these permit one to run the ‘pedgene’ package (<a href="https://CRAN.R-project.org/package=pedgene" class="uri">https://CRAN.R-project.org/package=pedgene</a>) to carry out gene-based association tests on family data using selected marker subsets, to run the ‘SKAT’ package (<a href="https://CRAN.R-project.org/package=SKAT" class="uri">https://CRAN.R-project.org/package=SKAT</a>) to carry out gene-based association tests using selected marker subsets, to output subsets of the Mega2R data as a VCF file (<a href="https://github.com/samtools/hts-specs" class="uri">https://github.com/samtools/hts-specs</a>) and related files (for phenotype and family data), and to convert the data frames into ‘GenABEL’ gwaa.data-class objects (<a href="https://CRAN.R-project.org/package=GenABEL" class="uri">https://CRAN.R-project.org/package=GenABEL</a>).</p>
<p>This tutorial shows how to read the ‘SQLite’ database and how to access tables in it using this package, Mega2R. The tutorial shows how to carry out gene-based analyses that select subsets of the data that corresponds to transcripts or other base pair ranges.<br />
It is important to point out that like GenABEL (<a href="https://CRAN.R-project.org/package=GenABEL" class="uri">https://CRAN.R-project.org/package=GenABEL</a>), Mega2R keeps its genotype data in a compressed format that is only expanded when needed.</p>
</div>
</div>
<div id="example-genome-wide-association-data" class="section level1">
<h1>2 Example Genome-wide Association Data</h1>
<p>We used the SeqSIMLA2 program to generate an example data set to use in this vignette. [SeqSIMLA2: simulating correlated quantitative traits accounting for shared environmental effects in user-specified pedigree structure, Chung RH1, Tsai WY, Hsieh CH, Hung KY, Hsiung CA, Hauser ER., Genet Epidemiol. 2015 Jan;39(1):20-4. doi: 10.1002/gepi.21850. Epub 2014 Sep 22.] We needed to sub-sample the data down to 1,380 people and 1,000 markers to make the size manageable. These data will be used to illustrate Mega2 and Mega2R operations that follow.</p>
<p>Note: The simulator produces markers on only chromosome 1.</p>
</div>
<div id="tutorial-data" class="section level1">
<h1>3 Tutorial Data</h1>
<p>The files you will need for this tutorial are provided in this package. Further, our use of the “mega2” executable expects the Mega2.BATCH.<name> files to be in the working directory and the latter files expect their data files to be in the working directory. This is done by running:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(Mega2R)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">dump_mega2rtutorial_data</span>()</span></code></pre></div>
<p>All the files for this vignette will be created in the temporary directory given by <code>file.path(tempdir(),&quot;Mega2Rtutorial&quot;)</code>. In that directory, you will see the following files:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">list.files</span>(<span class="kw">where_mega2rtutorial_data</span>())</span></code></pre></div>
<pre><code>##  [1] &quot;MEGA2.BATCH.seqsimr&quot; &quot;MEGA2.BATCH.srdta&quot;   &quot;MEGA2.BATCH.vcf&quot;    
##  [4] &quot;Mega2r.map&quot;          &quot;Mega2r.map.gz&quot;       &quot;Mega2r.ped&quot;         
##  [7] &quot;Mega2r.ped.gz&quot;       &quot;seqsimr.db&quot;          &quot;seqsimr.db.gz&quot;      
## [10] &quot;srdta.db&quot;            &quot;srdta.db.gz&quot;</code></pre>
<p><strong>Note: The temporary directory name, given by <code>file.path(tempdir(),&quot;Mega2Rtutorial&quot;)</code>, is generated randomly each time this vignette is run. </strong></p>
<p><strong>Note: The temporary directory name is also the value of the R expression, <code>where_mega2rtutorial_data()</code>.</strong></p>
<p>When you are done with these exercise, the “clean” command will remove these files:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">clean_mega2rtutorial_data</span>()</span></code></pre></div>
</div>
<div id="installation" class="section level1">
<h1>4 Installation</h1>
<div id="r" class="section level2">
<h2>4.1 R</h2>
<p><strong>We will assume that you have started an session at which to type the commands in the tutorial.</strong></p>
<p>To run any of these exercises, you should install the package Mega2R.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">install.packages</span>(<span class="st">&quot;Mega2R&quot;</span>)</span></code></pre></div>
</div>
<div id="bioconductor" class="section level2">
<h2>4.2 Bioconductor</h2>
<p>In Section 6 below, we will carry out gene-based association tests, where ‘genes’ are defined according to a database containing the boundaries of the gene transcripts. This requires two Bioconductor Annotations databases to be installed. The first line (below) loads the Bioconductor loader and the next two lines install two annotation databases. One annotation database provides the gene transcript locations and the other maps gene names to entrez gene IDs. (Note: As described in Section 5.3.3, you may choose a different transcript database from Bioconductor or construct one of your own.) Please type in R:</p>
<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)

biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)</code></pre>
<p>The above step is run once.</p>
</div>
</div>
<div id="using-mega2r-to-access-and-process-genetic-data" class="section level1">
<h1>5 Using Mega2R to access and process genetic data</h1>
<div id="creating-a-mega2-database" class="section level2">
<h2>5.1 Creating a Mega2 database</h2>
<p>We have provided files in this package that contain the data from the simulation. These files are in PLINK ped format data:</p>
<ul>
<li>Mega2r.ped</li>
<li>Mega2r.map</li>
</ul>
<p><strong>If you do not wish to install Mega2 right now, you can use the seqsimr.db database that is in the tutorial directory.</strong></p>
<p>You can obtain the Mega2 program from <a href="https://watson.hgen.pitt.edu/register/" class="uri">https://watson.hgen.pitt.edu/register/</a>. Then, you will invoke Mega2 on your data. To make matters simple, we will use a pre-constructed Mega2 batch file to automate the processing by Mega2. To run Mega2 to process and create the ‘SQLite’ database ‘seqsimr.db’, we issue the following command at the Unix prompt in the directory containing tutorial data; the name of this directory is given by the R command: <code>where_mega2rtutorial_data()</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a><span class="ex">mega2</span> MEGA2.BATCH.seqsimr</span></code></pre></div>
<p><strong>Note: This vignette will not invoke <em>mega2</em>, but use the seqsimr.db database that is in this package.</strong></p>
<p><strong>NOTE: To make this tutorial only dependent on R, the above code is not actually run. And its results, shown below, were captured from an environment where we had both R and Mega2 executable available. All the examples of mega2 shown in these exercises have been similarly “fudged”.</strong></p>
<p>The output seen on the screen when we ran Mega2 to create the ‘SQLite’ database is as follows:</p>
<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar, 
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill, 
##      and Daniel E. Weeks. 
## 
##      Last updated: Jun 13 2017, 09:36:42 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-7-24-10-03
## 
## Running Mega2 in batch mode from MEGA2.BATCH.seqsimr.
## Input filenames and missing value indicator read in from batch file.
## Dump Analysis option read in from batch file.
## WARNING: Locus selections not specified in batch file.
## WARNING: Going to Reorder menu.
## WARNING: Trait selections not specified in batch file.
## WARNING: Going to Trait selection menu.
## ==========================================================
## Keyword Input_Locus_File not in batch file, Locus file assumed to be unspecified.
## Keyword Input_Map_File not in batch file, Map file assumed to be unspecified.
## Keyword Input_Omit_File not in batch file, Omit file assumed to be unspecified.
## Keyword Input_Frequency_File not in batch file, Frequency file assumed to be unspecified.
## Keyword Input_Penetrance_File not in batch file, Penetrance file assumed to be unspecified.
## Keyword Input_Aux_File not in batch file, Aux file assumed to be unspecified.
## Keyword Input_Phenotype_File not in batch file, Phenotype file assumed to be unspecified.
## Keyword Input_Imputed_Info_File not in batch file, Imputed Info file assumed to be unspecified.
## ===========================================================
## Analysis Class: Dump.
## Quantitative  Input Missing Value  -9 
## Affection     Input Missing Value     &quot;-9&quot;
## Quantitative Output Missing Value      &quot;*&quot;
## Affection    Output Missing Value      &quot;*&quot;
## Input Format: PLINK PED format (ped)
## Pedigree and map files specified as PLINK format.
## omit, penetrance, and frequency files are always in Mega2 format.
## Input files will be read in as PLINK or Mega2 format files as appropriate.
## Reading PLINK map file for names: Mega2r.map
## Reading map file Mega2r.map ... (4 columns)
## Input Map name: Map, type: average genetic map, units: kosambi centiMorgans
## Input Map name: BP, type: physical map
## Found 2 possible maps in the Mega2r.map file.
## Now checking each record in map file Mega2r.map ...
## Done reading map file: Mega2r.map
## 
## ===========================================================
## Total number of loci =  1001
## 1 trait locus 
##       1 Affection status locus: 
##                 default
##       1000 Marker loci 
## Number of loci found per chromosome (chromosome:number)
##    1:1000
## ===========================================================
## WARNING: No frequency file provided.
## WARNING: Allele frequencies for these will be estimated from data.
## Trait &#39;default&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Reading PLINK .ped file: Mega2r.ped (2006 columns).
## 1000 (of 1000) markers to be included from Mega2r.map
## Reading pedigree information from Mega2r.ped
## 1380 individuals read from Mega2r.ped
## 1380 individuals with nonmissing phenotypes
## 105 cases, 1275 controls, 0 missing
## 620 males, 760 females, 0 of unspecified sex
## 0 founders, 1380 non-founders found
## ===========================================================
## Input pedigree data contains:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Pedigree exclusion option : Include all pedigrees whether typed or not.
## Count option: all alleles
## Count half-typed individuals&#39; alleles : no 
## ===========================================================
## Recoding pedigree genotypes ... 
## ===========================================================
## Pedigree data summary after recoding:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Created linkage ped tree
## Done checking locus integrity.
## Checking pedigree integrity...
## Done checking pedigree integrity.
## ==========================================================
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Database file &quot;seqsimr.db&quot; will be backed up.
## Moved existing seqsimr.db to seqsimr.db.old
## Dumping SQLite3 DB to file &quot;seqsimr.db&quot;
## ===========================================================
## See run summaries in directory 2017-7-24-10-03 
##    MEGA2.LOG, MEGA2.RECODE, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/mega2rtutorial/vignettes/2017-7-24-10-03/MEGA2run.html
## in a web browser.
## ===========================================================</code></pre>
<p>If you do not provide the command-line argument giving the name of the BATCH file, Mega2 will proceed to ask a series of questions to collect the information needed to produce a database. In addition, it will create a Mega2.BATCH file, similar to the one we suggested you use. You can look at the “Quick Start” section of the Mega2 documentation <a href="https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html" class="uri">https://watson.hgen.pitt.edu/docs/mega2_html/mega2.html</a> to better understand the interactive process.</p>
<p>The MEGA2.BATCH.seqsimr file begins with a rather long comment indicating the keyword values that may be set and their default value. Toward the end of the file, we see the inputs set to <strong>Mega2r.ped</strong> and <strong>Mega2r.map</strong>, indicate the input is PLINK ped format with parameters, and indicate that Mega2 should produce a database called <strong>seqsimr.db</strong>, etc. (These particular items are in bold face text below.)</p>
<blockquote>
<p><strong>Input_Database_Mode=1</strong><br />
<strong>Input_Format_Type=4</strong><br />
<strong>Input_Pedigree_File=Mega2r.ped</strong><br />
<strong>Input_PLINK_Map_File=Mega2r.map</strong><br />
Output_Path=.<br />
Input_Path=.<br />
<strong>PLINK_Args= –cM –missing-phenotype -9 –trait default</strong><br />
Input_Untyped_Ped_Option=2<br />
Input_Do_Error_Sim=no<br />
AlleleFreq_SquaredDev=999999999.000000<br />
Value_Marker_Compression=1<br />
<strong>Analysis_Option=Dump</strong><br />
Value_Missing_Quant_On_Input=-9.000000<br />
Value_Missing_Affect_On_Input=-9<br />
Count_Genotypes=4<br />
Count_Halftyped=no<br />
Value_Genetic_Distance_Index=0<br />
Value_Genetic_Distance_SexTypeMap=0<br />
Value_Base_Pair_Position_Index=1<br />
Default_Reset_Invalid=no<br />
<strong>DBfile_name=seqsimr.db</strong><br />
Default_Outfile_Names=yes</p>
</blockquote>
<p>If you wish to use any of the Mega2R functions described here on your own data, you will have to run “mega2” to convert your data into an ‘SQLite’ database.</p>
</div>
<div id="reading-and-examining-a-mega2-database" class="section level2">
<h2>5.2 Reading and Examining a Mega2 Database</h2>
<p>The Mega2R package facilitates reading genetic data from a Mega2-created ‘SQLite’ database.</p>
<div id="reading-a-mega2-database" class="section level3">
<h3>5.2.1 Reading a Mega2 database</h3>
<p>After you have created the ‘SQLite’ database, start up the R program. Load the Mega2R package, then use the function <code>read.Mega2DB</code> to read a Mega2 database.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">library</span>(Mega2R)</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co"># above.</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb9-6"><a href="#cb9-6"></a>ENV =<span class="st"> </span><span class="kw">read.Mega2DB</span>(db, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<p>The first argument <code>db</code> should be the name of the database (including the path if needed); here we have set <code>db</code> to point to the <code>seqsimr.db</code> example database file provided with this R package. Providing the optional argument, <code>verbose</code>, causes the read function to summarize the tables created, their fields and their sizes. Finally, an “R environment”, that contains the database tables is returned. (If you are unfamiliar with environments, you can think of them as data frames. <code>ENV$locus_table</code> will access the <code>locus_table</code> variable from <code>ENV</code> similar to fetching an “observation” from a data frame. The difference is when you change a data frame passed to a function, the change does not affect the original data frame. Only the function’s local value is changed; ALL changes are forgotten when the function exits. If you change the data in an environment passed to a function, the change is permanent.)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co"># above.</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb10-5"><a href="#cb10-5"></a>ENV =<span class="st"> </span><span class="kw">read.Mega2DB</span>(db, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## int_table    35  3   
## int_table    pId key value   
## 
## charstar_table   9   3   
## charstar_table   pId key value   
## 
## pedigree_table   20  8   
## pedigree_table   pId Num EntryCnt    Name    PedPre  OriginalID  origped pedigree_link   
## 
## person_table 1380    11  
## person_table pId UniqueID    OrigID  FamName PerPre  ID  Father  Mother  Sex pedigree_link   person_link 
## 
## pedigree_brkloop_table   20  8   
## pedigree_brkloop_table   pId Num EntryCnt    Name    PedPre  OriginalID  origped pedigree_link   
## 
## person_brkloop_table 1380    11  
## person_brkloop_table pId UniqueID    OrigID  FamName PerPre  ID  Father  Mother  Sex pedigree_link   person_link 
## 
## locus_table  1001    5   
## locus_table  pId LocusName   Type    AlleleCnt   locus_link  
## 
## allele_table 2002    5   
## allele_table pId AlleleName  Frequency   indexX  locus_link  
## 
## marker_table 1000    7   
## marker_table pId MarkerName  pos_avg pos_female  pos_male    chromosome  locus_link  
## 
## map_table    2000    6   
## map_table    pId marker  map position    pos_female  pos_male    
## 
## mapnames_table   2   6   
## mapnames_table   pId map sex_averaged_map    male_sex_map    female_sex_map  name    
## 
## traitaff_table   1   4   
## traitaff_table   pId ClassCnt    PenCnt  locus_link  
## 
## affectclass_table    1   9   
## affectclass_table    pId MaleDef FemaleDef   AutoDef MalePen FemalePen   AutoPen locus_link  class_link  
## 
## phenotype_table  1380    4   
## phenotype_table  pId person_link bytes   data    
## 
## genotype_table   1380    5   
## genotype_table   pId person_link chr bytes   data    </code></pre>
<p>For each table generated, if ‘verbose’ is TRUE, we emit two lines: one with the number of rows and number of columns of the table and the other with the column names of the table.</p>
<p>We need to make two observations that apply to all Mega2R functions:</p>
</div>
<div id="verbose-flag" class="section level3">
<h3>5.2.2 Verbose Flag</h3>
<p>When verbose is set in the initial read.Mega2DB, the value will be remembered. It may be used by any subsequent function. If verbose is TRUE, Mega2R functions can print diagnostic information.</p>
</div>
<div id="use-of-an-environment" class="section level3">
<h3>5.2.3 Use of an Environment</h3>
<p>All Mega2R functions that do not return an environment need to have an environment supplied as an argument. As stated earlier, the environment is used to store the data frames that contain the ‘SQLite’ database. There are two ways to pass the environment. If you assigned the result of <code>read.Mega2DB</code> to the variable <code>seqsimr</code>, then you could supply the value <code>seqsimr</code> to any Mega2R function as the named argument <code>envir</code>:</p>
<pre><code>showMega2ENV(envir = seqsimr)</code></pre>
<p>The second choice is a bit of a “hack” but it is very convenient. Every Mega2R function (that does not return an environment) has a named <code>envir</code> argument defined to take on the default value <code>ENV</code>:</p>
<pre><code>envir = ENV</code></pre>
<p>as in</p>
<pre><code>showMega2ENV = function(envir = ENV) { ... }</code></pre>
<p>The code above, assigns global variable <code>ENV</code> to the local variable, <code>envir</code>. Thus if <code>envir</code> is not provided in the function call, R will look up the value of <code>ENV</code> in the global environment. This “hack” does not handle the case where <code>ENV</code> is defined in an outer frame which is not the global environment. In this situation, we search backwards/upwards from the calling frame to find the first <code>ENV</code> and use it.</p>
</div>
<div id="back-to-more-examples." class="section level3">
<h3>5.2.4 Back to more examples.</h3>
<p>The <code>ls</code> function will show you all the variables in an environment. (You probably have used it without arguments to show you the variables in the .GlobalEnv.) Type:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">ls</span>(ENV)</span></code></pre></div>
<pre><code>##  [1] &quot;DBMega2Version&quot;         &quot;DBcompress&quot;             &quot;LocusCnt&quot;              
##  [4] &quot;MARKER_SCHEME&quot;          &quot;Mega2R&quot;                 &quot;PhenoCnt&quot;              
##  [7] &quot;affectclass_table&quot;      &quot;allele_table&quot;           &quot;charstar_table&quot;        
## [10] &quot;chr2int&quot;                &quot;dosage&quot;                 &quot;dosageRaw&quot;             
## [13] &quot;entrezGene&quot;             &quot;fam&quot;                    &quot;int_table&quot;             
## [16] &quot;locus_allele_table&quot;     &quot;locus_table&quot;            &quot;map_table&quot;             
## [19] &quot;mapnames_table&quot;         &quot;marker_table&quot;           &quot;markers&quot;               
## [22] &quot;pedigree_brkloop_table&quot; &quot;pedigree_table&quot;         &quot;person_brkloop_table&quot;  
## [25] &quot;person_table&quot;           &quot;phenotype_table&quot;        &quot;positionVsName&quot;        
## [28] &quot;refIndices&quot;             &quot;refRanges&quot;              &quot;traitaff_table&quot;        
## [31] &quot;txdb&quot;                   &quot;unified_genotype_table&quot; &quot;verbose&quot;</code></pre>
<p>A more informative overview of the database can be had with:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">showMega2ENV</span>()</span></code></pre></div>
<pre><code>## locus count:   1001; phenotype count:  1; compression: 2 bits
## marker count:  1000; sample count:  1380
## 
## genetic and physical maps:
##   map name map number
## 1      Map          0
## 2       BP          1
## 
## Phenotypes:
##   Index    Name      Type
## 1     1 default affection
## 
## 
## basic tables:
##                        rows cols
## affectclass_table         1    9
## allele_table           2002    5
## charstar_table            9    3
## int_table                35    3
## locus_table            1001    5
## map_table              2000    6
## mapnames_table            2    6
## marker_table           1000    8
## pedigree_brkloop_table   20    8
## pedigree_table           20    8
## person_brkloop_table   1380   11
## person_table           1380   11
## phenotype_table        1380    4
## traitaff_table            1    4
## 
## derived tables:
##                        rows cols
## fam                    1380    8
## markers                1000    5
## unified_genotype_table 1380    2</code></pre>
</div>
<div id="use-standard-r-operations-to-examine-the-created-data-frames" class="section level3">
<h3>5.2.5 Use standard R operations to examine the created data frames</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">str</span>(ENV<span class="op">$</span>locus_table)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    1001 obs. of  5 variables:
##  $ pId       : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ LocusName : chr  &quot;default&quot; &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; ...
##  $ Type      : int  2 4 4 4 4 4 4 4 4 4 ...
##  $ AlleleCnt : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ locus_link: int  0 1 2 3 4 5 6 7 8 9 ...</code></pre>
</div>
</div>
<div id="iterating-through-gene-transcripts" class="section level2">
<h2>5.3 Iterating through Gene Transcripts</h2>
<p>There are two ways to compute a function on the genotypes (or markers) in all the transcripts. These examples are explained more thoroughly in below.</p>
<div id="applyfntoranges" class="section level3">
<h3>5.3.1 applyFnToRanges</h3>
<p>Mega2R has an internal default list of the chromosome and base pair ranges for many gene transcripts. These transcripts come from the UCSC Genome Browser reference assembly GRCH37. The list was further modified to eliminate multiple records from the same gene with the exact same transcript start and transcript end. The list contains about 29,000 records. We show a bit of the data frame below. Each row contains 5 values: a transcript id, the gene id and three position values: chromosome, start base pair and end base pair.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">dim</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>## [1] 29062     5</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">head</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>##          XX    SYMBOL TXCHROM   TXSTART     TXEND
## 1 NM_005286    NPBWR2   chr20  62737182  62738184
## 2 NR_026775 LINC00240    chr6  26924771  26991753
## 3 NM_007188     ABCB8    chr7 150725509 150744869
## 4 NM_206883   SLC26A5    chr7 102993176 103086624
## 5 NM_206880     OR2V2    chr5 180581942 180582890
## 6 NM_206876    PPP1CB    chr2  28974613  29025806</code></pre>
<p>You may load your own range set instead of the default. You create a data frame that contains at least a chromosome “observation”, a start position “observation”, an end position “observation”, and possibly a name “observation”. And you create an integer vector that contains the column numbers of the chromosome “observation”, the start position “observation”, the end position “observation”, and optionally a name. If no name position is provided, a name column indicating the position will be added to the range. These two become the arguments to the <code>setRanges</code> function, viz.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a>ranges =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2240000</span>, <span class="dv">2245000</span>, <span class="dv">1</span>, <span class="dv">2245000</span>, <span class="dv">2250000</span>, <span class="dv">1</span>, <span class="dv">3760000</span>, <span class="dv">3761000</span>, </span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="dv">1</span>, <span class="dv">3761000</span>, <span class="dv">3762000</span>, <span class="dv">1</span>, <span class="dv">3762000</span>, <span class="dv">3763000</span>, <span class="dv">1</span>, <span class="dv">3763000</span>, <span class="dv">3764000</span>, <span class="dv">1</span>, <span class="dv">3764000</span>, <span class="dv">3765000</span>, </span>
<span id="cb25-3"><a href="#cb25-3"></a>    <span class="dv">1</span>, <span class="dv">3765000</span>, <span class="dv">3763760</span>, <span class="dv">1</span>, <span class="dv">3763760</span>, <span class="dv">3767000</span>, <span class="dv">1</span>, <span class="dv">3767000</span>, <span class="dv">3768000</span>, <span class="dv">1</span>, <span class="dv">3768000</span>, <span class="dv">3769000</span>, </span>
<span id="cb25-4"><a href="#cb25-4"></a>    <span class="dv">1</span>, <span class="dv">3769000</span>, <span class="dv">3770000</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">nrow =</span> <span class="dv">12</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">setRanges</span>(ranges, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="kw">dim</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>## [1] 12  4</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">head</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>##   X1      X2      X3          ChrStartEnd
## 1  1 2240000 2245000 chr1:2240000-2245000
## 2  1 2245000 2250000 chr1:2245000-2250000
## 3  1 3760000 3761000 chr1:3760000-3761000
## 4  1 3761000 3762000 chr1:3761000-3762000
## 5  1 3762000 3763000 chr1:3762000-3763000
## 6  1 3763000 3764000 chr1:3763000-3764000</code></pre>
<p>If you provide an index vector of 4 entries, the last one is assumed to be the column of the name for the range.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1"></a>ranges =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2240000</span>, <span class="dv">2245000</span>, <span class="dv">1</span>, <span class="dv">2245000</span>, <span class="dv">2250000</span>, <span class="dv">1</span>, <span class="dv">3760000</span>, <span class="dv">3761000</span>, </span>
<span id="cb29-2"><a href="#cb29-2"></a>    <span class="dv">1</span>, <span class="dv">3761000</span>, <span class="dv">3762000</span>, <span class="dv">1</span>, <span class="dv">3762000</span>, <span class="dv">3763000</span>, <span class="dv">1</span>, <span class="dv">3763000</span>, <span class="dv">3764000</span>, <span class="dv">1</span>, <span class="dv">3764000</span>, <span class="dv">3765000</span>, </span>
<span id="cb29-3"><a href="#cb29-3"></a>    <span class="dv">1</span>, <span class="dv">3765000</span>, <span class="dv">3763760</span>, <span class="dv">1</span>, <span class="dv">3763760</span>, <span class="dv">3767000</span>, <span class="dv">1</span>, <span class="dv">3767000</span>, <span class="dv">3768000</span>, <span class="dv">1</span>, <span class="dv">3768000</span>, <span class="dv">3769000</span>, </span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="dv">1</span>, <span class="dv">3769000</span>, <span class="dv">3770000</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, <span class="dt">nrow =</span> <span class="dv">12</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)</span>
<span id="cb29-5"><a href="#cb29-5"></a>ranges =<span class="st"> </span><span class="kw">data.frame</span>(ranges)</span>
<span id="cb29-6"><a href="#cb29-6"></a>ranges<span class="op">$</span>name =<span class="st"> </span>LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">12</span>]</span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="kw">names</span>(ranges) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;chr&quot;</span>, <span class="st">&quot;start&quot;</span>, <span class="st">&quot;end&quot;</span>, <span class="st">&quot;name&quot;</span>)</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="kw">setRanges</span>(ranges, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="kw">dim</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>## [1] 12  4</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">head</span>(ENV<span class="op">$</span>refRanges)</span></code></pre></div>
<pre><code>##   chr   start     end name
## 1   1 2240000 2245000    A
## 2   1 2245000 2250000    B
## 3   1 3760000 3761000    C
## 4   1 3761000 3762000    D
## 5   1 3762000 3763000    E
## 6   1 3763000 3764000    F</code></pre>
</div>
<div id="applyfntoranges-1" class="section level3">
<h3>5.3.2 applyFnToRanges</h3>
<p>The function:</p>
<blockquote>
<p>applyFnToRanges(DOcallback, envir = ENV)</p>
</blockquote>
<p>goes through each transcript/range entry in the default list of ranges and finds the markers that fall within the bounds. It then invokes the callback function for the range; the callback function is the first argument of the <em>applyFnToRanges</em> function. For all ranges that contain the same set of markers, the call back function is evaluated only once. (Note: This situation arises either because multiple named transcripts have the same start and end positions or because the granularity of the markers sampled is such that small changes in a range start and end position do not introduce additional markers into the range.)</p>
<p>The callback function is called with three arguments: the markers in range, the selected transcript/range entry and the environment. The callback function is expected to build an appropriate genotype matrix for the samples and each marker in the range (see Section 5.4). The call back is invoked repeatedly for each transcript range that contains any markers. If it is necessary to store information between successive invocations the environment (<code>envir</code>) can be used.</p>
<p>For the examples that follow, we use “show” as the call back function. As you can see, all it does is prints its range argument, markers argument and the head of the generated genotype matrix, in that order. It also prints a banner before each argument. Note: It does not print the environment argument value because it does not change.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1"></a>show =<span class="st"> </span><span class="cf">function</span>(m, r, e) {</span>
<span id="cb33-2"><a href="#cb33-2"></a>    <span class="kw">print</span>(<span class="st">&quot;rrrrrrrrrr&quot;</span>)</span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="kw">print</span>(r)</span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="kw">print</span>(<span class="st">&quot;mmmmmmmmmm&quot;</span>)</span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="kw">print</span>(m)</span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="kw">print</span>(<span class="st">&quot;g6g6g6g6g6&quot;</span>)</span>
<span id="cb33-7"><a href="#cb33-7"></a>    <span class="kw">print</span>(<span class="kw">head</span>(<span class="kw">getgenotypes</span>(m, <span class="dt">envir =</span> e)))</span>
<span id="cb33-8"><a href="#cb33-8"></a>}</span></code></pre></div>
<p>A simple example is shown below with the ranges value that was last set. We see that the ranges named “A” and “E” have markers in our example data set.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># apply function &#39;show&#39; to all the ranges ranges</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="kw">applyFnToRanges</span>(show)</span></code></pre></div>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   chr   start     end name
## 1   1 2240000 2245000    A
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 57         57              57   snp22730          1  2243896
## 58         58              58   snp22731          1  2243897
## 59         59              59   snp22733          1  2243899
## 60         60              60   snp22735          1  2243901
## 61         61              61   snp23360          1  2244526
## 62         62              62   snp23361          1  2244527
## 63         63              63   snp23362          1  2244528
## 64         64              64   snp23364          1  2244530
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   chr   start     end name
## 5   1 3762000 3763000    E
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;</code></pre>
<p>applyFnToRanges can also be provided explicit ranges as show below. This run is using a different set of ranges and thus finds a different set of ranges with markers: viz. range8m and range9m.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1"></a><span class="co"># apply function &#39;show&#39; to all genotypes on chromosomes 1 ranges</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">applyFnToRanges</span>(show, <span class="dt">ranges_arg =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">4e+06</span>, <span class="fl">5e+06</span>, <span class="st">&quot;range4m&quot;</span>, <span class="dv">1</span>, <span class="fl">5e+06</span>, </span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="fl">6e+06</span>, <span class="st">&quot;range5m&quot;</span>, <span class="dv">1</span>, <span class="fl">6e+06</span>, <span class="fl">7e+06</span>, <span class="st">&quot;range6m&quot;</span>, <span class="dv">1</span>, <span class="fl">7e+06</span>, <span class="fl">8e+06</span>, <span class="st">&quot;range7m&quot;</span>, <span class="dv">1</span>, </span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="fl">8e+06</span>, <span class="fl">9e+06</span>, <span class="st">&quot;range8m&quot;</span>, <span class="dv">1</span>, <span class="fl">9e+06</span>, <span class="fl">1e+07</span>, <span class="st">&quot;range9m&quot;</span>), <span class="dt">ncol =</span> <span class="dv">4</span>, <span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>), </span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="dt">indices_arg =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   X1    X2    X3      X4
## 5  1 8e+06 9e+06 range8m
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 73         73              73   snp30480          1  8264348
## 74         74              74   snp30484          1  8264352
## 75         75              75   snp30487          1  8264355
## 76         76              76   snp30491          1  8264359
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   X1    X2    X3      X4
## 6  1 9e+06 1e+07 range9m
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 77         77              77   snp32565          1  9124463
## 78         78              78   snp32567          1  9124465
## 79         79              79   snp32568          1  9124466
## 80         80              80   snp32570          1  9124468
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;</code></pre>
</div>
<div id="setannotations" class="section level3">
<h3>5.3.3 setAnnotations</h3>
<p>If you are iterating/selecting via genes, the default transcript database is “TxDb.Hsapiens.UCSC.hg19.knownGene” from Bioconductor; it is stored in the environment as shown below:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1"></a>ENV<span class="op">$</span>txdb</span></code></pre></div>
<pre><code>## [1] &quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1"></a>ENV<span class="op">$</span>entrezGene</span></code></pre></div>
<pre><code>## [1] &quot;org.Hs.eg.db&quot;</code></pre>
<p>Of course, you can change this database. Suppose we want to use build “hg18”, we would run:</p>
<pre><code>    setAnnotations(&quot;TxDb.Hsapiens.UCSC.hg18.knownGene&quot;, &quot;org.Hs.eg.db&quot;)</code></pre>
<p>Note: This gene also has transcript uc001akz.2 but its range is included within the uc001aky.1 transcript, so it is not processed.</p>
<p>If you are not using the “hg19” default, the <code>setAnnotations</code> command must be issued whenever R is started after the <code>Mega2R</code> library has been loaded. By way of a reminder, Section 4.2 explains how to choose and install “TxDb.Hsapiens.UCSC.hg19.knownGene” or a different Annotation database.</p>
</div>
<div id="applyfntogenes" class="section level3">
<h3>5.3.4 applyFnToGenes</h3>
<p>The function applyFnToGenes is called below to look for the transcripts of genes. We happen to know gene, “CEP104”, is in our data. Remember, this lookup is using “hg18”.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1"></a><span class="co"># apply function &#39;show&#39; to all transcripts on genes ELL2 and CARD15</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="kw">applyFnToGenes</span>(show, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;CEP104&quot;</span>))</span></code></pre></div>
<pre><code>## </code></pre>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;</code></pre>
<p>Switching to “hg19”, we see a different transcript id and transcript name as well as different start/end. But the same set of markers from our study fall in each range.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">setAnnotations</span>(<span class="st">&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;</span>, <span class="st">&quot;org.Hs.eg.db&quot;</span>)</span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="kw">applyFnToGenes</span>(show, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;CEP104&quot;</span>))</span></code></pre></div>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 65         65              65   snp24037          1  3762181
## 66         66              66   snp24039          1  3762183
## 67         67              67   snp24041          1  3762185
## 68         68              68   snp24048          1  3762192
## 69         69              69   snp24494          1  3762638
## 70         70              70   snp24499          1  3762643
## 71         71              71   snp24506          1  3762650
## 72         72              72   snp24507          1  3762651
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot;
## [2,] &quot;22&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot;
## [6,] &quot;22&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;</code></pre>
<p>The applyFnToGenes function has several other optional arguments that can request complete chromosomes, (multiple) ranges of base pairs on chromosomes, or collections of markers, in addition to the genes_arg argument. All these arguments define ranges that are passed to applyFnToRanges for evaluation. Note: If the genes_arg argument is set to the special “gene” string &quot;*&quot;, then all transcripts in the Bioconductor database, will match and be processed.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1"></a><span class="co"># apply function &#39;show&#39; to all genotypes on chromosomes 1 for two base pair</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="co"># ranges</span></span>
<span id="cb52-3"><a href="#cb52-3"></a><span class="kw">applyFnToGenes</span>(show, <span class="dt">ranges_arg =</span> <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">5e+06</span>, <span class="fl">1e+07</span>, <span class="dv">1</span>, <span class="fl">1e+07</span>, <span class="fl">1.5e+07</span>), <span class="dt">ncol =</span> <span class="dv">3</span>, </span>
<span id="cb52-4"><a href="#cb52-4"></a>    <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>))</span></code></pre></div>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID ALIAS           SYMBOL TXID TXNAME TXCHROM TXSTRAND TXSTART TXEND
## 1        -     - chr1:5e+06-1e+07    0      -       1        -   5e+06 1e+07
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 73         73              73   snp30480          1  8264348
## 74         74              74   snp30484          1  8264352
## 75         75              75   snp30487          1  8264355
## 76         76              76   snp30491          1  8264359
## 77         77              77   snp32565          1  9124463
## 78         78              78   snp32567          1  9124465
## 79         79              79   snp32568          1  9124466
## 80         80              80   snp32570          1  9124468
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [5,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot;
## [1] &quot;rrrrrrrrrr&quot;
##   ENTREZID ALIAS             SYMBOL TXID TXNAME TXCHROM TXSTRAND TXSTART
## 2        -     - chr1:1e+07-1.5e+07    0      -       1        -   1e+07
##     TXEND
## 2 1.5e+07
## [1] &quot;mmmmmmmmmm&quot;
##    locus_link locus_link_fill MarkerName chromosome position
## 81         81              81   snp34070          1 12812974
## 82         82              82   snp34071          1 12812975
## 83         83              83   snp34074          1 12812978
## 84         84              84   snp34075          1 12812979
## 85         85              85   snp34533          1 12813437
## 86         86              86   snp34534          1 12813438
## 87         87              87   snp34535          1 12813439
## 88         88              88   snp34536          1 12813440
## [1] &quot;g6g6g6g6g6&quot;
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [3,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;22&quot; &quot;22&quot; &quot;11&quot;
## [6,] &quot;11&quot; &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot;</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1"></a><span class="co"># apply function &#39;show&#39; to all genotypes for first marker in each chromosome (We</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="co"># only have data for chromosome 1.)  </span><span class="al">NOTE</span><span class="co">: Since we are using an arbitrary</span></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="co"># collection of markers, the range is not available.</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="kw">applyFnToGenes</span>(show, <span class="dt">markers_arg =</span> ENV<span class="op">$</span>markers[<span class="op">!</span><span class="kw">duplicated</span>(ENV<span class="op">$</span>markers<span class="op">$</span>chromosome), </span>
<span id="cb54-5"><a href="#cb54-5"></a>    <span class="dv">3</span>])</span></code></pre></div>
<pre><code>## [1] &quot;rrrrrrrrrr&quot;
## NULL
## [1] &quot;mmmmmmmmmm&quot;
##   locus_link locus_link_fill MarkerName chromosome position
## 1          1               1       snp1          1        2
## [1] &quot;g6g6g6g6g6&quot;
##      [,1]
## [1,] &quot;11&quot;
## [2,] &quot;11&quot;
## [3,] &quot;12&quot;
## [4,] &quot;11&quot;
## [5,] &quot;11&quot;
## [6,] &quot;11&quot;</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1"></a><span class="co"># apply function &#39;show&#39; to all genotypes on chromosomes 24 and 26.  remember our</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="co"># example database is only chr 1</span></span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="kw">applyFnToGenes</span>(show, <span class="dt">chrs_arg =</span> <span class="kw">c</span>(<span class="dv">24</span>, <span class="dv">26</span>))</span></code></pre></div>
<p>The example “show” function that we were using does not compute any statistics; it just shows the data that are available to analyze. The two functions below, “show2” and “show3”, compute a fisher exact test for trait vs marker and a chisq test of the same data. Hopefully, the code with comments is easy to understand.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1"></a>show.stat =<span class="st"> </span><span class="cf">function</span>(m, r, e, fn) {</span>
<span id="cb57-2"><a href="#cb57-2"></a>    <span class="kw">print</span>(r)</span>
<span id="cb57-3"><a href="#cb57-3"></a>    <span class="co"># collect genotypes for the set of markers &#39;m&#39;</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>    mm =<span class="st"> </span><span class="kw">getgenotypes</span>(m, <span class="dt">envir =</span> e)</span>
<span id="cb57-5"><a href="#cb57-5"></a>    <span class="co"># apply xxx.test of trait vs marker (accumulating samples)</span></span>
<span id="cb57-6"><a href="#cb57-6"></a>    pv =<span class="st"> </span><span class="kw">apply</span>(mm, <span class="dv">2</span>, fn)</span>
<span id="cb57-7"><a href="#cb57-7"></a>    <span class="kw">names</span>(pv) =<span class="st"> </span>m<span class="op">$</span>MarkerName</span>
<span id="cb57-8"><a href="#cb57-8"></a>    <span class="kw">print</span>(pv)</span>
<span id="cb57-9"><a href="#cb57-9"></a>}</span>
<span id="cb57-10"><a href="#cb57-10"></a></span>
<span id="cb57-11"><a href="#cb57-11"></a>show2 =<span class="st"> </span><span class="cf">function</span>(m, r, e) {</span>
<span id="cb57-12"><a href="#cb57-12"></a>    f =<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb57-13"><a href="#cb57-13"></a>        <span class="kw">tryCatch</span>(<span class="kw">fisher.test</span>(<span class="kw">table</span>(e<span class="op">$</span>fam<span class="op">$</span>trait, x)), <span class="dt">error =</span> <span class="cf">function</span>(e) {</span>
<span id="cb57-14"><a href="#cb57-14"></a>            <span class="kw">list</span>(<span class="dt">p.value =</span> <span class="ot">NA</span>)</span>
<span id="cb57-15"><a href="#cb57-15"></a>        })<span class="op">$</span>p.value</span>
<span id="cb57-16"><a href="#cb57-16"></a>    }</span>
<span id="cb57-17"><a href="#cb57-17"></a>    </span>
<span id="cb57-18"><a href="#cb57-18"></a>    <span class="kw">show.stat</span>(m, r, e, f)</span>
<span id="cb57-19"><a href="#cb57-19"></a>}</span>
<span id="cb57-20"><a href="#cb57-20"></a></span>
<span id="cb57-21"><a href="#cb57-21"></a>show3 =<span class="st"> </span><span class="cf">function</span>(m, r, e) {</span>
<span id="cb57-22"><a href="#cb57-22"></a>    f =<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb57-23"><a href="#cb57-23"></a>        <span class="kw">tryCatch</span>(<span class="kw">chisq.test</span>(<span class="kw">table</span>(e<span class="op">$</span>fam<span class="op">$</span>trait, x)), <span class="dt">error =</span> <span class="cf">function</span>(e) {</span>
<span id="cb57-24"><a href="#cb57-24"></a>            <span class="kw">list</span>(<span class="dt">p.value =</span> <span class="ot">NA</span>)</span>
<span id="cb57-25"><a href="#cb57-25"></a>        })<span class="op">$</span>p.value</span>
<span id="cb57-26"><a href="#cb57-26"></a>    }</span>
<span id="cb57-27"><a href="#cb57-27"></a>    </span>
<span id="cb57-28"><a href="#cb57-28"></a>    <span class="kw">show.stat</span>(m, r, e, f)</span>
<span id="cb57-29"><a href="#cb57-29"></a>}</span></code></pre></div>
<p>Try running</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1"></a><span class="kw">applyFnToGenes</span>(show2, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;CEP104&quot;</span>))</span></code></pre></div>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797
##  snp24037  snp24039  snp24041  snp24048  snp24494  snp24499  snp24506  snp24507 
## 0.2649470 0.9628246 1.0000000 0.2059075 0.6286297 0.6897829 0.6897829 0.6286297</code></pre>
<p>or</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">applyFnToGenes</span>(show3, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;CEP104&quot;</span>))</span></code></pre></div>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>##   ENTREZID  ALIAS SYMBOL TXID     TXNAME TXCHROM TXSTRAND TXSTART   TXEND
## 1     9731 CEP104 CEP104 4281 uc001aky.2       1        - 3728645 3773797</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: Chi-squared approximation may be incorrect&gt;</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: Chi-squared approximation may be incorrect&gt;
## tryFn() &lt;simpleWarning:: Chi-squared approximation may be incorrect&gt;
## tryFn() &lt;simpleWarning:: Chi-squared approximation may be incorrect&gt;
## tryFn() &lt;simpleWarning:: Chi-squared approximation may be incorrect&gt;</code></pre>
<pre><code>##  snp24037  snp24039  snp24041  snp24048  snp24494  snp24499  snp24506  snp24507 
## 0.2640127 0.9487084 1.0000000 0.1951090 0.6536253 0.7251600 0.7251600 0.6536253</code></pre>
</div>
</div>
<div id="iterating-through-the-genotypes" class="section level2">
<h2>5.4 Iterating through the Genotypes</h2>
<p>The callback functions described above will need the genotype information for the selected markers. The two functions below will collect that data. The first, <code>getgenotypes</code>, will return the allele nucleodides as they were coded in the sample data. (This function was illustrated by the <code>show</code> function above.) The second, <code>getgenotypesraw</code>, will return the allele numbers 1 and 2 encoded into an integer. The corresponding nucleotide can be looked up if needed.</p>
<div id="encoded-genotypes" class="section level3">
<h3>5.4.1 Encoded Genotypes</h3>
<p>The heart of the callback functions is the calculation of the genotype matrix of samples by markers. The genotype information is most often stored in a compressed 2 bit representation. An Rcpp function does the conversion of the compressed genotype data to nucleotides. The function</p>
<blockquote>
<p>getgenotypes(markers, envir = ENV)</p>
</blockquote>
<p>returns the matrix for the specified markers. It can take one additional argument that supplies a string to separate the two alleles of each marker. We will build a matrix for the first 10 markers of our data. Remember our database has 1380 samples so we will just show the head of the matrix.</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1"></a>genotype =<span class="st"> </span><span class="kw">getgenotypes</span>(ENV<span class="op">$</span>markers[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, ])</span>
<span id="cb69-2"><a href="#cb69-2"></a><span class="kw">dim</span>(genotype)</span></code></pre></div>
<pre><code>## [1] 1380   10</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">head</span>(genotype)</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot; 
## [2,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [3,] &quot;12&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [4,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [5,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;22&quot; &quot;11&quot; 
## [6,] &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;11&quot; &quot;12&quot; &quot;12&quot;</code></pre>
</div>
<div id="raw-genotypes" class="section level3">
<h3>5.4.2 Raw Genotypes</h3>
<p>The function</p>
<blockquote>
<p>getgenotypesraw(markers, envir = ENV)</p>
</blockquote>
<p>is similar to the <code>getgenotypes</code> function except that the matrix it returns contains an integer encoding for each genotype. The integer’s high 16 bits are the index for allele1 and the low 16 bits are the index for allele2. The function <code>getgenotypesraw</code> will be called with the same 10 markers as above.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1"></a><span class="co"># two ints in upper/lower half integer representing allele</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>raw =<span class="st"> </span><span class="kw">getgenotypesraw</span>(ENV<span class="op">$</span>markers[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, ])</span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="kw">dim</span>(raw)</span></code></pre></div>
<pre><code>## [1] 1380   10</code></pre>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1"></a><span class="kw">head</span>(raw)</span></code></pre></div>
<pre><code>##       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]   [,9] [,10]
## [1,] 65537 65537 65537 65537 65537 65537 65537 65537  65538 65538
## [2,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [3,] 65538 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [4,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [5,] 65537 65537 65537 65537 65537 65537 65537 65537 131074 65537
## [6,] 65537 65537 65537 65537 65537 65537 65537 65537  65538 65538</code></pre>
<p>Note: There are actually two different Rcpp functions for each named function in Section 5.4. One function processes compressed genotype data and the other function processes uncompressed genotype data.</p>
</div>
</div>
</div>
<div id="using-mega2r-to-carry-out-automated-gene-based-association-tests-using-pedgene" class="section level1">
<h1>6 Using Mega2R to carry out automated gene-based association tests using ‘pedgene’</h1>
<p>Mega2R provides functions that permit one to run the ‘pedgene’ package to carry out gene-based association tests on family data looping over selected marker subsets.</p>
<p>The ‘pedgene’ package implements methods for carrying out gene-based association tests on family data, and is available on CRAN as (<a href="https://CRAN.R-project.org/package=pedgene" class="uri">https://CRAN.R-project.org/package=pedgene</a>). It was written by Daniel Schaid and Jason Sinnwell<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div id="loading-a-mega2-database" class="section level2">
<h2>6.1 Loading a Mega2 database</h2>
<p>Rather than read the Mega2 ‘SQLite’ database with the <code>read.Mega2DB</code> function described previously, here we use a specialized <code>init_pedgene</code> function to read the Mega2 database. This latter function calls a utility function also used by <code>read.Mega2DB</code>. Then it creates, edits, and rewrites the family data, storing it in a <code>pedgene</code>-compatible data frame, <code>fam</code> . (<code>fam</code> merges data from the <code>pedigree_table</code>, <code>person_table</code> and <code>phenotype_table</code>.) <code>init_pedgene</code> purges persons with unknown case/control status which is necessary for the pedgene calculation. (When <code>fam</code> is filtered, similar filtering is done to the phenotype_table and the genotype_table.) Finally, <code>init_pedgene</code> calculates some values that will be used repeatedly and stores them in the environment that is returned.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb77-3"><a href="#cb77-3"></a><span class="co"># above.</span></span>
<span id="cb77-4"><a href="#cb77-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb77-5"><a href="#cb77-5"></a>ENV =<span class="st"> </span><span class="kw">init_pedgene</span>(db)</span></code></pre></div>
</div>
<div id="gene-ranges-reminder" class="section level2">
<h2>6.2 Gene Ranges reminder</h2>
<p>Mega2R has an internal default list of the chromosome and base pair ranges for a number of gene transcripts. These transcripts come from the UCSC Genome Browser reference assembly GRCH37. The list was further modified to eliminate multiple records of the same gene with the exact same transcript start and transcript end. These data contain about 29,000 records. You may load your own range set instead of the default. You create a data frame that contains at least a name “observation”, a chromosome “observation”, a start position “observation” and an end position “observation”. Then, you create an integer vector that contains the column numbers of the chromosome “observation”, the start position “observation” and the end position “observation”. These two objects are then arguments to the <code>setRanges</code> function, viz.</p>
<pre><code>        setRanges(Transcripts, Columns)</code></pre>
</div>
<div id="gene-transcripts-reminder" class="section level2">
<h2>6.3 Gene transcripts reminder</h2>
<p>If you plan to select transcripts by gene name, you must load them from Bioconductor. In Section 4.2, we indicated that you needed to type once to install the package:</p>
<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)
biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)</code></pre>
<p>And then, to use the desired transcription data base, use this command from the Mega2R package as part of your session:</p>
<pre><code>setAnnotations(txdb, entrezGene)</code></pre>
<p>where <code>txdb</code> is the name of Bioconductor transcription database, and <code>entrezGene</code> is the name of Bioconductor mapping of gene name or gene alias to entrez gene id.</p>
<div id="running-pedgene-on-transcripts" class="section level3">
<h3>6.4 Running pedgene on transcripts</h3>
<p>By default, the function <code>Mega2pedgene</code> examines the first 100 default transcripts and prints the results. For this database, the first 100 transcripts identifies only one transcript with several markers (It is found because it is on chromosome 1 and it has a range that overlaps with some of the markers in our study.) To make this tutorial exercise run faster, we noticed that the identified transcript appeared at transcript 54; so we will restrict pedgene to a small range of transcripts around 54, viz. 50 through 60:</p>
<p>Note: <code>verbose</code> needs to be TRUE, for these diagnostics to be printed.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="kw">Mega2pedgene</span>(<span class="dt">gs =</span> <span class="dv">50</span><span class="op">:</span><span class="dv">60</span>)</span></code></pre></div>
<pre><code>## tryFn() No markers in range: NR_052010, IL11RA, 9, 34653893, 34661898</code></pre>
<pre><code>## tryFn() No markers in range: NR_045785, CHIT1, 1, 203185206, 203198860</code></pre>
<pre><code>## tryFn() No markers in range: NM_017799, TMEM260, 14, 57046510, 57116232</code></pre>
<pre><code>## tryFn() No markers in range: NM_014705, DOCK4, 7, 111366163, 111846462</code></pre>
<pre><code>## tryFn() No markers in range: NM_003759, SLC4A4, 4, 72204769, 72437804</code></pre>
<pre><code>## tryFn() No markers in range: NM_002192, INHBA, 7, 41728600, 41742706</code></pre>
<pre><code>## tryFn() No markers in range: NM_002202, ISL1, 5, 50678957, 50690563</code></pre>
<pre><code>## tryFn() No markers in range: NM_003659, AGPS, 2, 178257470, 178408564</code></pre>
<pre><code>## tryFn() No markers in range: NM_003658, BARX2, 11, 129245880, 129322174</code></pre>
<pre><code>## tryFn() No markers in range: NM_018051, WDR60, 7, 158649268, 158738883</code></pre>
<pre><code>## CEP104 snp24037 520 646 214 
## CEP104 snp24039 940 386 54 
## CEP104 snp24041 1377 3 0 
## CEP104 snp24048 860 460 60 
## CEP104 snp24494 789 501 90 
## CEP104 snp24499 891 442 47 
## CEP104 snp24506 891 442 47 
## CEP104 snp24507 789 501 90 
##   chr   gene nvariants   start     end sKernel_BT pKernel_BT sBurden_BT
## 1   1 CEP104         8 3728644 3773797   31.96998  0.6297541 -0.6496837
##   pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW pKernel_UW
## 1  0.5158965   1184.995  0.5138866  -1.209563  0.2264468   222.8737  0.4111136
##   sBurden_UW pBurden_UW
## 1  -1.169488   0.242207</code></pre>
<p>You will see many reports of “No markers in range”, because the database only contains markers on a subrange of chromosome 1 whereas the transcripts span the entire genome. Occasionally you will see a listing of a gene name, markers, and count of 0, 1 and 2 genotypes, viz.</p>
<pre><code>CEP104 snp24037 520 646 214  
CEP104 snp24039 940 386 54  
CEP104 snp24041 1377 3 0  
CEP104 snp24048 860 460 60  
CEP104 snp24494 789 501 90  
CEP104 snp24499 891 442 47  
CEP104 snp24506 891 442 47  
CEP104 snp24507 789 501 90</code></pre>
<p>The genotype matrix for these markers, along with the markers, the range used, and the environment are passed to the call back function <code>DOpedgene</code>. <code>DOpedgene</code> converts the raw genotype encodings, 0x10001, 0x10002 (or 0x20001), and 0x20002 to the values 0, 1 and 2 (or 2, 1, 0) if 0x10001 is the genotype for the allele with the minor allele frequency. Then it runs <code>pedgene</code>. The results are automatically stored in a data frame with “observations”: prefix of chromosome, gene, number of markers and base pair range followed by Pedgene data: kernel and burden, value and p-values, four values for each of three weightings of the markers. These data are saved in the data frame, <code>pedgene_results</code>, in the environment. They are also printed when <code>verbose</code> is TRUE, viz.</p>
<p>Note: The results are always appended to the data frame. You should truncate it when necessary.</p>
<pre><code>   chr   gene nvariants   start     end sKernel_BT pKernel_BT sBurden_BT  
1 chr1 CEP104         8 3728644 3773797   31.96998  0.6297541 -0.6496837  
  pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW pKernel_UW  
1  0.5158965   1184.995  0.5138866  -1.209563  0.2264468   222.8737  0.4111136  
  sBurden_UW pBurden_UW  
1  -1.169488   0.242207</code></pre>
<p>You could run <code>Mega2pedgene</code> on all the transcript entries, but it takes a rather long time. You would type:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1"></a><span class="co"># we will skip this line for the Rmd document production because it takes too</span></span>
<span id="cb95-2"><a href="#cb95-2"></a><span class="co"># long</span></span>
<span id="cb95-3"><a href="#cb95-3"></a><span class="kw">applyFnToRanges</span>(DOpedgene, ENV<span class="op">$</span>refRanges, ENV<span class="op">$</span>refIndices, <span class="dt">envir =</span> ENV)</span></code></pre></div>
<p>If you run the above test, you will see that genes DISP1 and KIF26B have at least one p-value less than 0.01 and AK5 and STL7 at least one less than 0.03.</p>
</div>
<div id="running-pedgene-on-selected-genes" class="section level3">
<h3>6.5 Running pedgene on selected genes</h3>
<p>You may try searching for transcripts of specific genes. Here, the default transcript database is <code>TxDb.Hsapiens.UCSC.hg19.knownGene</code> from Bioconductor. Of course you can change it. Type:</p>
<pre><code>setAnnotations(&quot;txdb&quot;, &quot;genedb&quot;)</code></pre>
<p>where “txdb” is a string that is the name of transcript database that was fetched from Bioconductor, and similarly “genedb” is the name of a Bioconductor database that maps a gene id from the input to an entrez gene id. You need to install any new database with biocLite, as shown earlier.</p>
<p>We leave the command below as an exercise. It runs a bit slowly. It needs to find all the transcripts for each gene, to find all the markers between each pair of transcript start/end ranges, to compute the genotype matrix for these markers, and finally to call the callback function with appropriate arguments.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">applyFnToGenes</span>(DOpedgene, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;DISP1&quot;</span>, <span class="st">&quot;KIF26B&quot;</span>, <span class="st">&quot;AK5&quot;</span>, <span class="st">&quot;ST7L&quot;</span>), <span class="dt">envir =</span> ENV)</span></code></pre></div>
<p>But let us run this function for a few genes:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1"></a><span class="kw">applyFnToGenes</span>(DOpedgene, <span class="dt">genes_arg =</span> <span class="kw">c</span>(<span class="st">&quot;DISP1&quot;</span>, <span class="st">&quot;AK5&quot;</span>), <span class="dt">envir =</span> ENV)</span></code></pre></div>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>## tryFn() No markers in range: 26289, AK5, AK5, 1624, uc001dhm.2, 1, +, 77747662, 77780745</code></pre>
<pre><code>## AK5 snp80127 962 375 43 
## AK5 snp80131 1095 272 13 
## AK5 snp80142 1303 77 0 
## AK5 snp80148 1345 35 0 
##   chr gene nvariants    start      end sKernel_BT pKernel_BT sBurden_BT
## 2   1  AK5         4 77747662 78025654   2593.945   0.228311  -1.400928
##   pBurden_BT sKernel_MB pKernel_MB sBurden_MB pBurden_MB sKernel_UW pKernel_UW
## 2  0.1612355   1899.249 0.06206979  -2.263002 0.02363554   175.4195   0.051013
##   sBurden_UW pBurden_UW
## 2  -2.290307  0.0220035
## DISP1 snp332780 1375 5 0 
## DISP1 snp332781 675 559 146 
## DISP1 snp332783 1365 15 0 
## DISP1 snp332784 898 427 55 
##   chr  gene nvariants     start       end sKernel_BT  pKernel_BT sBurden_BT
## 3   1 DISP1         4 222988431 223179337    4559.34 0.004224181    1.44652
##   pBurden_BT sKernel_MB  pKernel_MB sBurden_MB  pBurden_MB sKernel_UW
## 3  0.1480315   5410.868 0.000253584   2.916462 0.003540261    277.508
##   pKernel_UW sBurden_UW pBurden_UW
## 3 0.04407319   2.094983 0.03617254</code></pre>
<p>You could run <code>Mega2pedgene</code> on all the transcript entries, but it takes a rather long time. You would type:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1"></a><span class="co"># we will skip this line for the Rmd document production because it takes too</span></span>
<span id="cb103-2"><a href="#cb103-2"></a><span class="co"># long</span></span>
<span id="cb103-3"><a href="#cb103-3"></a><span class="kw">applyFnToGenes</span>(DOpedgene, <span class="dt">genes_arg =</span> <span class="st">&quot;*&quot;</span>, <span class="dt">envir =</span> ENV)</span></code></pre></div>
<p>Note: The default behavior of <code>DOpedgene</code> is to append any new results to the end of the <code>ENV$pedgene_results</code> data frame.</p>
</div>
</div>
</div>
<div id="using-mega2r-to-carry-out-automated-gene-based-association-tests-using-skat" class="section level1">
<h1>7 Using Mega2R to carry out automated gene-based association tests using ‘SKAT’</h1>
<p>Mega2R provides functions to run the ‘SKAT’ package to carry out gene-based association tests using a kernel regression framework while looping over selected marker subsets.</p>
<p>The ‘SKAT’ package implements methods for carrying out gene-based association tests; it is available on CRAN as (<a href="https://CRAN.R-project.org/package=SKAT" class="uri">https://CRAN.R-project.org/package=SKAT</a>). It was written by Seunggeun Lee and Michael Wu<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<div id="loading-a-mega2-database-1" class="section level2">
<h2>7.1 Loading a Mega2 database</h2>
<p>The <code>init_SKAT</code> function is used to read the Mega2 database and initialize processing. This function calls the utility function, <code>dbmega2_import</code>, to read the database. Then it creates, edits, and rewrites the family data, storing it in the data frame, <code>fam</code>. (<code>fam</code> contains data merged from the <code>pedigree_table</code>, <code>person_table</code> and <code>phenotype_table</code>.) <code>init_SKAT</code> purges persons from the <code>fam</code> data frame with unknown case/control status. <code>setfam</code> sets <code>fam</code> in the environment and insures that filtering is done to the phenotype_table and the genotype_table so they all have the same person_link key. Next, <code>init_SKAT</code> decodes the phenotype_table into a simple data frame, <code>phe</code>. You will definitely want to examine <code>ENV</code>$<code>phe</code> to choose which phenotype to use for the case/control. In addition, <code>init_SKAT</code> calculates some values that will be used repeatedly and stores them in the environment that is returned. Finally, <code>init_SKAT</code> stores the argument <code>allMarkers</code> which tells later processing to ignore markers that show no variation (if FALSE).</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb104-2"><a href="#cb104-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb104-3"><a href="#cb104-3"></a><span class="co"># above.</span></span>
<span id="cb104-4"><a href="#cb104-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb104-5"><a href="#cb104-5"></a>ENV =<span class="st"> </span><span class="kw">init_SKAT</span>(db, <span class="dt">verbose =</span> F, <span class="dt">allMarkers =</span> F)</span></code></pre></div>
<p>You can run the command with verbose equals TRUE to see details of the database as it is loaded:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb105-2"><a href="#cb105-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb105-3"><a href="#cb105-3"></a><span class="co"># above.</span></span>
<span id="cb105-4"><a href="#cb105-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb105-5"><a href="#cb105-5"></a>ENV =<span class="st"> </span><span class="kw">init_SKAT</span>(db, <span class="dt">verbose =</span> T, <span class="dt">allMarkers =</span> F)</span></code></pre></div>
</div>
<div id="gene-ranges-reminder-1" class="section level2">
<h2>7.2 Gene Ranges reminder</h2>
<p>Mega2R also has an internal default list of the chromosome and base pair ranges for many gene transcripts. These transcripts come from the UCSC Genome Browser reference assembly GRCH37. The list was further modified to eliminate multiple records from the same gene with the exact same transcript start and transcript end. The list contains about 29,000 records. You may load your own range set instead of the default. Create a data frame that contains at least a name “observation”, a chromosome “observation”, a start position “observation” and an end position “observation”. And create an integer vector that contains the column numbers of the chromosome “observation”, the start position “observation” and the end position “observation”. These two become the arguments to the <code>setRanges</code> function, viz.</p>
<pre><code>setRanges(Ranges, Columns)</code></pre>
</div>
<div id="gene-transcripts-reminder-1" class="section level2">
<h2>7.3 Gene transcripts reminder</h2>
<p>Gene transcripts are defined according to a Bioconductor database containing the boundaries of the gene transcripts or defined by an internal table, <code>refRanges</code>, with the boundaries. The gene transcripts require two Bioconductor Annotations databases to be installed. The first line (below) loads the Bioconductor loader and the next two lines install two annotation databases. One annotation database provides the gene transcript locations and the other maps gene names to entrez gene IDs. (Note: You may choose a different transcript database from Bioconductor or construct one of your own.) Please type in R:</p>
<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)

biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)</code></pre>
<p>The above step is run once.</p>
<p>By default, Mega2R presumes that the databases, “TxDb.Hsapiens.UCSC.hg19.knownGene” and “org.Hs.eg.db” are selected. Otherwise you must make your choices known to Mega2 via the command:</p>
<pre><code>setAnnotations(txdb, entrezGene)</code></pre>
<p>where <code>txdb</code> is the name of Bioconductor transcription database, and <code>entrezGene</code> is the name of Bioconductor mapping of gene name or gene alias to entrez gene id.</p>
<p>Note that, in this case, if <code>init_SKAT</code> has been run as indicated above, then it loaded both a <code>txdb</code> and a <code>entrezGene</code> into the <code>ENV</code> environment. While these are already the set annotations, we could explicitly set them via this command:</p>
<pre><code>setAnnotations(ENV$txdb, ENV$entrezGene)</code></pre>
</div>
<div id="running-mega2skat-on-ranges" class="section level2">
<h2>7.4 Running Mega2SKAT on ranges</h2>
<p>You should be familiar with the SKAT functions of the SKAT package before you read this section. The function, <code>Mega2SKAT</code>, is Mega2R’s interface to SKAT, both to <code>SKAT_Null_Model</code> and <code>SKAT</code>. Its signature is:</p>
<pre><code>Mega2SKAT = function (f, ty, gs = 1:100, skat = SKAT::SKAT, envir = ENV, ...) { }</code></pre>
<p>The <code>gs</code> argument indicates how many default range elements should be processed and the <code>envir</code> argument specifies the environment that contains all the Mega2R data frames.</p>
<p>Most of the time, before you call <code>SKAT</code>, you need to call <code>SKAT_Null_Model</code> with a formula and an indicator for the type of the phenotype. <code>Mega2SKAT</code> will take its first two arguments, a formula and a type (string) and call <code>SKAT_Null_Model</code> with this information, viz.</p>
<pre><code>SKAT_Null_Model(f, out_type = ty)</code></pre>
<p>and store the results (in obj in the environment).</p>
<p>If the formula, <code>f</code>, is NULL, Mega2SKAT will not call <code>SKAT_Null_Model</code> and you must do the equivalent before calling <code>Mega2SKAT</code>. Store the result object in ENV$obj. There are several reasons a custom call to the build the model could be necessary. You might want to use <code>SKAT_Null_Model</code> but provided additional arguments viz. data, Adjustment, n.Resampling, type.Resampling. Alternatively, you might need to use a different model viz. SKAT_NULL_emmaX, SKAT_Null_Model_ChrX.</p>
<p>The <code>skat</code> argument specifies the name of the SKAT package function to use; this is usually SKAT::SKAT, but could be SKAT::SKATBinary, SKAT::SKAT_CommonRare, etc. Any additional, arguments needed for the “skat” functions are provided to the <code>Mega2SKAT</code> function and will be passed to the eventual call. All the “skat” functions are called with a genotype matrix for the markers, the object representing the Null Model and the additional arguments.</p>
<p>The Mega2R loop engine, iterates through each range and determines the set of markers contained. If there are no markers in a range, the genotype matrix is empty and Mega2SKAT will issue a warning. If a marker has no variation, Mega2SKAT will omit it, if the variable allMarkers is FALSE. Mega2SKAT will include it, if allMarkers is TRUE, but SKAT will more than likely issue a warning. The Mega2SKAT function also defines a callback function that converts the raw genotype information 0x10001, 0x10002 (or 0x20001) and 0x20002 to 0, 1, and 2 with the major allele (flipped if necessary to be) 0 and then calls the specified “skat” function with the required arguments. Finally, the callback function stores the results.</p>
<p>By default, the function <code>Mega2SKAT</code> examines the first 100 transcripts and prints the results. Note: <code>verbose</code> is FALSE to eliminate the (excessive) diagnostics. A typical invocation of <code>Mega2SKAT</code> could be:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb112-1"><a href="#cb112-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb112-2"><a href="#cb112-2"></a>ENV<span class="op">$</span>SKAT_results =<span class="st"> </span>ENV<span class="op">$</span>SKAT_results[<span class="dv">0</span>, ]</span>
<span id="cb112-3"><a href="#cb112-3"></a><span class="kw">Mega2SKAT</span>(ENV<span class="op">$</span>phe[, <span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="st">&quot;D&quot;</span>, <span class="dt">kernel =</span> <span class="st">&quot;linear.weighted&quot;</span>, <span class="dt">weights.beta =</span> <span class="kw">c</span>(<span class="fl">0.5</span>, </span>
<span id="cb112-4"><a href="#cb112-4"></a>    <span class="fl">0.5</span>))</span></code></pre></div>
<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!</code></pre>
<p>These data are saved in the data frame, <code>SKAT_results</code>, in the environment. Note: The results are always appended to the data frame. You should truncate it when necessary.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1"></a><span class="kw">print</span>(ENV<span class="op">$</span>SKAT_results)</span></code></pre></div>
<pre><code>##   chr   gene nvariants   start     end      skat
## 1   1 CEP104         8 3728644 3773797 0.4906803</code></pre>
<div class="sourceCode" id="cb116"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1"></a><span class="co"># we will skip this line for the Vignette document production because it takes</span></span>
<span id="cb116-2"><a href="#cb116-2"></a><span class="co"># too long</span></span>
<span id="cb116-3"><a href="#cb116-3"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb116-4"><a href="#cb116-4"></a>ENV<span class="op">$</span>SKAT_results =<span class="st"> </span>ENV<span class="op">$</span>SKAT_results[<span class="dv">0</span>, ]</span>
<span id="cb116-5"><a href="#cb116-5"></a><span class="kw">Mega2SKAT</span>(ENV<span class="op">$</span>phe[, <span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="st">&quot;D&quot;</span>, <span class="dt">kernel =</span> <span class="st">&quot;linear.weighted&quot;</span>, <span class="dt">weights.beta =</span> <span class="kw">c</span>(<span class="fl">0.5</span>, </span>
<span id="cb116-6"><a href="#cb116-6"></a>    <span class="fl">0.5</span>), <span class="dt">gs =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ENV<span class="op">$</span>refRanges))</span>
<span id="cb116-7"><a href="#cb116-7"></a><span class="kw">print</span>(ENV<span class="op">$</span>SKAT_results)</span></code></pre></div>
</div>
<div id="running-mega2skat-on-genes" class="section level2">
<h2>7.5 Running Mega2SKAT on genes</h2>
<p>Let us run the Mega2SKAT function for a few genes:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1"></a>ENV<span class="op">$</span>SKAT_results =<span class="st"> </span>ENV<span class="op">$</span>SKAT_results[<span class="dv">0</span>, ]</span>
<span id="cb117-2"><a href="#cb117-2"></a><span class="kw">Mega2SKAT</span>(ENV<span class="op">$</span>phe[, <span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="st">&quot;D&quot;</span>, <span class="dt">kernel =</span> <span class="st">&quot;linear.weighted&quot;</span>, <span class="dt">weights.beta =</span> <span class="kw">c</span>(<span class="fl">0.5</span>, </span>
<span id="cb117-3"><a href="#cb117-3"></a>    <span class="fl">0.5</span>), <span class="dt">genes =</span> <span class="kw">c</span>(<span class="st">&quot;DISP1&quot;</span>, <span class="st">&quot;AK5&quot;</span>, <span class="st">&quot;KIF26B&quot;</span>, <span class="st">&quot;ST7L&quot;</span>), <span class="dt">envir =</span> ENV)</span></code></pre></div>
<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!</code></pre>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1"></a><span class="kw">print</span>(ENV<span class="op">$</span>SKAT_results)</span></code></pre></div>
<pre><code>##   chr   gene nvariants     start       end        skat
## 1   1    AK5         4  77747662  78025654 0.061956810
## 2   1   ST7L         2 113066141 113153625 0.026524419
## 3   1 KIF26B         8 245318287 245809683 0.009316182
## 4   1  DISP1         4 222988431 223179337 0.001014347</code></pre>
<p>Note: we set verbose to FALSE otherwise there will be a large number of print outs indicating no markers are in the range. (Recall the samples come from part of chromosome one, whereas the ranges cover the whole genome.) If you are adventurous you can look at all the transcripts:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb123-2"><a href="#cb123-2"></a>ENV<span class="op">$</span>SKAT_results =<span class="st"> </span>ENV<span class="op">$</span>SKAT_results[<span class="dv">0</span>, ]</span>
<span id="cb123-3"><a href="#cb123-3"></a><span class="kw">Mega2SKAT</span>(ENV<span class="op">$</span>phe[, <span class="dv">3</span>] <span class="op">-</span><span class="st"> </span><span class="dv">1</span> <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="st">&quot;D&quot;</span>, <span class="dt">kernel =</span> <span class="st">&quot;linear.weighted&quot;</span>, <span class="dt">weights.beta =</span> <span class="kw">c</span>(<span class="fl">0.5</span>, </span>
<span id="cb123-4"><a href="#cb123-4"></a>    <span class="fl">0.5</span>), <span class="dt">genes =</span> <span class="st">&quot;*&quot;</span>, <span class="dt">envir =</span> ENV)</span></code></pre></div>
<pre><code>## Sample size (non-missing y and X) = 1380, which is &lt; 2000. The small sample adjustment is applied!</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<p>Note: The default behavior of <code>Mega2SKAT</code> is to append any new results to the end of the <code>ENV$SKAT_results</code> data frame.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1"></a><span class="kw">print</span>(ENV<span class="op">$</span>SKAT_results)</span></code></pre></div>
<pre><code>##    chr      gene nvariants     start       end        skat
## 1    1   DDX11L1         8     11874     14409 0.084358684
## 2    1    NBPF20         4 144151519 144830407 0.165218819
## 3    1 GNG12-AS1         4  68297971  68668670 1.000000000
## 4    1  MIR548F1         4 186029867 186446655 0.739856169
## 5    1     TESK2         4  45809555  45923543 0.434699375
## 6    1   SDCCAG8         8 243449574 243663393 0.740460394
## 7    1     WDR63         8  85527993  85598821 0.957805022
## 8    1       CR1        12 207669473 207783033 0.792580813
## 9    1     GLIS1         4  53971906  54199877 0.479708780
## 10   1      DAB1         4  57463579  58716211 0.465837198
## 11   1       DPT         4 168664695 168698442 0.159566866
## 12   1       AK4         4  65613850  65697828 0.267672523
## 13   1     EPRS1         8 220160484 220220000 1.000000000
## 14   1     NTNG1         4 107682629 108024475 0.268167106
## 15   1      ATF6        20 161736034 161835745 0.911072117
## 16   1    SRGAP2         8 206557369 206628046 0.090416819
## 17   1       AK5         4  77747662  78025654 0.061842146
## 18   1    BRINP3         4 190066797 190444942 1.000000000
## 19   1 LINC01140         4  87458690  87634886 1.000000000
## 20   1     KCNT2         4 196194913 196577499 0.516330128
## 21   1   TRABD2B         8  48226200  48462562 0.203056661
## 22   1   C1orf53         8 197871682 197876497 1.000000000
## 23   1      NCF2         4 183524697 183559739 0.372465906
## 24   1      NPR1         4 153651164 153666468 1.000000000
## 25   1   PLEKHO1         4 150122170 150131825 0.650174139
## 26   1     PI4KB         8 151264273 151300191 0.418035046
## 27   1     GDAP2         4 118406107 118472302 0.304581565
## 28   1      ST7L         2 113066141 113161550 0.026425571
## 29   1     MARC2        16 220921676 220957596 0.365127207
## 30   1    KIF26B         8 245318287 245809683 0.010093813
## 31   1      HHAT         4 210612927 210849638 0.268299801
## 32   1   GATAD2B         8 153777203 153895451 0.885562098
## 33   1     LRRC7         4  70225874  70589171 0.535160220
## 34   1     LRRC7         4  70032868  70340687 0.882258194
## 35   1      RGS7         4 240938817 241520478 0.518737533
## 36   1      RYR2         8 237205702 237997288 0.504633474
## 37   1    SLC2A5         4   9117507   9148510 1.000000000
## 38   1    WASH7P        12     14362     16765 0.707292718
## 39   1    WASH7P         8     15603     29370 1.000000000
## 40   1      EVI5         4  93029199  93159945 0.323859557
## 41   1     TTC13         4 231041987 231114618 0.724342010
## 42   1   C1orf21         4 184356150 184598155 0.239426450
## 43   1    IGSF21         4  18434240  18704977 0.558091927
## 44   1     DISP1         4 222988431 223179337 0.001061588
## 45   1       CD2         4 117297086 117308084 0.092554839
## 46   1  C1orf158         8  12806163  12821102 0.505969086
## 47   1    NOS1AP         4 162039581 162326974 0.326857707
## 48   1    CEP104         8   3750235   3773797 0.500883328
## 49   1    CDK11B         4   1571100   1655775 0.778438867</code></pre>
</div>
</div>
<div id="using-mega2r-to-carry-out-automated-gene-based-association-tests-using-famskat_rc" class="section level1">
<h1>8 Using Mega2R to carry out automated gene-based association tests using ‘famSKAT_RC’</h1>
<p>Mega2R provides functions to run the ‘famSKAT_RC’ package that carries out family-based association kernel tests for both rare and common variants while looping over selected marker subsets. With the appropriate parameter settings adjusting the percent of rare variants and the family kinship matrix, ‘famSKAT_RC’ behaves as SKAT, famSKAT and/or SKAT_RC.</p>
<p>The ‘famSKATRC’ package is available on CRAN as (<a href="https://CRAN.R-project.org/package=famSKATRC" class="uri">https://CRAN.R-project.org/package=famSKATRC</a>). It was written by Mohamad Saad1 and Ellen M. Wijsman1<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>.</p>
<div id="loading-a-mega2-database-2" class="section level2">
<h2>8.1 Loading a Mega2 database</h2>
<p>The <code>init_famSKATRC</code> function is used to read the Mega2 database and initialize processing. This function calls the utility function, <code>dbmega2_import</code>, to read a database. Then it creates, edits, and rewrites the family data making sure that the members are uniquely labeled; it stores the results in the data frame, <code>fam</code>. (<code>fam</code> contains data merged from the <code>pedigree_table</code>, <code>person_table</code> and <code>phenotype_table</code>.) Next, <code>init_famSKATRC</code> decodes the phenotype_table into a simple data frame, <code>phe</code> which it stores in the environment; missing/zero valued entries are set to ‘NA’. You will definitely want to examine <code>ENV</code>$<code>phe</code> to choose which phenotype to use for analysis. Finally, <code>init_famSKATRC</code> calculates some values that will be used repeatedly and stores them in the environment. These data include a kinship matrix calculated from the <code>fam</code> family data and weighting functions provided for both the rare variant and also for the common variant based on the beta distribution.</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb129-2"><a href="#cb129-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb129-3"><a href="#cb129-3"></a><span class="co"># above.</span></span>
<span id="cb129-4"><a href="#cb129-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb129-5"><a href="#cb129-5"></a>ENV =<span class="st"> </span><span class="kw">init_famSKATRC</span>(db, <span class="dt">verbose =</span> F)</span></code></pre></div>
<p>The <code>setfam</code> function is designed to let you prune the family structure and store it. It ensures that all the other original tables that have family member data will be updated. <code>mkphenotype</code> if it is used (which it is in <code>init_famSKATRC</code>), has to be called whenever the <code>fam</code> table is changed (which happens in <code>setfam</code>).</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1"></a><span class="co"># The special hack below reduces the samples to 20% of the original, so the run</span></span>
<span id="cb130-2"><a href="#cb130-2"></a><span class="co"># will finish in reasonable time. There are 20 different pedigrees.</span></span>
<span id="cb130-3"><a href="#cb130-3"></a><span class="kw">setfam</span>(ENV<span class="op">$</span>fam[(ENV<span class="op">$</span>fam<span class="op">$</span>pedigree_link <span class="op">%in%</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span>), ], ENV)</span>
<span id="cb130-4"><a href="#cb130-4"></a></span>
<span id="cb130-5"><a href="#cb130-5"></a>ENV<span class="op">$</span>phe =<span class="st"> </span><span class="kw">mkphenotype</span>(ENV)</span>
<span id="cb130-6"><a href="#cb130-6"></a>ENV<span class="op">$</span>phe[ENV<span class="op">$</span>phe <span class="op">==</span><span class="st"> </span><span class="dv">0</span>] =<span class="st"> </span><span class="ot">NA</span></span></code></pre></div>
<p>You can run the init command with verbose equals TRUE to see the details of the database load and to enable later printouts:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb131-2"><a href="#cb131-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb131-3"><a href="#cb131-3"></a><span class="co"># above.</span></span>
<span id="cb131-4"><a href="#cb131-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb131-5"><a href="#cb131-5"></a>ENV =<span class="st"> </span><span class="kw">init_famSKATRC</span>(db, <span class="dt">verbose =</span> T)</span></code></pre></div>
</div>
<div id="gene-ranges-reminder-2" class="section level2">
<h2>8.2 Gene Ranges reminder</h2>
<p>Mega2R also has an internal default list of the chromosome and base pair ranges for many gene transcripts stored in an internal table <code>refRanges</code>. These transcripts come from the UCSC Genome Browser reference assembly GRCH37. The list was further modified to eliminate multiple records from the same gene with the exact same transcript start and transcript end. The list contains about 29,000 records.</p>
<p>You may load your own range set instead of the default. Create a data frame that contains at least a name “observation”, a chromosome “observation”, a start position “observation” and an end position “observation”. And create an integer vector that contains the column numbers of the chromosome “observation”, the start position “observation” and the end position “observation”. These two become the arguments to the <code>setRanges</code> function, viz.</p>
<pre><code>setRanges(Ranges, Columns)</code></pre>
</div>
<div id="gene-transcripts-reminder-2" class="section level2">
<h2>8.3 Gene transcripts reminder</h2>
<p>Gene transcripts can alternatively be defined according to a Bioconductor database containing the boundaries of the gene transcripts. The gene transcripts require two Bioconductor Annotations databases to be installed. The first line (below) loads the Bioconductor loader and the next two lines install two annotation databases. One annotation database provides the gene transcript locations and the other maps gene names to entrez gene IDs. (Note: You may choose a different transcript database from Bioconductor or construct one of your own.) Please type in R:</p>
<pre><code>source(&quot;https://bioconductor.org/biocLite.R&quot;)

biocLite(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;) 
biocLite(&quot;org.Hs.eg.db&quot;)</code></pre>
<p>The above function is roughly the equivalent of the R language <code>install.packages</code>; it is run once.</p>
<p>By default, Mega2R uses the databases: “TxDb.Hsapiens.UCSC.hg19.knownGene” and “org.Hs.eg.db”; you may choose alternates via the command:</p>
<pre><code>setAnnotations(txdb, entrezGene)</code></pre>
<p>where <code>txdb</code> is the name of Bioconductor transcription database, and <code>entrezGene</code> is the name of Bioconductor mapping of gene name or gene alias to entrez gene id. This command may be issued any time before the <code>mega2famSKATRC</code> command is called. The defaults were set with:</p>
<pre><code>setAnnotations(&quot;TxDb.Hsapiens.UCSC.hg19.knownGene&quot;, &quot;org.Hs.eg.db&quot;)
</code></pre>
</div>
<div id="running-mega2famskatrc-on-ranges" class="section level2">
<h2>8.4 Running Mega2famSKATRC on ranges</h2>
<p>You should be familiar with the famSKAT_RC function of the famSKATRC package and especially its many arguments which are more completely explained in the documentation.</p>
<p>The function, <code>Mega2famSKATRC</code>, is Mega2R’s interface to famSKAT_RC. Its signature is:</p>
<pre><code>Mega2famSKATRC = function (gs = 1:100, genes = NULL, envir = ENV, ...) { }</code></pre>
<p>The <code>gs</code> argument indicates how many default range elements should be processed, <code>genes</code> if not NULL is a vector of gene names to process (with ’*’ representing all known genes) and the <code>envir</code> argument specifies the environment that contains all the Mega2R data frames.</p>
<p>Any additional, arguments needed for the “famSKAT_RC” function should be provided to the <code>Mega2famSKATRC</code> function and they will be passed to the eventual call to “famSKAT_RC”. The “famSKAT_RC” function is also called with a genotype dosage matrix of the markers.</p>
<p>The Mega2R loop engine iterates through each range and determines the set of markers contained. If there are no markers in a range, the genotype matrix is empty and <code>Mega2famSKATRC</code> will issue a warning. If a marker shows no variation, <code>Mega2famSKATRC</code> will omit it. The <code>Mega2famSKATRC</code> function uses an internal function that converts the raw genotype value 0x10001, 0x10002 (or 0x20001) and 0x20002 to 0, 1, and 2 with the major allele (flipped if necessary to be) 0 and then calls the <code>famSKAT_RC</code> function with the required arguments. Finally, the <code>Mega2famSKATRC</code> callback function stores the results.</p>
<p>By default, the function <code>Mega2famSKATRC</code> processes the first 100 transcripts and prints the results. Note: Set <code>verbose</code> to FALSE to eliminate the (excessive) diagnostics. A typical invocation of <code>Mega2famSKATRC</code> would be:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb137-2"><a href="#cb137-2"></a><span class="kw">Mega2famSKATRC</span>(<span class="dt">pheno =</span> <span class="dv">3</span>, <span class="dt">gs =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">60</span>)</span></code></pre></div>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<p>These data are saved in the data frame, <code>famSKATRC_results</code>, in the environment. Note: The results are always appended to the data frame. You should truncate it when necessary. Also, you may want to save these results to a file.</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1"></a><span class="kw">print</span>(ENV<span class="op">$</span>famSKATRC_results)</span></code></pre></div>
<pre><code>##   chr   gene nvariants   start     end user.self sys.self elapsed famSKATRC1
## 1   1 CEP104         8 3728644 3773797     3.465    0.239    3.76   0.417261
##   famSKATRC2 famSKATRC3 famSKATRC4
## 1  0.5111286  0.6570682  0.7798193</code></pre>
<div class="sourceCode" id="cb141"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb141-1"><a href="#cb141-1"></a><span class="co"># we will skip this line for the Vignette document production because it takes</span></span>
<span id="cb141-2"><a href="#cb141-2"></a><span class="co"># too long</span></span>
<span id="cb141-3"><a href="#cb141-3"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb141-4"><a href="#cb141-4"></a><span class="kw">Mega2famSKATRc</span>(<span class="dt">pheno =</span> <span class="dv">3</span>, <span class="dt">gs =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ENV<span class="op">$</span>refRanges))</span>
<span id="cb141-5"><a href="#cb141-5"></a><span class="kw">print</span>(ENV<span class="op">$</span>famSKATRC_results)</span></code></pre></div>
</div>
<div id="running-mega2famskatrc-on-genes" class="section level2">
<h2>8.5 Running Mega2famSKATRC on genes</h2>
<p>Let us run the <code>Mega2famSKATRC</code> function for a few genes.<br />
Processing time scales with sample size and number of ranges/genes to be processed. It is not dependent on the number of markers. On an old iMac, this statement below takes 3 minutes per gene for the full 1380 samples. But, remember we have reduce the samples to a total of 276 or 20% of the size of the samples in the database.</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb142-2"><a href="#cb142-2"></a><span class="kw">Mega2famSKATRC</span>(<span class="dt">pheno =</span> <span class="dv">3</span>, <span class="dt">genes =</span> <span class="kw">c</span>(<span class="st">&quot;DISP1&quot;</span>, <span class="st">&quot;AK5&quot;</span>, <span class="st">&quot;KIF26B&quot;</span>, <span class="st">&quot;ST7L&quot;</span>), <span class="dt">envir =</span> ENV)</span></code></pre></div>
<pre><code>## &#39;select()&#39; returned 1:1 mapping between keys and columns</code></pre>
<pre><code>## &#39;select()&#39; returned 1:many mapping between keys and columns</code></pre>
<pre><code>## tryFn() No markers in range: 26289, AK5, AK5, 1624, uc001dhm.2, 1, +, 77747662, 77780745</code></pre>
<pre><code>## tryFn() No markers in range: 55083, KIF26B, KIF26B, 4014, uc010pyr.2, 1, +, 245516980, 245535019</code></pre>
<pre><code>## tryFn() No markers in range: 55083, KIF26B, KIF26B, 4015, uc001ibg.1, 1, +, 245674304, 245852109</code></pre>
<pre><code>## tryFn() No markers in range: 55083, KIF26B, KIF26B, 4016, uc001ibh.1, 1, +, 245809394, 245852109</code></pre>
<pre><code>## AK5 snp80127 184 79 13 
## AK5 snp80131 213 59 4 
## AK5 snp80142 268 8 0 
## AK5 snp80148 261 15 0</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>##   chr gene nvariants    start      end user.self sys.self elapsed famSKATRC1
## 2   1  AK5         4 77747662 78025654     3.927    0.249   4.195   0.182881
##   famSKATRC2 famSKATRC3 famSKATRC4
## 2  0.2504308  0.5136662  0.8300378
## ST7L snp144498 186 81 9 
## ST7L snp144501 183 90 3</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>##   chr gene nvariants     start       end user.self sys.self elapsed famSKATRC1
## 3   1 ST7L         2 113066141 113153625      3.24    0.212   3.455  0.2117074
##   famSKATRC2 famSKATRC3 famSKATRC4
## 3  0.2117074  0.2117074  0.2117074
## KIF26B snp358996 276 0 0 
## KIF26B snp358997 185 81 10 
## KIF26B snp358999 206 68 2 
## KIF26B snp359000 261 15 0 
## KIF26B snp359211 223 52 1 
## KIF26B snp359213 238 37 1 
## KIF26B snp359214 228 47 1 
## KIF26B snp359220 225 50 1</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>##   chr   gene nvariants     start       end user.self sys.self elapsed
## 4   1 KIF26B         7 245318287 245809683     3.219    0.214   3.438
##   famSKATRC1 famSKATRC2 famSKATRC3 famSKATRC4
## 4  0.4889175  0.5186314  0.5168329  0.3973495
## DISP1 snp332780 274 2 0 
## DISP1 snp332781 79 137 60 
## DISP1 snp332783 276 0 0 
## DISP1 snp332784 152 105 19</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: Consider playing with &#39;lim&#39; or &#39;acc&#39;.&gt;</code></pre>
<pre><code>## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;
## tryFn() &lt;simpleWarning:: imaginary parts discarded in coercion&gt;</code></pre>
<pre><code>##   chr  gene nvariants     start       end user.self sys.self elapsed famSKATRC1
## 5   1 DISP1         3 222988431 223179337     3.233    0.209   3.446          1
##   famSKATRC2 famSKATRC3 famSKATRC4
## 5  0.4021516  0.1161365  0.0509027</code></pre>
<div class="sourceCode" id="cb161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb161-1"><a href="#cb161-1"></a><span class="kw">print</span>(ENV<span class="op">$</span>famSKATRC_results)</span></code></pre></div>
<pre><code>##   chr   gene nvariants     start       end user.self sys.self elapsed
## 1   1 CEP104         8   3728644   3773797     3.465    0.239   3.760
## 2   1    AK5         4  77747662  78025654     3.927    0.249   4.195
## 3   1   ST7L         2 113066141 113153625     3.240    0.212   3.455
## 4   1 KIF26B         7 245318287 245809683     3.219    0.214   3.438
## 5   1  DISP1         3 222988431 223179337     3.233    0.209   3.446
##   famSKATRC1 famSKATRC2 famSKATRC3 famSKATRC4
## 1  0.4172610  0.5111286  0.6570682  0.7798193
## 2  0.1828810  0.2504308  0.5136662  0.8300378
## 3  0.2117074  0.2117074  0.2117074  0.2117074
## 4  0.4889175  0.5186314  0.5168329  0.3973495
## 5  1.0000000  0.4021516  0.1161365  0.0509027</code></pre>
<p>If you are adventurous you can look at all the genes: Note: Below, we set verbose to FALSE; otherwise there would be a large number of printouts indicating no markers are in many of the ranges. (Recall the samples come from part of chromosome one, whereas the ranges cover the whole genome.)</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="#cb163-1"></a>ENV<span class="op">$</span>verbose =<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb163-2"><a href="#cb163-2"></a><span class="kw">Mega2famSKATRC</span>(<span class="dt">pheno =</span> <span class="dv">3</span>, <span class="dt">genes =</span> <span class="st">&quot;*&quot;</span>, <span class="dt">envir =</span> ENV)</span>
<span id="cb163-3"><a href="#cb163-3"></a><span class="kw">print</span>(ENV<span class="op">$</span>famSKATRC_results)</span></code></pre></div>
<p>Note: The <code>Mega2famSKATRC</code> function appends any new results to the end of the <code>ENV$famSKATRC_results</code> data frame.</p>
</div>
</div>
<div id="outputting-mega2r-data-to-vcf-format" class="section level1">
<h1>9 Outputting Mega2R data to VCF format</h1>
<p>The <code>Mega2VCF</code> function can output subsets of the Mega2R database as a VCF file, accompanied by related files (for phenotype and family data).</p>
<p>The VCF data format (<a href="https://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/" class="uri">https://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/</a>) was originally defined by the 1000 Genomes Project (<a href="https://www.internationalgenome.org/home" class="uri">https://www.internationalgenome.org/home</a>) for data storage.</p>
<p>The current version of data format can be found at (<a href="https://samtools.github.io/hts-specs/" class="uri">https://samtools.github.io/hts-specs/</a>).</p>
<div id="writing-a-vcf-file-using-mega2r" class="section level2">
<h2>9.1 Writing a VCF File using Mega2R</h2>
<p>First, create the directory “vcfr”, so we can keep all the generated data in one place.</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb164-1"><a href="#cb164-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb164-2"><a href="#cb164-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb164-3"><a href="#cb164-3"></a><span class="co"># above.</span></span>
<span id="cb164-4"><a href="#cb164-4"></a>vcfdir =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;vcfr&quot;</span>)</span>
<span id="cb164-5"><a href="#cb164-5"></a><span class="cf">if</span> (<span class="op">!</span><span class="kw">dir.exists</span>(vcfdir)) <span class="kw">dir.create</span>(vcfdir)</span></code></pre></div>
<p>The Mega2VCF function takes an argument which is the prefix used on all generated files. We will make it a path that includes the directory vcfr. Below, we assume that a Mega2 database was stored in the environment, <code>ENV</code>. If this is not the case, supply to Mega2VCF a named argument, <code>envir</code>, set to the environment you wish to use. (You will also have to change the references to the <code>markers</code> data frame, below, from <code>ENV</code>$markers to “environment name”$markers.)</p>
<p>Note that Mega2VCF will create the .vcf file as well as a .fam file (in linkage format), a .phe file (phenotypes) and a few others. These files are listed below.</p>
<p>Creating the VCF file and related files is accomplished by typing:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb165-1"><a href="#cb165-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb165-2"><a href="#cb165-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb165-3"><a href="#cb165-3"></a><span class="co"># above.</span></span>
<span id="cb165-4"><a href="#cb165-4"></a>vcffile =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;vcfr&quot;</span>, <span class="st">&quot;vcf.01&quot;</span>)</span>
<span id="cb165-5"><a href="#cb165-5"></a><span class="kw">Mega2VCF</span>(vcffile, ENV<span class="op">$</span>markers[ENV<span class="op">$</span>markers<span class="op">$</span>chromosome <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ])</span></code></pre></div>
<p>Note: The line above places the data for only chromosome 1 in the files (Recall that our simulated data is only on chromosome 1).</p>
<p>Note: In general, you can filter <code>ENV$markers</code> as needed. If the second argument is not present, all the markers are written out.</p>
<p>The generated files are listed below:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb166-1"><a href="#cb166-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb166-2"><a href="#cb166-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb166-3"><a href="#cb166-3"></a><span class="co"># above.</span></span>
<span id="cb166-4"><a href="#cb166-4"></a>vcfdir =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;vcfr&quot;</span>)</span>
<span id="cb166-5"><a href="#cb166-5"></a><span class="kw">list.files</span>(vcfdir)</span></code></pre></div>
<pre><code>## [1] &quot;vcf.01.fam&quot;  &quot;vcf.01.freq&quot; &quot;vcf.01.map&quot;  &quot;vcf.01.pen&quot;  &quot;vcf.01.phe&quot; 
## [6] &quot;vcf.01.vcf&quot;</code></pre>
<p>You can read the code to see how these files are created from the data frames. It is worth noting that the internal logic does not create a genotype matrix for all the requested markers at once, but rather works on a block of markers at a time, limiting the amount of memory required. The code also illustrates how to extract the phenotype values from the phenotype raw vectors.</p>
</div>
</div>
<div id="converting-mega2r-data-to-genabel-format" class="section level1">
<h1>10 Converting Mega2R data to GenABEL format</h1>
<p>Mega2R provides support for converting the data frames into ‘GenABEL’ format (e.g. as gwaa.data-class objects) using the functions of GenABEL.</p>
<p>The ‘GenABEL’ package is available on CRAN as (<a href="https://CRAN.R-project.org/package=GenABEL" class="uri">https://CRAN.R-project.org/package=GenABEL</a>) in the archive (GenABEL was archived in late May 2018). The Mega2R library does not implicitly include GenABEL. You must explicitly add the GenABEL library to your workspace. If Mega2R finds GenABEL in your workspace, the functions <code>Mega2GenABEL</code> and <code>Mega2ENVGenABEL</code> will be available. Otherwise, the functions will just return NULL. (In the example below, we use “require” instead of “library” to illustrate this behavior&quot;.)</p>
<p>The reference for GenABEL is <a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div id="creating-a-genabel-gwaa.data-class-object-using-mega2r" class="section level2">
<h2>10.1 Creating a GenABEL gwaa.data-class object using Mega2R</h2>
<p>There are several data formats that Mega2 can read and transform into a database that are not directly accepted by GenABEL. But any Mega2 database that can be read into R, can be transformed to GenABEL following this example using <em>seqsimr.db</em>.</p>
<p>GenABEL can process PLINK .tped/.tfam files with the function <code>convert.snp.tped</code> to create a GenABEL “raw” file. Then the “raw” file and a generated phenotype file can be processed by the function, <code>load.gwaa.data</code>, to yield a gwaa.data-class object. Currently, the function, <code>Mega2GenABEL</code>, uses this mechanism to convert Mega2 data frames to a gwaa.data-class object. The .tped/.fam/.phe files are created in a scratch space, file.path(tempdir(), Mega2GenABEL). They are deleted when the <code>Mega2GenABEL</code> function exits. The GenABEL functions <code>convert.snp.tped</code> and <code>load.gwaa.data</code> are explained in <a href="https://cran.r-project.org/package=GenABEL" class="uri">https://cran.r-project.org/package=GenABEL</a>.</p>
<p>If you haven’t already, first install the ‘GenABEL’ package from CRAN. Since ‘GenABEL’ is not readily available (and only available from the CRAN Archive), we will show you the commands and then what you would have seen if you had ‘GenABEL’ installed.</p>
<p>If you typed:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="#cb168-1"></a><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>)</span>
<span id="cb168-2"><a href="#cb168-2"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb168-3"><a href="#cb168-3"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb168-4"><a href="#cb168-4"></a><span class="co"># above.</span></span>
<span id="cb168-5"><a href="#cb168-5"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb168-6"><a href="#cb168-6"></a>ENV =<span class="st"> </span><span class="kw">read.Mega2DB</span>(db)</span>
<span id="cb168-7"><a href="#cb168-7"></a></span>
<span id="cb168-8"><a href="#cb168-8"></a><span class="co"># This line converts the database to a gwaa.data-class object. The intermediate</span></span>
<span id="cb168-9"><a href="#cb168-9"></a><span class="co"># files are in tempdir() and begin with &#39;Mega2GenABEL&#39;</span></span>
<span id="cb168-10"><a href="#cb168-10"></a>seqsimgwaa =<span class="st"> </span><span class="kw">Mega2GenABEL</span>()</span></code></pre></div>
<p>You would see:</p>
<pre><code>require(&quot;GenABEL&quot;)

## Loading required package: GenABEL
## Loading required package: MASS
## 
## Attaching package: &#39;MASS&#39;
## The following object is masked _by_ &#39;.GlobalEnv&#39;:
## 
##     genotype

## Loading required package: GenABEL.data
# Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;sTutorial Data&#39; section
# above.

db = file.path(where_mega2rtutorial_data(), &quot;seqsimr.db&quot;)
ENV = read.Mega2DB(db)

# This line converts the database to a gwaa.data-class object. The intermediate
# files are in tempdir() and begin with &#39;Mega2GenABEL&#39;
seqsimgwaa = Mega2GenABEL()

## Reading individual ids from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tfam&#39; ...
## ... done.  Read 1380 individual ids from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tfam&#39;
## Reading genotypes from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tped&#39; ...
## ...done.  Read 1000 SNPs from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tped&#39;
## Writing to file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABELtped.raw&#39;
## ...
## ... done.
## ids loaded...
## marker names loaded...
## chromosome data loaded...
## map data loaded...
## allele coding data loaded...
## strand data loaded...
## genotype data loaded...
## snp.data object created...
## assignment of gwaa.data object FORCED; X-errors were not checked!</code></pre>
<p>You can use any of the GenABEL provided functions on the results, <code>seqsimgwaa</code>. If you typed:</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb170-1"><a href="#cb170-1"></a><span class="kw">str</span>(seqsimgwaa)</span></code></pre></div>
<p>You would see:</p>
<pre><code>str(seqsimgwaa)

## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   1380 obs. of  3 variables:
##   .. ..$ id     : chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. ..$ sex    : int [1:1380] 0 1 1 1 1 0 0 0 0 0 ...
##   .. ..$ default: int [1:1380] 1 1 1 1 1 1 1 1 1 1 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 345
##   .. .. ..@ nids      : int 1380
##   .. .. ..@ nsnps     : int 1000
##   .. .. ..@ idnames   : chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. .. ..@ snpnames  : chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ map       : Named num [1:1000] 2 3 4 5 201 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1000] &quot;snp1&quot; &quot;snp2&quot; &quot;snp3&quot; &quot;snp4&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:1000] 01 01 01 01 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:1000] 00 00 00 00 ...
##   .. .. ..@ male      : Named int [1:1380] 0 1 1 1 1 0 0 0 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:1380] &quot;1SAP039_H05-0107&quot; &quot;1SAP039_H05-0106&quot; &quot;1SAP039_SAP039F14&quot; &quot;1SAP039_SAP039F13&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:345, 1:1000] 59 55 55 55 ...</code></pre>
</div>
</div>
<div id="converting-mega2r-data-to-gds-corearray-format" class="section level1">
<h1>11 Converting Mega2R data to GDS (CoreArray) format</h1>
<p>CoreArray Genetic Data Structure (GDS)<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> is a C++ package available from SourceForge<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> as <a href="http://corearray.sourceforge.net" class="uri">http://corearray.sourceforge.net</a>. The Bioconductor<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> package <code>gdsfmt</code> (<a href="https://bioconductor.org/packages/release/bioc/html/gdsfmt.html" class="uri">https://bioconductor.org/packages/release/bioc/html/gdsfmt.html</a>) provides a machine independent R<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> language interface to GDS. <code>gdsfmt</code> provides access to the underlying named vector hierarchy and named matrix hierarchy. The Bioconductor package SeqArray (<a href="https://bioconductor.org/packages/release/bioc/html/SeqArray.html" class="uri">https://bioconductor.org/packages/release/bioc/html/SeqArray.html</a>) uses the named CoreArray GDS variables to store (and retrieve) a complete VCF file. The SeqArray API can be used to apply analysis functions to the underlying GWAS data. In addition, SeqArray data may be converted to a related format SNPArray (Note the package is called SNPRelate (<a href="https://bioconductor.org/packages/release/bioc/html/SNPRelate.html" class="uri">https://bioconductor.org/packages/release/bioc/html/SNPRelate.html</a>).) which allows linkage analysis to be performed on the GWAS data.</p>
<p>It is not our intention in this document to explain the CoreArray structure or all the structures that are used to represent the VCF GWS data. The reader is encourage to examine the above references. If your data were available in VCF format, or another format that can be processed to produce a Mega2 database, the following section shows how to convert the Mega2 database to either a SNPArray or SeqArray.</p>
<p>Note: Since the packages used here are sourced from Bioconductor, installation is performed by:</p>
<pre><code>if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE))
    install.packages(&quot;BiocManager&quot;)

BiocManager::install(&quot;gdsfmt&quot;)
BiocManager::install(&quot;SeqArray&quot;)
BiocManager::install(&quot;SNPRelate&quot;)</code></pre>
<p>After the installation is performed, you may use the ‘library()’ function to add the code to your R workspace.</p>
<div id="corearray-features-vs-mega2r-database-features" class="section level2">
<h2>11.1 CoreArray features vs Mega2R database features</h2>
<p>There are two important issues that are necessary to understand when converting a Mega2R database to CoreArray format. First, because of the design of CoreArray it is easier (and probably more efficient) to add sucessive new columns to the genotype array. The Mega2R design makes it easy to retrieve complete columns representing samples of arbitrary markers. Thus, the default usage is to create a genotype array that is indexed by sample and then marker. This layout is optimal to fetch columns of samples from the array. However, if there are multiple program that you will use that fetch some markers for selected samples, the genotype array should be organized as markers by samples. In this case, it would be best to create the array with the latter organization; there is an option to make this choice.</p>
<p>Second, SeqArray is designed to store all the information in any VCF file. In particular, it can distinguish both haplotypes and genotypes markers. And it can represent biallelic and multi-allelic markers. Mega2R can not handle either of these options. (Actually, Mega2R does fine with multi-alleleic markers but that is not yet supported by Mega2gdsfmt.) Mega2R will always present the heterozygous genotype value as Ref Allele, then Alt allele. The SNPArray format, like Mega2R, does not support haplotypes or multi-alleleic markers.</p>
</div>
<div id="creating-a-gds-file-using-mega2r" class="section level2">
<h2>11.2 Creating a GDS file using Mega2R</h2>
<p>The Mega2R function, <code>Mega2gdsfmt()</code>, creates a ‘.gds’ file from the Mega2R database; it is called as shown below</p>
<pre><code>    Mega2gdsfmt(filename = &quot;test.gds&quot;, markers = NULL, snp.order = FALSE, SeqArray = FALSE, envir = ENV)

The arguments are:
</code></pre>
<ul>
<li><p><em>filename</em> - CoreArray (gds) file to create</p></li>
<li><p><em>markers</em> - data frame of markers to be processed</p></li>
<li><p><em>snp.order</em> - TRUE indicates that the “genotype” data matrix has SNP as the first index (which changes more quickly than subsequent indices). FALSE indicates that SAMPLE is the the first index. Default is FALSE.</p></li>
<li><p><em>SeqArray</em> - TRUE uses SeqArray labels for the CoreArray elements. FALSE uses SNPRelate labels. Default is FALSE.</p></li>
<li><p><em>envir</em> - ‘environment’ containing SQLite database and other globals.</p></li>
<li><p><em>returns</em> - the “filename” file containing the CoreArray data. Then returns an internal pointer, class .gds, to the file data.</p></li>
</ul>
<p>We will illustrate the CoreArray files when they are created.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb174-1"><a href="#cb174-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb174-2"><a href="#cb174-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb174-3"><a href="#cb174-3"></a><span class="co"># above.</span></span>
<span id="cb174-4"><a href="#cb174-4"></a>db =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;seqsimr.db&quot;</span>)</span>
<span id="cb174-5"><a href="#cb174-5"></a>ENV =<span class="st"> </span><span class="kw">read.Mega2DB</span>(db)</span></code></pre></div>
<p>Below, we assume that a Mega2 database was stored in the environment, <code>ENV</code>. If this is not the case, supply the named argument, <code>envir</code>, wherever <code>ENV</code> is used.</p>
<div id="creating-the-gds-file-in-seqarray-gdsfmt-format" class="section level3">
<h3>11.2.1 Creating the GDS file in SeqArray gdsfmt format</h3>
<p>Type:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb175-1"><a href="#cb175-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: the gds file to be created must be closed with the function below, or by</span></span>
<span id="cb175-2"><a href="#cb175-2"></a><span class="co"># using an on.exit(closefn.gds(&lt;name&gt;))</span></span>
<span id="cb175-3"><a href="#cb175-3"></a><span class="kw">showfile.gds</span>(<span class="dt">closeall =</span> T, <span class="dt">verbose =</span> F)</span>
<span id="cb175-4"><a href="#cb175-4"></a></span>
<span id="cb175-5"><a href="#cb175-5"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb175-6"><a href="#cb175-6"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb175-7"><a href="#cb175-7"></a><span class="co"># above.</span></span>
<span id="cb175-8"><a href="#cb175-8"></a>gdsfile =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;foo.gds&quot;</span>)</span>
<span id="cb175-9"><a href="#cb175-9"></a>gdsn =<span class="st"> </span><span class="kw">Mega2gdsfmt</span>(gdsfile, ENV<span class="op">$</span>markers[ENV<span class="op">$</span>markers<span class="op">$</span>chromosome <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ], <span class="dt">SeqArray =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## Clean up the fragments of GDS file:
##     open the file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds&#39; (683.0K)
##     # of fragments: 79
##     save to &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds.tmp&#39;
##     rename &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds.tmp&#39; (92.2K, reduced: 590.8K)
##     # of fragments: 38</code></pre>
<p>Note: The line above places the data for only chromosome 1 in the gds file. (Recall that our simulated data is only on chromosome 1). Note: In general, you can filter the second argument, <code>ENV$markers</code>, as needed. If the second argument is not present, all the markers are written out.</p>
<p>The created gds file with its variable heirarchy values is listed below:</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb177-1"><a href="#cb177-1"></a><span class="kw">print</span>(gdsn)</span></code></pre></div>
<pre><code>## File: /private/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T/RtmpOZZxzW/Mega2Rtutorial/foo.gds (92.2K)
## +    [  ] *
## |--+ description   [  ]
## |--+ sample.id   { Str8 1380 LZMA_ra(2.37%), 317B }
## |--+ variant.id   { Int32 1000 LZMA_ra(18.1%), 733B }
## |--+ position   { Int32 1000 LZMA_ra(38.6%), 1.5K }
## |--+ chromosome   { Int32 1000 LZMA_ra(2.75%), 117B } *
## |--+ allele   { Str8 1000 LZMA_ra(2.75%), 117B }
## |--+ genotype   [  ]
## |  |--+ data   { Bit2 2x1380x1000 LZMA_ra(12.4%), 83.5K } *
## |  |--+ extra.index   { Int32 3x0 LZMA_ra, 18B }
## |  \--+ extra   { Int16 0 LZMA_ra, 18B }
## |--+ phase   [  ]
## |  |--+ data   { Bit1 1380x1000 LZMA_ra(0.10%), 181B }
## |  |--+ extra.index   { Int32 3x0 LZMA_ra, 18B }
## |  \--+ extra   { Bit1 0 LZMA_ra, 18B }
## |--+ annotation   [  ]
## |  |--+ id   { Str8 1000 LZMA_ra(13.9%), 1.3K }
## |  |--+ qual   { Float32 1000 LZMA_ra(2.75%), 117B }
## |  |--+ filter   { Int32,factor 1000 LZMA_ra(2.75%), 117B } *
## |  |--+ info   [  ]
## |  \--+ format   [  ]
## \--+ sample.annotation   [  ]
##    \--+ family   { Str8 1380 LZMA_ra(1.58%), 193B }</code></pre>
<div class="sourceCode" id="cb179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb179-1"><a href="#cb179-1"></a><span class="kw">closefn.gds</span>(gdsn)</span></code></pre></div>
</div>
<div id="creating-the-snprelate-file-in-snparray-gdsfmt-format" class="section level3">
<h3>11.2.2 Creating the SNPRelate file in SNPArray gdsfmt format</h3>
<p>Type:</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb180-1"><a href="#cb180-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co">: the gds file to be created must be closed with the function below, or by</span></span>
<span id="cb180-2"><a href="#cb180-2"></a><span class="co"># using an on.exit(closefn.gds(&lt;name&gt;))</span></span>
<span id="cb180-3"><a href="#cb180-3"></a><span class="kw">showfile.gds</span>(<span class="dt">closeall =</span> T, <span class="dt">verbose =</span> F)</span></code></pre></div>
<div class="sourceCode" id="cb181"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb181-1"><a href="#cb181-1"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb181-2"><a href="#cb181-2"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb181-3"><a href="#cb181-3"></a><span class="co"># above.</span></span>
<span id="cb181-4"><a href="#cb181-4"></a>gdsfile =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;foo.gds&quot;</span>)</span>
<span id="cb181-5"><a href="#cb181-5"></a>gdsn =<span class="st"> </span><span class="kw">Mega2gdsfmt</span>(gdsfile, ENV<span class="op">$</span>markers[ENV<span class="op">$</span>markers<span class="op">$</span>chromosome <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, ], <span class="dt">SeqArray =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<pre><code>## Clean up the fragments of GDS file:
##     open the file &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds&#39; (345.8K)
##     # of fragments: 71
##     save to &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds.tmp&#39;
##     rename &#39;/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T//RtmpOZZxzW/Mega2Rtutorial/foo.gds.tmp&#39; (84.0K, reduced: 261.8K)
##     # of fragments: 29</code></pre>
<p>Note: The line above places the data for only chromosome 1 in the gds file. (Recall that our simulated data is only on chromosome 1). Note: In general, you can filter the second argument, <code>ENV$markers</code>, as needed. If the second argument is not present, all the markers are written out.</p>
<p>The generated file and contents are listed below:</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="#cb183-1"></a><span class="kw">print</span>(gdsn)</span></code></pre></div>
<pre><code>## File: /private/var/folders/fh/_24twzc50lz_hj83x3r29t3c0000gq/T/RtmpOZZxzW/Mega2Rtutorial/foo.gds (84.0K)
## +    [  ] *
## |--+ description   [  ]
## |--+ sample.id   { Str8 1380 LZMA_ra(2.37%), 317B }
## |--+ snp.id   { Int32 1000 LZMA_ra(18.1%), 733B }
## |--+ snp.rs.id   { Str8 1000 LZMA_ra(13.9%), 1.3K }
## |--+ snp.position   { Int32 1000 LZMA_ra(38.6%), 1.5K }
## |--+ snp.chromosome   { Int32 1000 LZMA_ra(2.75%), 117B } *
## |--+ snp.allele   { Str8 1000 LZMA_ra(2.75%), 117B }
## |--+ genotype   { Bit2 1380x1000 LZMA_ra(22.4%), 75.6K } *
## \--+ sample.annot   [ data.frame ] *
##    |--+ sample.id   { Str8 1380 LZMA_ra(2.37%), 317B }
##    |--+ family.id   { Str8 1380 LZMA_ra(1.58%), 193B }
##    |--+ father.id   { Str8 1380 LZMA_ra(1.64%), 189B }
##    |--+ mother.id   { Str8 1380 LZMA_ra(1.67%), 193B }
##    |--+ sex.id   { Str8 1380 LZMA_ra(1.92%), 169B }
##    \--+ cc.id   { Int32 1380 LZMA_ra(4.67%), 265B }</code></pre>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="#cb185-1"></a><span class="kw">closefn.gds</span>(gdsn)</span></code></pre></div>
<p>You can process these files by programs that are designed to read them. For example, the SNPRelate library has functions that perform: LD-based pruning, PCA, and relatedness by IBD. The SeqArray format file has functions that perform: missing rates for variants, missing rates for samples, allele frequencies as well as PCA and inbreeding coefficients.</p>
</div>
</div>
</div>
<div id="regression-testing" class="section level1">
<h1>12 Regression testing</h1>
<p>To verify that the functions described above have worked correctly, we can compare their output files to those created by Mega2, itself, to verify that they are identical, as expected. This type of testing is known as regression testing.</p>
<div id="vcf-regression" class="section level2">
<h2>12.1 VCF regression</h2>
<p>If you have a executable copy of Mega2, you can run the code below using the MEGA2.BATCH.vcf file and provided example database.</p>
<p>Cut and paste the shell code and you should see similar results to what is presented here.</p>
<p>Otherwise, the text below is an illustration of what should happen. These lines use the C++ Mega2 program to populate the <em>vcf</em> directory with the same set of files that the were created in the <em>vcfr</em> directory.</p>
<p>At the Unix command prompt in the temporary directory with the name given by <code>where_mega2rtutorial_data()</code>, type:</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb186-1"><a href="#cb186-1"></a><span class="fu">mkdir</span> vcf</span>
<span id="cb186-2"><a href="#cb186-2"></a><span class="ex">mega2</span> MEGA2.BATCH.vcf</span></code></pre></div>
<p><strong>Note: To make this tutorial only dependent on R, the above code is not actually run. And the results, shown below, were captured from an environment where we had both R and the Mega2 executable available.</strong></p>
<p>The output should be similar to that below (except for time stamps):</p>
<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar, 
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill, 
##      and Daniel E. Weeks. 
## 
##      Last updated: Jun 13 2017, 09:36:42 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-7-24-10-05
## 
## Running Mega2 in batch mode from MEGA2.BATCH.vcf.
## Analysis option read in from batch file.
## Chromosome(s) and markers read in from batch file.
## Trait selection(s) read in from batch file.
## ==========================================================
## Analysis Class: VCF.
## Quantitative Output Missing Value     &quot;-9&quot;
## Affection    Output Missing Value     &quot;-9&quot;
## Reading SQLite3 DB from file &quot;seqsimr.db&quot;
## ===========================================================
## The path to this SQLite3 database is seqsimr.db.
## This database was created using Mega2 version 4.9.2.
## This database was created using   SQLite3 3.9.2 on 2017-7-24-10-03.
## This database was processed using SQLite3 3.9.2 on 2017-7-24-10-05.
## This database was created from PLINK PED format data using the following files:
##         Pedigree file   Mega2r.ped
##        PLINK Map file   Mega2r.map
## This database contains:
##  1380 persons (20 pedigrees)
##  1000 markers
##  1 trait
##  genetic distance(map name/type) &quot;Map&quot;/kosambi, Sex map type AVERAGED_MAP
##  base pair distance(map name) &quot;BP&quot;
## 
## ==========================================================
## 1 trait locus 
##       1 Affection status locus: 
##                 default
## ===========================================================
## Selected map Map.
## Selected chromosome 1
## Output will combine markers and the following selected traits:
##                 default [MARKERS]
## After selecting traits and covariates
## 1 trait locus 
##       1 Affection status locus: 
##                 default
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL       20     1380     620       760       1380000        0    1380000
## Typed       20     1380     620       760
## Untyped      0        0       0         0
## ===========================================================
## Mega2 created the following file(s) for VCF Format:
## VCF file created using allele ordering setting: Original_Order
##         VCF format file:        vcf/vcf.01.vcf
##         VCF pedigree file:      vcf/vcf.01.fam
##         VCF phenotype file:     vcf/vcf.01.phe
##         VCF map file:           vcf/vcf.01.map
##         VCF freq file:          vcf/vcf.01.freq
##         VCF pen file:           vcf/vcf.01.pen
## 
## SQLite3 database &quot;seqsimr.db&quot; was processed to generate this output.
## Output is in vcf
## ===========================================================
## See run summaries in directory 2017-7-24-10-05 
##    MEGA2.LOG, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/mega2rtutorial/vignettes/2017-7-24-10-05/MEGA2run.html
## in a web browser.
## ===========================================================
## If you use Mega2 as part of a published work, please reference 
##  Baron RV, Kollar C, Mukhopadhyay N, Weeks DE
##  Mega2: validated data-reformatting for linkage and association analyses
##  Source Code for Biology and Medicine.2014, 9:26
##  DOI: 10.1186/s13029-014-0026-y
## as well as the version used, which is currently Version 4.9.2
## ===========================================================</code></pre>
<p>The abbreviated MEGA2.BATCH.vcf file is below. (The initial comment section is not shown and important lines are shown in a bold typeface.) Notice that there are no INPUT FILES, just a database file.</p>
<blockquote>
<p>Input_Database_Mode=2<br />
Align_Strand_Input=no<br />
<strong>Output_Path=vcf</strong><br />
Input_Untyped_Ped_Option=2<br />
Input_Do_Error_Sim=no<br />
AlleleFreq_SquaredDev=999999999.000000<br />
<strong>Analysis_Option=VCF</strong><br />
Value_Missing_Quant_On_Output=-9<br />
Value_Missing_Affect_On_Output=-9<br />
<strong>DBfile_name=seqsimr.db</strong><br />
Chromosome_Single=1<br />
Traits_Combine=1 2 e<br />
<strong>file_name_stem=vcf</strong><br />
human_genome_build=B37<br />
VCF_output_file_type=1<br />
VCF_Allele_Order=Original_Order<br />
Default_Outfile_Names=yes</p>
</blockquote>
<p>You should compare the two directories: <em>vcf</em> and <em>vcfr</em>. Please add the -w flag to the diff command. This causes the comparison to ignore differences in white space. Lines that contain dates may be different between the two directories. At the Unix command prompt in the temporary directory, with the name given by <code>where_mega2rtutorial_data()</code>, type:</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb188-1"><a href="#cb188-1"></a><span class="fu">diff</span> -wrs vcf vcfr</span></code></pre></div>
<p><strong>Note: To make this tutorial only dependent on R, the above code is not actually run. And the results, shown below, were captured from an environment where we had both R and the Mega2 executable available.</strong></p>
<p>The <em>diff</em> should show:</p>
<pre><code>## Files vcf/vcf.01.fam and vcfr/vcf.01.fam are identical
## Files vcf/vcf.01.freq and vcfr/vcf.01.freq are identical
## Files vcf/vcf.01.map and vcfr/vcf.01.map are identical
## Files vcf/vcf.01.pen and vcfr/vcf.01.pen are identical
## Files vcf/vcf.01.phe and vcfr/vcf.01.phe are identical
## Files vcf/vcf.01.vcf and vcfr/vcf.01.vcf are identical</code></pre>
</div>
<div id="genabel-regression" class="section level2">
<h2>12.2 GenABEL regression</h2>
<p>This test is a bit more complicated. We intend to verify that the object generated by <code>Mega2GenABEL</code> is the same as a GenABEL object we started with. First, we load <code>GenABEL</code> and access its data: <strong>NOTE: The code in this section can not really be executed, if you do not have GenABEL available on your machine.</strong> But we have an old version of GenABEL and will show you in the example below what you should see.</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb190-1"><a href="#cb190-1"></a>GotGenABEL =<span class="st"> </span><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>, <span class="dt">quietly =</span> <span class="ot">FALSE</span>)</span>
<span id="cb190-2"><a href="#cb190-2"></a><span class="cf">if</span> (GotGenABEL) <span class="kw">data</span>(srdta) <span class="cf">else</span> srdta =<span class="st"> </span><span class="ot">NULL</span></span></code></pre></div>
<pre><code>The previous code does not display anything.</code></pre>
<p>Then we use the GenABEL export.plink() function to dump the GenABEL data as PLINK .ped/.map/.phe files. The latter will be processed by Mega2 to generate a database.</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb192-1"><a href="#cb192-1"></a>GotGenABEL =<span class="st"> </span><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>, <span class="dt">quietly =</span> <span class="ot">FALSE</span>)</span>
<span id="cb192-2"><a href="#cb192-2"></a></span>
<span id="cb192-3"><a href="#cb192-3"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb192-4"><a href="#cb192-4"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb192-5"><a href="#cb192-5"></a><span class="co"># above.</span></span>
<span id="cb192-6"><a href="#cb192-6"></a></span>
<span id="cb192-7"><a href="#cb192-7"></a>srdtafile =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;srdta&quot;</span>)</span>
<span id="cb192-8"><a href="#cb192-8"></a><span class="cf">if</span> (GotGenABEL) <span class="kw">export.plink</span>(srdta, <span class="dt">transpose =</span> <span class="ot">FALSE</span>, <span class="dt">filebasename =</span> srdtafile, </span>
<span id="cb192-9"><a href="#cb192-9"></a>    <span class="dt">phenotypes =</span> <span class="kw">names</span>(srdta<span class="op">@</span>phdata)[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)])</span></code></pre></div>
<p>The previous code does not display anything.</p>
<p>To produce the Mega2 database <code>srdta.db</code>, we switch to the Unix command line, cd to the temporary directory, with the name given by the results of this R command <code>where_mega2rtutorial_data()</code>, and run:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb193-1"><a href="#cb193-1"></a><span class="ex">mega2</span> MEGA2.BATCH.srdta</span></code></pre></div>
<p><strong>NOTE: To make this tutorial only dependent on R, the above code is not actually run. And its results, shown below, were captured from an environment where we had both R and the Mega2 executable available.</strong></p>
<pre><code>## ==========================================================
##                           MEGA2 4.9.2
##      Copyright 1999-2017, University of Pittsburgh. All Rights Reserved.
##      Contributors to Mega2: Robert Baron, Justin R. Stickel, Charles P. Kollar,
##      Nandita Mukhopadhyay, Lee Almasy, Mark Schroeder, William P. Mulvihill,
##      and Daniel E. Weeks.
## 
##      Last updated: Oct 13 2017, 09:55:04 , valid until June 15, 2018.
##      Compiled with gcc version 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)
## 
##      Mega2 comes with ABSOLUTELY NO WARRANTY.
##      See LICENSE.txt for terms of copying, modifying &amp; redistributing Mega2.
## ==========================================================
## NOTE: For humans, chromosome 23 codes for X, 24 codes for Y and 25 codes for XY.
## 
## Run date:                  2017-10-13-10-06
## 
## Running Mega2 in batch mode from MEGA2.BATCH.srdta.
## Input filenames and missing value indicator read in from batch file.
## Dump Analysis option read in from batch file.
## WARNING: Locus selections not specified in batch file.
## WARNING: Going to Reorder menu.
## WARNING: Trait selections not specified in batch file.
## WARNING: Going to Trait selection menu.
## ==========================================================
## Keyword Input_Locus_File not in batch file, Locus file assumed to be unspecified.
## Keyword Input_Map_File not in batch file, Map file assumed to be unspecified.
## Keyword Input_Omit_File not in batch file, Omit file assumed to be unspecified.
## Keyword Input_Frequency_File not in batch file, Frequency file assumed to be unspecified.
## Keyword Input_Penetrance_File not in batch file, Penetrance file assumed to be unspecified.
## Keyword Input_Aux_File not in batch file, Aux file assumed to be unspecified.
## Keyword Input_Imputed_Info_File not in batch file, Imputed Info file assumed to be unspecified.
## ===========================================================
## Analysis Class: Dump.
## Quantitative  Input Missing Value  -9 
## Affection     Input Missing Value     &quot;-9&quot;
## Quantitative Output Missing Value      &quot;*&quot;
## Affection    Output Missing Value      &quot;*&quot;
## Input Format: PLINK PED format (ped)
## Pedigree and map files specified as PLINK format.
## omit, penetrance, and frequency files are always in Mega2 format.
## Input files will be read in as PLINK or Mega2 format files as appropriate.
## reading phenotype file srdta.phe ... (5 columns)
## Reading PLINK map file for names: srdta.map
## Reading map file srdta.map ... (4 columns)
## Input Map name: Map, type: average genetic map, units: kosambi Morgans
## Input Map name: BP, type: physical map
## Found 2 possible maps in the srdta.map file.
## Now checking each record in map file srdta.map ...
## Done reading map file: srdta.map
## 
## ===========================================================
## Total number of loci =  839
## 6 trait loci 
##       2 Affection status loci: 
##                 bt default
##       4 Quantitative loci: 
##                 age qt1 qt2 qt3
##       833 Marker loci 
## Number of loci found per chromosome (chromosome:number)
##    1:833
## ===========================================================
## WARNING: No frequency file provided.
## WARNING: Allele frequencies for these will be estimated from data.
## Trait &#39;bt&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Trait &#39;default&#39; will be assigned the default penetrance: (0.0500 0.9000 0.9000)
## Reading PLINK .ped file: srdta.ped (1672 columns).
## 833 (of 833) markers to be included from srdta.map
## Reading pedigree information from srdta.ped
## 2500 individuals read from srdta.ped
## 2500 individuals with nonmissing phenotypes
## 0 cases, 0 controls, 2500 missing
## 1275 males, 1225 females, 0 of unspecified sex
## 0 founders, 2500 non-founders found
## ===========================================================
## Input pedigree data contains:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Pedigree exclusion option : Include all pedigrees whether typed or not.
## Count option: all alleles
## Count half-typed individuals&#39; alleles : no 
## ===========================================================
## Recoding pedigree genotypes ... 
## ===========================================================
## Pedigree data summary after recoding:
## Input pedigree file is in PLINK-fam format. 
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Created linkage ped tree
## 
## ===== Messages of type &quot;quant_stat&quot;: 
## ------------------------------------------------------------
## Per-pedigree quantitative phenotype summary:
## Pedigree     Mean      Std Dev     Minimum    Maximum  #Phenotypes
## ------------------------------------------------------------
## age
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1            43.40000    0.00000   43.40000   43.40000        1
## 2            48.20000    0.00000   48.20000   48.20000        1
## 3            37.90000    0.00000   37.90000   37.90000        1
## 4            53.80000    0.00000   53.80000   53.80000        1
## 5            47.50000    0.00000   47.50000   47.50000        1
## 6            45.00000    0.00000   45.00000   45.00000        1
## 7            52.00000    0.00000   52.00000   52.00000        1
## 8            42.50000    0.00000   42.50000   42.50000        1
## 9            29.70000    0.00000   29.70000   29.70000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt1
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1            -0.58000    0.00000   -0.58000   -0.58000        1
## 2             0.80000    0.00000    0.80000    0.80000        1
## 3            -0.52000    0.00000   -0.52000   -0.52000        1
## 4            -1.55000    0.00000   -1.55000   -1.55000        1
## 5             0.25000    0.00000    0.25000    0.25000        1
## 6             0.15000    0.00000    0.15000    0.15000        1
## 7            -0.56000    0.00000   -0.56000   -0.56000        1
## 8             0.00000    0.00000    0.00000    0.00000        0
## 9            -2.26000    0.00000   -2.26000   -2.26000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt2
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1             4.46000    0.00000    4.46000    4.46000        1
## 2             6.32000    0.00000    6.32000    6.32000        1
## 3             3.26000    0.00000    3.26000    3.26000        1
## 4           888.00000    0.00000  888.00000  888.00000        1
## 5             5.70000    0.00000    5.70000    5.70000        1
## 6             4.65000    0.00000    4.65000    4.65000        1
## 7             4.64000    0.00000    4.64000    4.64000        1
## 8             5.77000    0.00000    5.77000    5.77000        1
## 9             0.71000    0.00000    0.71000    0.71000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## qt3
## ------------------------------------------------------------
## ------------------------------------------------------------
## 1             1.43000    0.00000    1.43000    1.43000        1
## 2             3.90000    0.00000    3.90000    3.90000        1
## 3             5.05000    0.00000    5.05000    5.05000        1
## 4             3.76000    0.00000    3.76000    3.76000        1
## 5             2.89000    0.00000    2.89000    2.89000        1
## 6             1.87000    0.00000    1.87000    1.87000        1
## 7             2.49000    0.00000    2.49000    2.49000        1
## 8             2.68000    0.00000    2.68000    2.68000        1
## 9             1.45000    0.00000    1.45000    1.45000        1
## ===== Too many &quot;quant_stat&quot; records, display is temporarily suspended ..
## ===== 2501 total records of type &quot;quant_stat&quot; are in MEGA2.LOG
## 
## 
## ===== Messages of type &quot;quant_stat_sum&quot;: 
##                Quantitative trait phenotype statistics
## -------------------------------------------------------------------------------
## QTL            Missing  Minimum   Maximum   Total      Pedigrees    Total
##                                             pedigrees  phenotyped   phenotypes
## -------------------------------------------------------------------------------
## age                  0   24.100    71.600        2500        2500         2500
## qt1                  3   -4.600     3.200        2500        2497         2497
## qt2                  0    0.000   888.000        2500        2500         2500
## qt3                 11   -1.970     6.340        2500        2489         2489
## NOTE: The Missing QTL value on input has been assigned as &#39;-9.00&#39;.
## -------------------------------------------------------------------------
## QTL                 Mean   Std Dev  Skewness  Kurtosis
## -------------------------------------------------------------------------
## age               50.038     7.060     0.003    -0.063
## qt1               -0.298     1.001    -0.075     0.126
## qt2                6.122    30.601    28.734   825.077
## qt3                2.609     1.101     0.033    -0.090
## ===========================================================
## ===== 4 total records of type &quot;quant_stat_sum&quot; are in MEGA2.LOG
## 
## Done checking locus integrity.
## Checking pedigree integrity...
## Done checking pedigree integrity.
## ==========================================================
## ===========================================================
## Pedigree statistics after selecting chromosomes and marker loci:
## Input pedigree file is in post-makeped format.
##                                                   Marker Genotypes
##                                                   Fully    Half
##      Pedigrees   People   Males   Females         Typed    Typed     Total
## TOTAL     2500     2500    1275      1225       1978958        0    2082500
## Typed     2500     2500    1275      1225
## Untyped      0        0       0         0
## ===========================================================
## Database file &quot;srdta.db&quot; will be backed up.
## Moved existing srdta.db to srdta.db.old
## Dumping SQLite3 DB to file &quot;srdta.db&quot;
## ===========================================================
## See run summaries in directory 2017-10-13-10-06 
##    MEGA2.LOG, MEGA2.RECODE, MEGA2.ERR, MEGA2.KEYS
## The script &#39;mega2log2html.pl&#39; exited normally.
## To view the HTML-formatted run summaries, open
## /Users/rbaron/mega2/bb/srcdir/R/2017-10-13-10-06/MEGA2run.html
## in a web browser.
## ===========================================================</code></pre>
<div id="the-mega2.batch.srdata-file" class="section level3">
<h3>The MEGA2.BATCH.srdata file</h3>
<p>The abbreviated MEGA2.BATCH.srdta file is below. (The initial comment section is not shown and important lines are shown in a bold typeface.)</p>
<blockquote>
<p><strong>Input_Database_Mode=1</strong><br />
<strong>Input_Format_Type=4</strong><br />
<strong>Input_Pedigree_File=srdta.ped</strong><br />
<strong>Input_PLINK_Map_File=srdta.map</strong><br />
<strong>Input_Phenotype_File=srdta.phe</strong><br />
Output_Path=.<br />
Input_Path=.<br />
PLINK_Args= –missing-phenotype -9 –trait default<br />
Input_Untyped_Ped_Option=2<br />
Input_Do_Error_Sim=no<br />
AlleleFreq_SquaredDev=999999999.000000<br />
Value_Marker_Compression=1<br />
<strong>Analysis_Option=Dump</strong><br />
Value_Missing_Quant_On_Input=-9.000000<br />
Value_Missing_Affect_On_Input=-9<br />
Count_Genotypes=4<br />
Count_Halftyped=no<br />
Value_Genetic_Distance_Index=0<br />
Value_Genetic_Distance_SexTypeMap=0<br />
Value_Base_Pair_Position_Index=1<br />
Default_Reset_Invalid=no<br />
<strong>DBfile_name=srdta.db</strong><br />
Default_Outfile_Names=yes</p>
</blockquote>
<p>Note: We have provided a copy of the srdta.db database in the Mega2R package. So you can proceed with the steps that follow, even if you did not create your own database.</p>
<p>Now, we go back into R and run Mega2GenABEL(). If you type:</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb195-1"><a href="#cb195-1"></a>GotGenABEL =<span class="st"> </span><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>, <span class="dt">quietly =</span> <span class="ot">FALSE</span>)</span>
<span id="cb195-2"><a href="#cb195-2"></a><span class="co"># Before issuing the next command, make sure you have issued this command</span></span>
<span id="cb195-3"><a href="#cb195-3"></a><span class="co"># `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section</span></span>
<span id="cb195-4"><a href="#cb195-4"></a><span class="co"># above.</span></span>
<span id="cb195-5"><a href="#cb195-5"></a>sdb =<span class="st"> </span><span class="kw">file.path</span>(<span class="kw">where_mega2rtutorial_data</span>(), <span class="st">&quot;srdta.db&quot;</span>)</span>
<span id="cb195-6"><a href="#cb195-6"></a>ENV =<span class="st"> </span><span class="kw">read.Mega2DB</span>(sdb)</span>
<span id="cb195-7"><a href="#cb195-7"></a></span>
<span id="cb195-8"><a href="#cb195-8"></a>mega =<span class="st"> </span><span class="kw">Mega2GenABEL</span>()</span></code></pre></div>
<p>You will see:</p>
<pre><code>GotGenABEL = require(&quot;GenABEL&quot;, quietly = FALSE)

# Before issuing the next command, make sure you have issued this command
# `dump_mega2rtutorial_data()` first as instructed in the &#39;Tutorial Data&#39; section
# above.

sdb = file.path(where_mega2rtutorial_data(), &quot;srdta.db&quot;)
ENV = read.Mega2DB(sdb)

mega = Mega2GenABEL()

## Reading individual ids from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tfam&#39; ...
## ... done.  Read 2500 individual ids from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tfam&#39;
## Reading genotypes from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tped&#39; ...
## ...done.  Read 833 SNPs from file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABEL.tped&#39;
## Writing to file &#39;/var/folders/kn/h793jrls0n39bdym6d7531qr0000gp/T//RtmpNtrIhU/Mega2GenABELtped.raw&#39; ...
## ... done.
## ids loaded...
## marker names loaded...
## chromosome data loaded...
## map data loaded...
## allele coding data loaded...
## strand data loaded...
## genotype data loaded...
## snp.data object created...
## assignment of gwaa.data object FORCED; X-errors were not checked!</code></pre>
<p><strong>NOTE: The code below will check if you have GenABEL available on your machine, if it is not available the code in this section can not really be executed. But, we will show you the expected results.</strong></p>
<p><code>mega</code> should be the same as the <code>srdta</code> gwaa.data-class object. You can compare them however you prefer. For example, in R, if you type:</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="#cb197-1"></a>GotGenABEL =<span class="st"> </span><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>, <span class="dt">quietly =</span> <span class="ot">FALSE</span>)</span>
<span id="cb197-2"><a href="#cb197-2"></a><span class="kw">str</span>(mega)</span>
<span id="cb197-3"><a href="#cb197-3"></a><span class="cf">if</span> (GotGenABEL) <span class="kw">str</span>(srdta)</span></code></pre></div>
<p>You will see:</p>
<pre><code>GotGenABEL = require(&quot;GenABEL&quot;, quietly=FALSE)
str(mega)

## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   2500 obs. of  8 variables:
##   .. ..$ id     : chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. ..$ sex    : int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. ..$ age    : num [1:2500] 43.4 48.2 37.9 53.8 47.5 45 52 42.5 29.7 45.8 ...
##   .. ..$ qt1    : num [1:2500] -0.58 0.8 -0.52 -1.55 0.25 0.15 -0.56 -9 -2.26 -1.32 ...
##   .. ..$ qt2    : num [1:2500] 4.46 6.32 3.26 888 5.7 4.65 4.64 5.77 0.71 3.26 ...
##   .. ..$ qt3    : num [1:2500] 1.43 3.9 5.05 3.76 2.89 1.87 2.49 2.68 1.45 0.85 ...
##   .. ..$ bt     : int [1:2500] 0 1 1 1 1 0 0 1 0 0 ...
##   .. ..$ default: int [1:2500] 0 0 0 0 0 0 0 0 0 0 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 625
##   .. .. ..@ nids      : int 2500
##   .. .. ..@ nsnps     : int 833
##   .. .. ..@ idnames   : chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. .. ..@ snpnames  : chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ map       : Named num [1:833] 2500 3500 5750 13500 14250 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 08 0b 0c 07 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 00 00 00 00 ...
##   .. .. ..@ male      : Named int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2500] &quot;1_p1&quot; &quot;2_p2&quot; &quot;3_p3&quot; &quot;4_p4&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:625, 1:833] 55 59 55 a5 ...


if (GotGenABEL) str(srdta)


## Formal class &#39;gwaa.data&#39; [package &quot;GenABEL&quot;] with 2 slots
##   ..@ phdata:&#39;data.frame&#39;:   2500 obs. of  7 variables:
##   .. ..$ id : chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. ..$ sex: int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. ..$ age: num [1:2500] 43.4 48.2 37.9 53.8 47.5 45 52 42.5 29.7 45.8 ...
##   .. ..$ qt1: num [1:2500] -0.58 0.8 -0.52 -1.55 0.25 0.15 -0.56 NA -2.26 -1.32 ...
##   .. ..$ qt2: num [1:2500] 4.46 6.32 3.26 888 5.7 4.65 4.64 5.77 0.71 3.26 ...
##   .. ..$ qt3: num [1:2500] 1.43 3.9 5.05 3.76 2.89 1.87 2.49 2.68 1.45 0.85 ...
##   .. ..$ bt : int [1:2500] 0 1 1 1 1 0 0 1 0 0 ...
##   ..@ gtdata:Formal class &#39;snp.data&#39; [package &quot;GenABEL&quot;] with 11 slots
##   .. .. ..@ nbytes    : num 625
##   .. .. ..@ nids      : int 2500
##   .. .. ..@ nsnps     : int 833
##   .. .. ..@ idnames   : chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. .. ..@ snpnames  : chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ chromosome: Factor w/ 1 level &quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ map       : Named num [1:833] 2500 3500 5750 13500 14250 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:833] &quot;rs10&quot; &quot;rs18&quot; &quot;rs29&quot; &quot;rs65&quot; ...
##   .. .. ..@ coding    :Formal class &#39;snp.coding&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 08 0b 0c 03 ...
##   .. .. ..@ strand    :Formal class &#39;snp.strand&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:833] 01 01 02 01 ...
##   .. .. ..@ male      : Named int [1:2500] 1 1 0 1 1 0 0 1 0 0 ...
##   .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2500] &quot;p1&quot; &quot;p2&quot; &quot;p3&quot; &quot;p4&quot; ...
##   .. .. ..@ gtps      :Formal class &#39;snp.mx&#39; [package &quot;GenABEL&quot;] with 1 slot
##   .. .. .. .. ..@ .Data: raw [1:625, 1:833] 55 59 55 a5 ...</code></pre>
<p>You can compare these printouts by eye. Alternatively, the function <em>Mega2GenABELtst()</em> can be used to compare the phenotype data, genotype data, and object metadata, item by item. If you type:</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb199-1"><a href="#cb199-1"></a>GotGenABEL =<span class="st"> </span><span class="kw">require</span>(<span class="st">&quot;GenABEL&quot;</span>, <span class="dt">quietly =</span> <span class="ot">FALSE</span>)</span>
<span id="cb199-2"><a href="#cb199-2"></a><span class="kw">options</span>(<span class="dt">max.print =</span> <span class="dv">30</span>)</span>
<span id="cb199-3"><a href="#cb199-3"></a><span class="kw">Mega2GenABELtst</span>(<span class="dt">mega_ =</span> mega, <span class="dt">gwaa_ =</span> srdta)</span></code></pre></div>
<p>You will see:</p>
<pre><code>GotGenABEL = require(&quot;GenABEL&quot;, quietly = FALSE)
options(max.print = 30)
Mega2GenABELtst(mega_ = mega, gwaa_ = srdta)

## all(mega_@phdata$sex == gwaa_@phdata$sex) [1] TRUE
## all(mega_@phdata$age == gwaa_@phdata$age) [1] TRUE
## all(mega_@phdata$qt1 == gwaa_@phdata$qt1) [1] TRUE
## all(mega_@phdata$qt2 == gwaa_@phdata$qt2) [1] TRUE
## all(mega_@phdata$qt3 == gwaa_@phdata$qt3) [1] TRUE
## all(mega_@phdata$bt == gwaa_@phdata$bt) [1] TRUE
## all(mega_@gtdata@nids == gwaa_@gtdata@nids)[1] TRUE
## all(mega_@gtdata@nsnps == gwaa_@gtdata@nsnps)[1] TRUE
## all(mega_@gtdata@nbytes == gwaa_@gtdata@nbytes)[1] TRUE
## all(mega_@gtdata@idnames == gwaa_@gtdata@idnames)[1] FALSE
## all(mega_@gtdata@snpnames == gwaa_@gtdata@snpnames)[1] TRUE
## all(mega_@gtdata@chromosome == gwaa_@gtdata@chromosome)[1] TRUE
## all(mega_@gtdata@map == gwaa_@gtdata@map)[1] TRUE
## all(mega_@gtdata@male == gwaa_@gtdata@male)[1] TRUE
## all(mega_@gtdata@coding == gwaa_@gtdata@coding)[1] FALSE
## all(mega_@gtdata@strand == gwaa_@gtdata@strand)[1] FALSE
## all(mega_@gtdata@gtps == gwaa_@gtdata@gtps)[1] FALSE
## all(mega_@gtdata == gwaa_@gtdata)[1] TRUE
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [1] &quot;markers that differ&quot;
## [1] &quot;markers that differ&quot;
##     locus_link locus_link_fill MarkerName chromosome position
## 4            9               9       rs65          1    13500
## 8           13              13      rs130          1    27250
## 10          15              15      rs150          1    33250
## 20          25              25      rs324          1    82500
## 23          28              28      rs348          1    88000
## 24          29              29      rs361          1    90000
##  [ reached getOption(&quot;max.print&quot;) -- omitted 209 rows ]
## [1] &quot;allele values for markers that differ&quot;
## [1] &quot;allele values for markers that differ&quot;
##     locus_link pId.x AlleleName.x Frequency.x indexX.x pId.y AlleleName.y
## 4            9    19            A  0.28027754        1    20            T
## 8           13    27            A  0.30622110        1    28            G
## 10          15    31            A  0.65998312        1    32            C
##     Frequency.y indexX.y
## 4    0.71972246        2
## 8    0.69377890        2
## 10   0.34001688        2
##  [ reached getOption(&quot;max.print&quot;) -- omitted 212 rows ]</code></pre>
<p>**NOTE These results are somewhat disappointing. But …</p>
<p>First, “mega2” prefers to use the pedigree id concatenated to the person id as the sample name, even if the person id itself is unique.</p>
<p>The second difference in <strong>gtdata@strand</strong> occurs because Mega2 does not keep track of strand orientation and always returns 0.</p>
<p>The final difference is more subtle. The <strong>gtdata</strong> comparison line decodes the genotype to characters then normalizes the two heterozygous cases to one value. These results are the same for the two different gwaa.class-objects; hence the data are really the same. But <code>Mega2GenABEL</code> converts the data frames using the <code>convert.snp.tped</code> function while the <code>srdta</code> object, generated by GenABEL, uses the <code>convert.snp.text</code>. Though both functions encode the genotype to a number, the <code>convert.snp.tped</code> function rearranges the genotype so that the major allele appears first, the <code>convert.snp.text</code> does no such rearrangement. Because <strong>gtdata@coding</strong> and <strong>gtdata@gtps</strong> compare the encoded allele pairs and corresponding encoded genotypes, they sometimes differ.</p>
</div>
</div>
<div id="seqarray-regression" class="section level2">
<h2>12.3 SeqArray regression</h2>
<p>Rather than spell out all the details, this time we will only sketch how to match the SeqArray/SNPArray files calculated by R library APIs and converted from a Mega2R database.</p>
<p>First, you will need to find a suitable VCF file. (As stated earlier, it would be preferable if the genotype data were without haplotypes and if the markers were bi-alleleic.) Section <strong>11.1</strong> explains how to convert a VCF file to a Mega2 database. Earlier, in Section <strong>10.2/10.2.1</strong> and <strong>10.2/10.2.2</strong>, we showed how to convert the Mega2 database to SeqArray format and SnpArray format, respectively.</p>
<p>Next, the <code>SeqArray</code> library contains a function, <code>seqVCF2SEQ()</code>, that converts a VCF file to a SeqArray. In addition, <code>SeqArray</code> contains another function, <code>seqSEQ2SNP()</code>, that converts a CoreArray file in SeqArray format to SNPArray format.</p>
<p>Our goal is to compare the underlying data calculated in the above two paragraphs. Let us illustrate with the SNPArray data. The Mega2R calculation gives you an open <code>gdsfmt</code> file descriptor. If you <code>print</code> the descriptor, it will show all the CoreArray variables; one of which is ‘sample.id’. The native calculation uses <code>seqVCF2SEQ()</code> and then <code>seqSEQ2SNP()</code> to produce SNPArray data in a gdsfmt file. Open this gdsfmt file using <code>openfn.gds(&lt;file name&gt;)</code>, and then proceed to print the gds object and look at its variables. To compare both versions of ‘sample.id’s, use the low level gdsfmt primitives, ’read.gsdn’, and ‘index.gdsn’ as in:</p>
<pre><code>        all(read.gdsn(index.gdsn(&lt;file name open descriptor&gt;, &#39;sample.id&#39;)) ==
            read.gdsn(index.gdsn(Mega2Rgdsfmt descriptor&gt;, &#39;sample.id&#39;)) )</code></pre>
<p>The above test should be applied to all the variables in the gds object hierarchy. Further, a similar test can be applied to the gds variables of a SeqArray, using the SeqArray variable hierarchy rather than those of the SNPArray.</p>
</div>
</div>
<div id="next-steps" class="section level1">
<h1>13 Next steps</h1>
<p>If you are left with questions as to how you can use Mega2R for your own research, you can:</p>
<ol style="list-style-type: decimal">
<li><p>Read our paper “The Mega2R R package: tools for accessing and processing common genetic data formats in R” (in preparation), which extends this document by providing implementation details.</p></li>
<li><p>Read the source of the various functions if you understand R; the code is not particularly subtle.</p></li>
<li><p>Write to the Mega2 discussion group: <a href="https://groups.google.com/forum/#!forum/mega2-users" class="uri">https://groups.google.com/forum/#!forum/mega2-users</a></p></li>
</ol>
</div>
<div id="acknowlegements" class="section level1">
<h1>14 Acknowlegements</h1>
<p>The Mega2 C++ program and this Mega2R R package are both open source and are freely available, along with extensive documentation, from our <a href="https://watson.hgen.pitt.edu/register/" class="uri">https://watson.hgen.pitt.edu/register/</a> web site. This work was supported by NIH grant R01 GM076667 (PI: Weeks).</p>
</div>
<div id="references" class="section level1">
<h1>15 References</h1>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Schaid DJ, McDonnell SK., Sinnwell JP, Thibodeau SN. (2013) Multiple Genetic Variant Association Testing by Collapsing and Kernel Methods With Pedigree or Population Structured Data, Genet Epidemiol, 37(5):409-18.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Lee, S., Emond, M.J., Bamshad, M.J., Barnes, K.C., Rieder, M.J., Nickerson, D.A., NHLBI GO Exome Sequencing Project-ESP Lung Project Team, Christiani, D.C., Wurfel, M.M. and Lin, X. (2012) Optimal unified approach for rare variant association testing with application to small sample case-control whole-exome sequencing studies. American Journal of Human Genetics, 91, 224-237.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Mohamad Saad1 and Ellen M. Wijsman1, Combining family- and population-based imputation data for association analysis of rare and common variants in large pedigrees. Genet Epidemiol. 2014 Nov; 38(7): 579–590., doi: 10.1002/gepi.21844<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Aulchenko Y.S., Ripke S., Isaacs A., van Duijn C.M. GenABEL: an R package for genome-wide association analysis. Bioinformatics. 2007 23(10):1294-6.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Zheng, Xiuwen, David Levine, Jess Shen, Stephanie M. Gogarten, Cathy Laurie, and Bruce S. Weir. 2012. “A High-Performance Computing Toolset for Relatedness and Principal Component Analysis of Snp Data.” Bioinformatics (Oxford, England) 28 (24):3326–8. <a href="https://doi.org/10.1093/bioinformatics/bts606" class="uri">https://doi.org/10.1093/bioinformatics/bts606</a>.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p><a href="https://sourceforge.net" class="uri">https://sourceforge.net</a><a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>Gentleman, Robert C., Vincent J. Carey, Douglas M. Bates, Ben Bolstad, Marcel Dettling, Sandrine Dudoit, Byron Ellis, et al. 2004. “Bioconductor: Open Software Development for Computational Biology and Bioinformatics.” Genome Biology 5 (10):1–16. <a href="https://doi.org/10.1186/gb-2004-5-10-r80" class="uri">https://doi.org/10.1186/gb-2004-5-10-r80</a>.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>R Core Team. 2016. “R: A Language and Environment for Statistical Computing.”<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
