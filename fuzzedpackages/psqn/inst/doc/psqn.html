<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>psqn: Partially Separable Quasi-Newton</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">psqn: Partially Separable Quasi-Newton</h1>



<style>
img {
    border: none;
}
</style>
<p><span class="math display">\[\renewcommand\vec{\boldsymbol}   \def\bigO#1{\mathcal{O}(#1)}   \def\Cond#1#2{\left(#1\,\middle|\, #2\right)}   \def\mat#1{\boldsymbol{#1}}   \def\der{{\mathop{}\!\mathrm{d}}}   \def\argmax{\text{arg}\,\text{max}}  \def\Prob{\text{P}}  \def\diag{\text{diag}}   \def\argmin{\text{arg}\,\text{min}}   \def\Expe{\text{E}}\]</span></p>
<p>This package provides an optimization method for <em>partially separable</em> functions. Partially separable functions are of the following form:</p>
<p><span class="math display">\[f(\vec x) = \sum_{i = 1}^n f_i(\vec x_{\mathcal I_i})\]</span></p>
<p>where <span class="math inline">\(\vec x\in \mathbb R^l\)</span>,</p>
<p><span class="math display">\[\vec x_{\mathcal I_i} =    (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top)\vec x, \qquad    \mathcal I_i = (j_{i1}, \dots, \mathcal j_{im_i}) \subseteq    \{1, \dots, l\}^l,\]</span> and <span class="math inline">\(\vec e_k\)</span> is the <span class="math inline">\(k\)</span>’th column of the <span class="math inline">\(l\)</span> dimensional identity matrix. Each function <span class="math inline">\(f_i\)</span> is called an <em>element function</em> and only depends on <span class="math inline">\(m_i \ll l\)</span> parameters. This allows for an efficient quasi-Newton method when all the <span class="math inline">\(m_i\)</span>’s are much smaller than the dimension of the parameter vector <span class="math inline">\(\vec x\)</span>, <span class="math inline">\(l\)</span>. The framework can be extended to allow for a linear combination of parameters but we do not cover such problems. This vignette closely follows <span class="citation">Nocedal and Wright (2006)</span> who cover the methods and alternatives in much greater detail.</p>
<p>We only consider a more restricted form of the problem. Assume that each index set <span class="math inline">\(\mathcal I_i\)</span> is of the form:</p>
<p><span class="math display">\[\begin{align*}   \mathcal I_i &amp;= \{1,\dots, p\} \cup \mathcal J_i \\   \mathcal J_i \cap \mathcal J_j &amp;= \emptyset \qquad j\neq i \\   \mathcal J_i \cap \{1,\dots, p\} &amp;= \emptyset \qquad \forall i = 1,\dots, n   \end{align*}.\]</span></p>
<p>That is, each index set contains <span class="math inline">\(p\)</span> <em>global parameters</em> and <span class="math inline">\(q_i = \lvert\mathcal J_i\rvert\)</span> <em>private parameters</em> which are particular for each element function, <span class="math inline">\(f_i\)</span>. For implementation reason, we let:</p>
<p><span class="math display">\[\begin{align*}   \overleftarrow q_i &amp;=    \begin{cases} p &amp; i = 0 \\ p + \sum_{k = 1}^i q_k &amp; i &gt; 0 \end{cases} \\   \mathcal J_i &amp;=    \{1 + \overleftarrow q_{i - 1}, \dots , q_i + \overleftarrow q_{i - 1}\}   \end{align*}\]</span></p>
<p>such that the element functions’ private parameters lies in consecutive parts of <span class="math inline">\(\vec x\)</span>.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<p>We are going to consider a Taylor approximation for a generalized linear mixed model. In particular, we focus on a mixed logit regression where:</p>
<p><span class="math display">\[\begin{align*}   \vec U_i &amp;\sim N^{(r)}(\vec 0, \mat\Sigma) \\   \vec\eta_i &amp;= \mat X_i\vec\beta + \mat Z_i\vec U_i \\   Y_{ij} &amp;\sim \text{Bin}(\text{logit}^{-1}(\eta_{ij}), 1),    \qquad j = 1, \dots, t_i   \end{align*}\]</span></p>
<p>where <span class="math inline">\(N^{(r)}(\vec\mu,\mat\Sigma)\)</span> means a <span class="math inline">\(r\)</span>-dimensional a multivariate normal distribution with mean <span class="math inline">\(\vec\mu\)</span> and covariance matrix <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\text{Bin}(p, k)\)</span> means a binomial distribution probability <span class="math inline">\(p\)</span> and size <span class="math inline">\(k\)</span>. <span class="math inline">\(\vec U_i\)</span> is an unknown random effect with an unknown covariance <span class="math inline">\(\mat\Sigma\)</span> and <span class="math inline">\(\vec\beta\in\mathbb{R}^p\)</span> are unknown fixed effect coefficients. <span class="math inline">\(\mat X_i\)</span> and <span class="math inline">\(\mat Z_i\)</span> are known design matrices each with <span class="math inline">\(t_i\)</span> rows for each of the <span class="math inline">\(t_i\)</span> observed outcomes, the <span class="math inline">\(y_{ij}\)</span>s.</p>
<p>As part of a Taylor approximation, we find a mode of <span class="math inline">\(\vec x = (\vec\beta^\top, \widehat{\vec u}_1^\top, \dots, \widehat{\vec u}_n^\top)\)</span> of the log of the integrand given a covariance matrix estimate, <span class="math inline">\(\widehat{\mat \Sigma}\)</span>. That is, we are minimizing:</p>
<p><span class="math display">\[\begin{align*}   f(\vec x) &amp;= -\sum_{i = 1}^n \left(     \sum_{k = 1}^{t_i}(y_{ij}\eta_{ij} - \log(1 + \exp\eta_{ij}))     - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= -\sum_{i = 1}^n \left(     \vec y_i(\mat X_i\vec\beta + \mat Z_i\widehat{\vec u}_i)     - \sum_{k = 1}^{t_i}     \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\widehat{\vec u}_i))   - \frac 12 \widehat{\vec u}_i^\top\widehat{\mat \Sigma}^{-1} \widehat{\vec u}_i     \right) \\   &amp;= \sum_{i = 1}^nf_i((\vec\beta^\top, \widehat{\vec u}_i^\top)^\top) \\   f_i((\vec\beta^\top, \vec u^\top)^\top) &amp;=    -\vec y_i(\mat X_i\vec\beta + \mat Z_i\vec u)     + \sum_{k = 1}^{t_i}   \log(1 + \exp(\vec x_{ik}^\top\vec\beta + \vec z_{ik}^\top\vec u))   + \frac 12 \vec u^\top\widehat{\mat \Sigma}^{-1} \vec u   \end{align*}\]</span></p>
<p>In this problem, <span class="math inline">\(\vec\beta\)</span> are the global parameters and the <span class="math inline">\(\widehat{\vec u}_i\)</span>’s are the private parameters. Thus, <span class="math inline">\(l = p + nr\)</span>. We will later return to this example with an implementation which uses this package.</p>
<div id="variational-approximations" class="section level3">
<h3>Variational Approximations</h3>
<p>The objective function for variational approximations for mixed models for clustered data is commonly also partially separable. We will briefly summarize the idea here. <span class="citation">Ormerod and Wand (2012)</span> and <span class="citation">Ormerod (2011)</span> are examples where one might benefit from using the methods in this package.</p>
<p>We let <span class="math inline">\(\tilde f_i\)</span> be the log marginal likelihood term from cluster <span class="math inline">\(i\)</span>. This is of the form:</p>
<p><span class="math display">\[
\tilde f_i(\vec\omega) = \log \int p_i(\vec y_i, \vec u;\vec\omega)\der \vec u 
\]</span></p>
<p>where <span class="math inline">\(\vec\omega\)</span> are unknown model parameters, <span class="math inline">\(p_i(\vec u;\vec\omega)\)</span> is the joint density of the observed data denoted by <span class="math inline">\(\vec y_i\)</span>, and <span class="math inline">\(\vec U_i\)</span> which is a cluster specific random effect. <span class="math inline">\(\exp \tilde f_i(\vec\omega)\)</span> is often intractable. An approximation of <span class="math inline">\(\tilde f_i\)</span> is to select some variational distribution denoted by <span class="math inline">\(v_i\)</span> parameterized by some set <span class="math inline">\(\Theta_i\)</span>. We then use the approximation:</p>
<p><span class="math display">\[
\begin{align*}
\tilde f_i(\vec\omega) &amp;= \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i \vec u;\vec\omega)/v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u_i \mid \vec y_i;\vec\omega)/v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u \\
  &amp;= 
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u
  + \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)}
  \right)\der\vec u \\
&amp;\geq
  \int v_i(\vec u; \vec\theta_i)
  \log\left(
  \frac{p_i(\vec y_i, \vec u;\vec\omega)}
       {v_i(\vec u; \vec\theta_i)}
  \right)\der\vec u = f_i(\vec\omega,\vec\theta_i)
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span> and <span class="math inline">\(p_i(\vec u_i \mid \vec y_i;\vec\omega)\)</span> is the conditional density of the random effect given the observed data, <span class="math inline">\(\vec y_i\)</span>, and model parameters, <span class="math inline">\(\vec\omega\)</span>. <span class="math inline">\(f_i(\vec\omega,\vec\theta_i)\)</span> is a lower bound since the Kullback–Leibler divergence</p>
<p><span class="math display">\[
\int v_i(\vec u; \vec\theta_i)\log\left(
  \frac{v_i(\vec u; \vec\theta_i)}
       {p_i(\vec u \mid \vec y_i;\vec\omega)} 
  \right)\der\vec u
\]</span></p>
<p>is positive. The idea is to replace the minimization problem:</p>
<p><span class="math display">\[
\argmin_{\vec\omega} -\sum_{i = 1}^n \tilde f_i(\vec\omega)
\]</span></p>
<p>with a variational approximation:</p>
<p><span class="math display">\[
\argmin_{\vec\omega,\vec\theta_1,\dots,\vec\theta_n} 
  -\sum_{i = 1}^n f_i(\vec\omega,\vec\theta_i)
\]</span></p>
<p>This problem fits into the framework in the package where <span class="math inline">\(\vec\omega\)</span> are the global parameters and the <span class="math inline">\(\vec\theta_i\)</span>s are the private parameters.</p>
<p>Variational approximation have the property that if <span class="math inline">\(v_i(\vec u; \vec\theta_i) = p_i(\vec u \mid \vec y_i;\vec\omega)\)</span> then the Kullback–Leibler divergence is zero and the lower bound is equal to the log marginal likelihood. Thus, we need to use a family of variational distributions, <span class="math inline">\(v_i\)</span>, which yields a close approximation of the conditional density of the random effects, <span class="math inline">\(p_i(\vec u \mid \vec y_i;\vec\omega)\)</span>, for some <span class="math inline">\(\vec\theta_i\in\Theta_i\)</span>. Moreover, the lower bound also needs to be easy to optimize. Variational approximations have an advantage that given estimates of <span class="math inline">\(\widehat{\vec\omega},\widehat{\vec\theta}_1,\dots,\widehat{\vec\theta}_n\)</span> then subsequent inference can be approximated using:</p>
<p><span class="math display">\[
\Expe\left(h(\vec U_i)\right) =
  \int h(\vec u) p_i(\vec u \mid \vec y_i;\vec\omega)\der\vec u 
  \approx 
  \int h(\vec u) v_i(\vec u; \widehat{\vec\theta}_i)\der\vec u.
\]</span></p>
<p>The latter integral may be much easier to work with for some functions <span class="math inline">\(h\)</span> and variational distribution, <span class="math inline">\(v_i\)</span>.</p>
</div>
</div>
<div id="quasi-newton-method-for-partially-separable-functions" class="section level2">
<h2>Quasi-Newton Method for Partially Separable Functions</h2>
<p>We are going to assume some prior knowledge of Newton’s method and the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm and we only provide a few details of these methods. However, will need a bit of notations from these methods to motivate the quasi-Newton method we have implemented.</p>
<p>Newton’s method to minimize a function is to start at some value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 1\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\nabla^2 f(\vec x_{k - 1})\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \vec p_k\)</span> or <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \gamma\vec p_k\)</span> for <span class="math inline">\(\gamma \in (0, 1]\)</span> set to satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>, and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>Computing the Hessian, <span class="math inline">\(\nabla^2 f(\vec x_{k - 1})\)</span>, at every iteration can be expensive. The BFGS algorithm offers an alternative where we use an approximation instead. Here we start with some Hessian approximation <span class="math inline">\(\mat B_0\)</span> and</p>
<ol style="list-style-type: decimal">
<li>compute a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>find a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>set <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>, <span class="math inline">\(\vec s_k = \alpha\vec p_k = \vec x_k - \vec x_{k - 1}\)</span>, <span class="math inline">\(\vec d_k = \nabla f(\vec x_k) - \nabla f(\vec x_{k - 1})\)</span>,</li>
<li>perform a rank-two update <span class="math display">\[\mat B_k = \mat B_{k - 1} + \frac{\vec y_k\vec y_k^\top}{\vec y_k^\top\vec s_k} - \frac{\mat B_{k - 1}\vec s_k\vec s_k^\top\mat B_{k - 1}^\top}{\vec s_k^\top\mat B_{k - 1}\vec s_k},\]</span> and</li>
<li>repeat with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This reduces the cost of computing the Hessian. Further, we can update <span class="math inline">\(\mat B_k^{-1}\)</span> to avoid solving <span class="math inline">\(\mat B_{k - 1}\vec p_k = - \nabla f(\vec x_{k -1})\)</span>. The matrix <span class="math inline">\(\mat B_k^{-1}\)</span> will still be large and dense when <span class="math inline">\(l\)</span> is large.</p>
<div id="using-partial-separability" class="section level3">
<h3>Using Partial Separability</h3>
<p>As an alternative, we can exploit the structure of the problem we are solving. Let</p>
<p><span class="math display">\[\mat H_i = (\vec e_{j_{i1}}^\top, \dots ,\vec e_{j_{im_i}}^\top).\]</span></p>
<p>The true Hessian in our case is sparse and given by</p>
<p><span class="math display">\[\nabla^2 f(\vec x) = \sum_{i = 1}^n    \mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\]</span></p>
<p>Notice that each <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> is only a <span class="math inline">\((p + q_i)\times (p + q_i)\)</span> matrix. We illustrate this below with <span class="math inline">\(n = 10\)</span> element functions. Each plot is <span class="math inline">\(\mat H_i^\top\nabla^2f_i(\vec x_{\mathcal I_i})\mat H_i\)</span> where black entries are a non-zero.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqAAAAEMCAMAAAAs1PT/AAAATlBMVEUAAAADAwMGBgYICAgNDQ0QEBAsLCwzMzM0NDQ9PT1fX19jY2OJiYmMjIyRkZG1tbXFxcXGxsbJycnd3d3z8/P09PT19fX4+Pj8/Pz///9MpF1bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAGbElEQVR4nO3dwW6bRRiG0QBtnRDStCRAuP8bZYHk77HoRCXEP7M4Z9mxnFfOs4lVj2/+hI3d/N8D4DUCZWsCZWsCZWsCZWsCZWsCZWsCZWsCZWsCZWsCZWsXgd6fDnT7tJj0eOSK08NixcvdkSvuXhYzHo5ccXpcrHi6PXLF/TLQTzdjMfX9fP2yOPj842rBNYb9vPj3P374ntfh5uZ9XrJf/ljNe/Nzv2HY8+fFwZcP7xfFzbdcPOLTxcMvTo4M9NdloD8JdOYdGehvy0A/CnQItPME2hOBngk0BFoC7TyB9kSgZwINgdbn36/+s2MZ6C9HrlgHeuSKdaC/HjlDoCXQIdASaAg0BFoCHQItgYZA45VAj5wh0BBoCLQEOgRaAg2BhkBLoEOgJdAQaAi0BDoEWgINgYZAS6BDoCXQEGgItAQ6BFoCDYGGQEugQ6Al0BBoCLQEOgRau38mSaBDoCXQEOjy5NoEGgINgZZAh0DLH0kh0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0CLQEGgINgdbu1y/+hyf91wRaAg2BhkBLoEOgJdAQaAi0BDoEWgINgYZAS6BDoCXQEGgItAQ6BFoCDYGGQEugQ6Al0BBoCLQEOgRauwfqfzMNgZZAQ6DLk2sTaAg0BFoCHQItgYZAQ6Al0CHQEmgINARauwf65vdY3/AGrUBLoCHQEGgJdAi0BBoCDYGWQIdAS6Ah0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0CLQEGgINgdbugR65QqAl0BBoCLQEOgRaAg2BhkBLoEOgJdAQaAi0BDrWgX5865td/3TzLRePEGgJdAi0BBoCDYGWQIdAS6Ah0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0CLQEGgINgZZAh0BLoCHQEGgJdAi0BBoCDYGWQIdAS6Ah0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0+FRnCTQEGgItgQ6BlkBDoCHQEugQaAk0BBoCLYEOgZZAQ6Ah0BLoEGgJNAQaAi2BDoGWQEOgsUmgX5eBPh85Q6DjeRno1yNnrAO9Px3o9mmx7/HIFaeHxYqXuyNX3L0sZjwcueL0uFjxdHvkivtloLAbgbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1gbI1FzcsVri4IXa5uOFTvrTmle+xeR/rq29+fPVnvvOg5dU3P/zrH/QfXqv11Tfv8Qv43udYX33z4WoZ/O0itlfuZjoy0PXlYT8J9OzQQA/5Iq9vEuiSQIdAS6AhUIEuCHQItAQaAv2+QK824BvcsBx7XGDrhuUSaAg0BFoCHQItgYZAQ6Al0LF/oHv8FS/QIdCLE4GeCTQEWgINgV6cCPRMoCHQEmgI9OJEoGcCDYGWQEOgFycCPRNoCLQEGgK9OBHomUBDoCXQEOjFiUDPBBoCLYGGQC9OBHom0Ngm0CNnCDQEGgItgQ6BlkBDoCHQEugQaO3+uXiBDoGWQEOgy5NrE2gINARaAh0CLYGGQEOgJdAh0BJoCDS2D9T7oEOgy5NrE2gINARaAh0CLYGGQEOgJdAh0BJoCDQEWgIdAi2BhkBDoCXQIdASaAg0BFoCHQItgYZAQ6Al0CHQ2j3QTb6r8y3P9lYCLYGGQEOgJdAh0BJoCDQEWgIdAi2BhkBDoCXQIdDaPVDvgw6BlkBDoMuTaxNoCDQEWgIdAi2BhkBDoCXQIdASaAg0BFoCHQItgYZAQ6Al0CHQEmgINARaAh0CLYHGOtD3+LLU730OgZZAQ6Ah0BLoEGgJNAQaAi2BDoGWQEOgIdDaPdAjVwi0BBoCDYGWQIdAS6Ah0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0CLQEGgINgZZAh0BLoCHQEGgJdAi0BBoCDYGWQIdAS6Ah0BBoCXQItAQaAg2BlkCHQEugIdAQaAl0CLQEGrsH+vEdPlv6mpsSaAl0CLQEGgIV6IJAh0BLoCFQgS4IdAi0BBoCFeiCQIdAS6AhUIEuCHQItAQaAhXogkCHQOvrMtDnI2cIdDwvA/2wR6D3pwPdPi3GPh654vSwWPFyd+SKu5fFjIcjV5weFyuebo9ccb8MFHYjULYmULYmULYmULYmULYmULYmULYmULYmULYmULYmULb2F8xodc+9Eoj9AAAAAElFTkSuQmCC" style="display: block; margin: auto;" /></p>
<p>The whole Hessian is:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAD1BMVEUAAAAaGhoiIiJFRUX////5cEo+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAACgUlEQVR4nO3QQY6CABBFQRTvf2Z3jAHCUzPDINbbd+enhps2G/57wNEDFAGKAEWAIkARoAhQ9AM0XjU1rgBdBk1dAG0HKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQNHLQLcvC1AEKAIUAYoARYAiQBGgCFAEKAIUPQX0eLCFd0ZBQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYAiQBGgCFAEKAIUAYoARYCil4Gyk1kBigBFgCJAEaAIUAQoAhQBigBFvw/00PzPJ4oBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhT9KdCihdjxCQFFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBF+wJ1hxMDFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6GtCihdjOuwBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJA0eGBttpjJ6AIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgKKPBpo33/1E+RNQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCgCFAGKAEWAIkARoAhQBCg6FdAbpSAgQJsBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUAQoAhQBigBFgCJAEaAIUPQW0HjV1LgCpNUARYAiQBGgCFAEKAIUAYrup18JmeoS7cYAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>We can use the partial separability to implement a BFGS method where we make <span class="math inline">\(n\)</span> BFGS approximations, one for each element function, <span class="math inline">\(f_i\)</span>. Let <span class="math inline">\(\mat B_{ki}\)</span> be the approximation of <span class="math inline">\(\nabla^2f_i(\vec x_{\mathcal I_i})\)</span> at iteration <span class="math inline">\(k\)</span>. Then the method we have implemented starts with <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span> and</p>
<ol style="list-style-type: decimal">
<li>computes a direction <span class="math inline">\(\vec p_k\)</span> given by <span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1}),\]</span></li>
<li>finds a step size <span class="math inline">\(\alpha\)</span> such that <span class="math inline">\(\vec x_{k - 1} + \alpha\vec p_k\)</span> satisfy the <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">Wolfe conditions</a>,</li>
<li>sets <span class="math inline">\(\vec x_k = \vec x_{k - 1} + \alpha\vec p_k\)</span>,</li>
<li>performs BFGS updates for each <span class="math inline">\(\mat B_{k1},\dots,\mat B_{kn}\)</span>, and</li>
<li>repeats with <span class="math inline">\(k\leftarrow k + 1\)</span> if a convergence criterion is not satisfied.</li>
</ol>
<p>This seems as if it is going to be much slower as we are solving a large linear system if <span class="math inline">\(l\)</span> is large. However, we can use the conjugate gradient method we describe in the next section. This will be fast if we can perform the following matrix-vector product fast:</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec z.\]</span></p>
<p>To elaborate on this, each <span class="math inline">\(\mat H_i^\top\mat B_{k - 1,i}\mat H_i\vec z\)</span> consists of matrix-vector product with a <span class="math inline">\(o_i \times o_i\)</span> symmetric matrix and a vector where <span class="math inline">\(o_i = (p + q_i)\)</span>. This can be done in <span class="math inline">\(2o_i(o_i + 1)\)</span> flops. Thus, the total cost is <span class="math inline">\(2\sum_{i = 1}^n o_i(o_i + 1)\)</span> flops. This is in contrast to the original <span class="math inline">\(2l(l + 1)\)</span> flops with the BFGS method.</p>
<p>As an example suppose that <span class="math inline">\(q_i = 5\)</span> for all <span class="math inline">\(n\)</span> element functions, <span class="math inline">\(n = 5000\)</span>, and <span class="math inline">\(p = 10\)</span>. Then <span class="math inline">\(o_i = 15\)</span> and the matrix-vector product above requires <span class="math inline">\(2\cdot 5000 \cdot 15(15 + 1) = 2400000\)</span> flops. In contrast <span class="math inline">\(l = 5000 \cdot 5 + 10 = 25010\)</span> and the matrix-vector product in the BFGS method requires <span class="math inline">\(2\cdot 25010 (25010 + 1) = 1251050220\)</span> flops. That is 521 times more flops. Similar ratios are shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>More formerly, the former is <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2) = \mathcal O(np^2 + np\bar q + \sum_{i = 1}^nq_i^2)\)</span> where <span class="math inline">\(\bar q = \sum_{i = 1}^n q_i / n\)</span> whereas the matrix-vector product in the BFGS method is <span class="math inline">\(\mathcal O((p + n\bar q)^2) = \mathcal O(p^2 + pn\bar q + (n\bar q)^2)\)</span>. Thus, the former is favorable as long as <span class="math inline">\(np^2 + \sum_{i = 1}^nq_i^2\)</span> is small compared with <span class="math inline">\((n\bar q)^2\)</span>. Furthermore, the rank-two BFGS updates are cheaper and may converge faster to a good approximation. However, we should keep in mind that the original BFGS method yields an approximation of <span class="math inline">\(\mat B_k^{-1}\)</span>. Thus, we do not need to solve a linear system. However, we may not need to take many conjugate gradient iterations to get a good approximation with the implemented quasi-Newton method.</p>
</div>
</div>
<div id="conjugate-gradient-method" class="section level2">
<h2>Conjugate Gradient Method</h2>
<p>The conjugate gradient method we use solves</p>
<p><span class="math display">\[\mat A\vec b = \vec v\]</span></p>
<p>which in our quasi-Newton method is</p>
<p><span class="math display">\[\left(\sum_{i = 1}^n\mat H_i^\top\mat B_{k - 1,i}\mat H_i\right)\vec p_k = - \nabla f(\vec x_{k -1})\]</span></p>
<p>We start of with some initial value <span class="math inline">\(\vec x_0\)</span>. Then we set <span class="math inline">\(k = 0\)</span>, <span class="math inline">\(\vec r_0 = \mat A\vec x_0 - \vec v\)</span>, <span class="math inline">\(\vec p_0 = -\vec r_0\)</span>, and:</p>
<ol style="list-style-type: decimal">
<li>find the step length <span class="math display">\[\alpha_k = \frac{\vec r_k^\top\vec r_k}{\vec p_k^\top\mat A\vec p_k},\]</span></li>
<li>find the new value <span class="math display">\[\vec x_{k + 1} = \vec x_k + \alpha_k\vec p_k,\]</span></li>
<li>find the new residual <span class="math display">\[\vec r_{k + 1} = \vec r_k + \alpha_k\mat A\vec p_k,\]</span></li>
<li>set <span class="math inline">\(\beta_{k + 1} = (\vec r_k^\top\vec r_k)^{-1}\vec r_{k + 1}^\top\vec r_{k + 1}\)</span>,</li>
<li>set the new search direction to <span class="math display">\[\vec p_{k + 1} = - \vec r_{k + 1} + \beta_{k + 1}\vec p_k,\]</span> and</li>
<li>stop if <span class="math inline">\(\vec r_{k + 1}^\top\vec r_{k + 1}\)</span> is smaller. Otherwise set <span class="math inline">\(k\leftarrow k + 1\)</span> and repeat.</li>
</ol>
<p>The main issue is the matrix-vector product <span class="math inline">\(\mat A\vec p_k\)</span> but as we argued in the previous section that this can be computed in <span class="math inline">\(\mathcal O(\sum_{i = 1}^n(p + q_{i})^2)\)</span> time. The conjugate gradient method will at most take <span class="math inline">\(h\)</span> iterations where <span class="math inline">\(h\)</span> is the number of rows and columns of <span class="math inline">\(\mat A\)</span>. Moreover, if <span class="math inline">\(\mat A\)</span> only has <span class="math inline">\(r &lt; h\)</span> distinct eigenvalues then we will at most make <span class="math inline">\(r\)</span> conjugate gradient iterations. Lastly, if <span class="math inline">\(\mat A\)</span> has clusters of eigenvalues then we may expect to perform only a number of iterations close to the number of distinct clusters.</p>
<p>In practice, we terminate the conjugate gradient method when <span class="math inline">\(\lVert\vec r_k\rVert &lt; \min (c, \sqrt{\lVert\nabla f(\vec x_{k -1})\rVert})\lVert\nabla f(\vec x_{k -1})\rVert\)</span> where <span class="math inline">\(c\)</span> is a constant the user can set. Moreover, we use diagonal preconditioning.</p>
<p>We can compare the flops of the matrix product in BFGS with applying the conjugate gradient method. Assume that all <span class="math inline">\(q_i\)</span>s are almost <span class="math inline">\(\bar q\)</span>. Then the ratio of flops is approximately:</p>
<p><span class="math display">\[
\frac{p^2 + 2pn\bar q + (n\bar q)^2}
     {n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
\]</span></p>
<p>where <span class="math inline">\(n_{\text{cg}}\)</span> is the number of conjugate gradient iterations. Thus, to get something which is linear in the number of element functions, <span class="math inline">\(n\)</span>, then we must have that:</p>
<p><span class="math display">\[
\begin{align*}
\frac{n_{\text{cg}}(np^2 + 2pn\bar q + n\bar q^2)}
     {p^2 + 2pn\bar q + (n\bar q)^2} &amp;\leq \frac kn \\
\Leftrightarrow n_{\text{cg}} &amp;\leq \frac kn
  \frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {np^2 + 2pn\bar q + n\bar q^2} \\
&amp;= k\frac{p^2 + 2pn\bar q + (n\bar q)^2}
  {n^2(p^2 + 2p\bar q + \bar q^2)} \\
&amp;\approx k 
  \frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(k\)</span> is some fixed constant with <span class="math inline">\(k &lt; n\)</span>. An example of the latter ratio is shown in the <a href="#bfgs-and-partially-separable-quasi-newton">BFGS and Partially Separable Quasi-Newton</a> section.</p>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> in the denominator by once computing the first <span class="math inline">\(p\times p\)</span> part of the Hessian approximation prior to performing the conjugate gradient method. This is implemented. The <code>max_cg</code> argument is added beacuse of the considerations above.</p>
</div>
<div id="line-search-and-wolfe-condition" class="section level2">
<h2>Line Search and Wolfe Condition</h2>
<p>We use line search and search for a point which satisfy <a href="https://en.wikipedia.org/wiki/Wolfe_conditions">the strong Wolfe condition</a> by default. The constants in the Wolfe condition can be set by the user. The line search is implemented as described by <span class="citation">Nocedal and Wright (2006)</span> with cubic interpolation in the zoom phase.</p>
</div>
<div id="symmetric-rank-one-updates" class="section level2">
<h2>Symmetric Rank-one Updates</h2>
<p><a href="https://en.wikipedia.org/wiki/Symmetric_rank-one">Symmetric rank-one (SR1)</a> updates are implemented as an alternative to the BFGS updates. The user can set whether the SR1 updates should be used. The SR1 updates does not guarantee that the Hessian approximation is positive definite. Thus, the conjugate gradient method only proceeds if <span class="math inline">\(\vec p_k^\top\mat A\vec p_k &gt; 0\)</span>. That is, if the new direction is a descent direction.</p>
</div>
<div id="example-using-the-implementation" class="section level2">
<h2>Example Using the Implementation</h2>
<p>We simulate a data set below from the mixed logit model we showed earlier.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co"># assign model parameters, number of random effects, and fixed effects</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">q &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># number of private parameters per cluster</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">p &lt;-<span class="st"> </span><span class="dv">5</span> <span class="co"># number of global parameters</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">beta &lt;-<span class="st"> </span><span class="kw">sqrt</span>((<span class="dv">1</span><span class="op">:</span>p) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(<span class="dv">1</span><span class="op">:</span>p))</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">Sigma &lt;-<span class="st"> </span><span class="kw">diag</span>(q)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="co"># simulate a data set</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">n_clusters &lt;-<span class="st"> </span>800L <span class="co"># number of clusters</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">set.seed</span>(<span class="dv">66608927</span>)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">sim_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(20L, 1L) <span class="op">+</span><span class="st"> </span>2L</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(p <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)), </a>
<a class="sourceLine" id="cb1-14" data-line-number="14">              p)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  u &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">rnorm</span>(q) <span class="op">%*%</span><span class="st"> </span><span class="kw">chol</span>(Sigma))</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  Z &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(q <span class="op">*</span><span class="st"> </span>n_members, <span class="op">-</span><span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q), <span class="kw">sqrt</span>(<span class="dv">6</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>q)), </a>
<a class="sourceLine" id="cb1-17" data-line-number="17">              q)</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  y &lt;-<span class="st"> </span><span class="kw">as.numeric</span>((<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>eta))<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>) <span class="op">&gt;</span><span class="st"> </span><span class="kw">runif</span>(n_members))</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  </a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  <span class="kw">list</span>(<span class="dt">X =</span> X, <span class="dt">Z =</span> Z, <span class="dt">y =</span> y, <span class="dt">u =</span> u, <span class="dt">Sigma_inv =</span> <span class="kw">solve</span>(Sigma))</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="co"># example of the first cluster</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">sim_dat[[1L]]</a>
<a class="sourceLine" id="cb1-26" data-line-number="26"><span class="co">#&gt; $X</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="co">#&gt;         [,1]   [,2]    [,3]</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="co">#&gt; [1,]  0.0416 -0.809 -0.1839</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29"><span class="co">#&gt; [2,]  0.6524 -1.373 -0.9254</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30"><span class="co">#&gt; [3,] -1.3339 -0.957 -0.8708</span></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="co">#&gt; [4,]  0.7547 -0.156  0.0178</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32"><span class="co">#&gt; [5,]  0.7191 -0.681 -0.7232</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34"><span class="co">#&gt; $Z</span></a>
<a class="sourceLine" id="cb1-35" data-line-number="35"><span class="co">#&gt;        [,1]   [,2]   [,3]</span></a>
<a class="sourceLine" id="cb1-36" data-line-number="36"><span class="co">#&gt; [1,]  0.167 -0.483 -0.785</span></a>
<a class="sourceLine" id="cb1-37" data-line-number="37"><span class="co">#&gt; [2,] -0.266 -0.823  0.794</span></a>
<a class="sourceLine" id="cb1-38" data-line-number="38"><span class="co">#&gt; [3,]  0.609 -0.549  0.269</span></a>
<a class="sourceLine" id="cb1-39" data-line-number="39"><span class="co">#&gt; [4,] -0.414 -0.457  0.605</span></a>
<a class="sourceLine" id="cb1-40" data-line-number="40"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-41" data-line-number="41"><span class="co">#&gt; $y</span></a>
<a class="sourceLine" id="cb1-42" data-line-number="42"><span class="co">#&gt; [1] 0 0 0</span></a>
<a class="sourceLine" id="cb1-43" data-line-number="43"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-44" data-line-number="44"><span class="co">#&gt; $u</span></a>
<a class="sourceLine" id="cb1-45" data-line-number="45"><span class="co">#&gt; [1]  0.0705 -1.7285  0.1538 -0.3245</span></a>
<a class="sourceLine" id="cb1-46" data-line-number="46"><span class="co">#&gt; </span></a>
<a class="sourceLine" id="cb1-47" data-line-number="47"><span class="co">#&gt; $Sigma_inv</span></a>
<a class="sourceLine" id="cb1-48" data-line-number="48"><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></a>
<a class="sourceLine" id="cb1-49" data-line-number="49"><span class="co">#&gt; [1,]    1    0    0    0</span></a>
<a class="sourceLine" id="cb1-50" data-line-number="50"><span class="co">#&gt; [2,]    0    1    0    0</span></a>
<a class="sourceLine" id="cb1-51" data-line-number="51"><span class="co">#&gt; [3,]    0    0    1    0</span></a>
<a class="sourceLine" id="cb1-52" data-line-number="52"><span class="co">#&gt; [4,]    0    0    0    1</span></a></code></pre></div>
<p>The combined vector with global and private parameters can be created like this (it is a misnoma to call this <code>true_params</code> as the modes of the random effects, the private parameters, should only match the random effects if the clusters are very large):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">true_params &lt;-<span class="st"> </span><span class="kw">c</span>(beta, <span class="kw">sapply</span>(sim_dat, <span class="cf">function</span>(x) x<span class="op">$</span>u))</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co"># global parameters</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">true_params[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">#&gt; [1] 0.258 0.365 0.447 0.516 0.577</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co"># some of the private parameters</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">true_params[<span class="dv">1</span><span class="op">:</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>q) <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="co">#&gt;  [1]  0.0705 -1.7285  0.1538 -0.3245  0.2516 -0.5419 -0.5537 -0.2805 -1.1777</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co">#&gt; [10] -1.7539  1.7338  0.5616 -0.8379  1.2412 -1.2046  1.4547</span></a></code></pre></div>
<p>As a reference, we will create the following function to evaluate the log of the integrand:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">eval_integrand &lt;-<span class="st"> </span><span class="cf">function</span>(par){</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  out &lt;-<span class="st"> </span><span class="fl">0.</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  inc &lt;-<span class="st"> </span>p</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    dat &lt;-<span class="st"> </span>sim_dat[[i]]</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    u &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>inc]</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    inc &lt;-<span class="st"> </span>inc <span class="op">+</span><span class="st"> </span>q</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>u <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    out &lt;-<span class="st"> </span>out <span class="op">-</span><span class="st"> </span><span class="kw">drop</span>(y <span class="op">%*%</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(eta))) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17"><span class="st">      </span><span class="fl">.5</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(u <span class="op">%*%</span><span class="st"> </span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>u)</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  }</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  </a>
<a class="sourceLine" id="cb3-20" data-line-number="20">  out</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">}</a>
<a class="sourceLine" id="cb3-22" data-line-number="22"></a>
<a class="sourceLine" id="cb3-23" data-line-number="23"><span class="co"># check the log integrand at true global parameters and the random effects</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24"><span class="kw">eval_integrand</span>(true_params)</a>
<a class="sourceLine" id="cb3-25" data-line-number="25"><span class="co">#&gt; [1] 6898</span></a></code></pre></div>
<p>We will use this function to compare with our C++ implementation.</p>
<div id="r-implementation" class="section level3">
<h3>R Implementation</h3>
<p>A R function which we need to pass to <code>psqn</code> to minimize the partially separable function is given below:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># evalutes the negative log integrand. </span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co"># </span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co"># Args:</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">#   i cluster/element function index. </span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">#   par the global and private parameter for this cluster. It has length </span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">#       zero if the number of parameters is requested.</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">#   comp_grad logical for whether to compute the gradient. </span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  dat &lt;-<span class="st"> </span>sim_dat[[i]]</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  X &lt;-<span class="st"> </span>dat<span class="op">$</span>X</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  Z &lt;-<span class="st"> </span>dat<span class="op">$</span>Z</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    <span class="co"># requested the dimension of the parameter</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>X), <span class="dt">private_dim =</span> <span class="kw">NROW</span>(dat<span class="op">$</span>Z)))</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  y &lt;-<span class="st"> </span>dat<span class="op">$</span>y</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  Sigma_inv &lt;-<span class="st"> </span>dat<span class="op">$</span>Sigma_inv</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">  </a>
<a class="sourceLine" id="cb4-20" data-line-number="20">  beta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">  uhat &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">  eta &lt;-<span class="st"> </span><span class="kw">drop</span>(beta <span class="op">%*%</span><span class="st"> </span>X <span class="op">+</span><span class="st"> </span>uhat <span class="op">%*%</span><span class="st"> </span>Z)</a>
<a class="sourceLine" id="cb4-23" data-line-number="23">  exp_eta &lt;-<span class="st"> </span><span class="kw">exp</span>(eta)</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  </a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  out &lt;-<span class="st"> </span><span class="op">-</span><span class="kw">sum</span>(y <span class="op">*</span><span class="st"> </span>eta) <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26"><span class="st">    </span><span class="kw">sum</span>(uhat <span class="op">*</span><span class="st"> </span>(Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)) <span class="op">/</span><span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">  <span class="cf">if</span>(comp_grad){</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">    d_eta &lt;-<span class="st"> </span><span class="op">-</span>y <span class="op">+</span><span class="st"> </span>exp_eta <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>exp_eta)</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">    grad &lt;-<span class="st"> </span><span class="kw">c</span>(X <span class="op">%*%</span><span class="st"> </span>d_eta, </a>
<a class="sourceLine" id="cb4-30" data-line-number="30">              Z <span class="op">%*%</span><span class="st"> </span>d_eta <span class="op">+</span><span class="st"> </span>dat<span class="op">$</span>Sigma_inv <span class="op">%*%</span><span class="st"> </span>uhat)</a>
<a class="sourceLine" id="cb4-31" data-line-number="31">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</a>
<a class="sourceLine" id="cb4-32" data-line-number="32">  }</a>
<a class="sourceLine" id="cb4-33" data-line-number="33">  </a>
<a class="sourceLine" id="cb4-34" data-line-number="34">  out</a>
<a class="sourceLine" id="cb4-35" data-line-number="35">}</a></code></pre></div>
<p>Here is a check that the above yields the same as the function we defined before:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># check the function</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">r_func_val &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span>n_clusters, <span class="cf">function</span>(i)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">FALSE</span>)))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">all.equal</span>(<span class="kw">eval_integrand</span>(true_params), r_func_val)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co"># we could check the gradient like this</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="cf">if</span>(<span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  r_func_gr &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(true_params))</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(sim_dat)){</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    out_i &lt;-<span class="st"> </span><span class="kw">r_func</span>(i, true_params[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>p, <span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p)], <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    r_func_gr[<span class="dv">1</span><span class="op">:</span>p] &lt;-<span class="st"> </span>r_func_gr[<span class="dv">1</span><span class="op">:</span>p] <span class="op">+</span><span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>p]</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    r_func_gr[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>(i <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>p] &lt;-<span class="st"> </span><span class="kw">attr</span>(out_i, <span class="st">&quot;grad&quot;</span>)[<span class="dv">1</span><span class="op">:</span>q <span class="op">+</span><span class="st"> </span>p]</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  }</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  </a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">library</span>(numDeriv)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(<span class="cf">function</span>(par) <span class="kw">eval_integrand</span>(par), true_params)</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">  <span class="kw">all.equal</span>(r_func_gr, gr_num, <span class="dt">tolerance =</span> <span class="fl">1e-6</span>)</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">}</a></code></pre></div>
<p>The partially separable function can be minimized like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">start_val &lt;-<span class="st"> </span>true_params </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">start_val[  <span class="dv">1</span><span class="op">:</span>p ] &lt;-<span class="st"> </span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="st">  </span>start_val[  <span class="dv">1</span><span class="op">:</span>p ] <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="st">  </span><span class="kw">c</span>(<span class="fl">0.49</span>, <span class="fl">-0.63</span>, <span class="fl">-0.4</span>, <span class="fl">-0.33</span>, <span class="fl">-0.38</span>) <span class="co"># ~rnorm(length(beta), sd = .5)</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">start_val[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span>p)] &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">library</span>(psqn)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb6-9" data-line-number="9">                        <span class="dt">c2 =</span> <span class="fl">.9</span>)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb6-11" data-line-number="11">       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(start_val)</a></code></pre></div>
<p>We will later compare this with the result from the C++ implementation which we provide in the next section.</p>
</div>
<div id="c-implementation" class="section level3">
<h3>C++ Implementation</h3>
<p>We provide a C++ implementation with the package as an example of how to use this package. The location of the implementation can be found by calling <code>system.file(&quot;mlogit-ex.cpp&quot;, package = &quot;psqn&quot;)</code>. The most important part of the implementation is the problem specific <code>m_logit_func</code> class, the <code>get_mlogit_optimizer</code> function and the <code>optim_mlogit</code> function which are needed to perform the optimization. The content of the file is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">// we will use openMP to perform the comptutation in parallel</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co">// we use RcppArmadillo to simplify the code</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="co">// [[Rcpp::depends(psqn)]]</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"></a>
<a class="sourceLine" id="cb7-13" data-line-number="13"><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, <span class="dt">size_t</span> <span class="at">const</span> n_ele){</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb7-17" data-line-number="17"></a>
<a class="sourceLine" id="cb7-18" data-line-number="18"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19"><span class="co"> implements the element function for a given cluster. The class must provide</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20"><span class="co"> the member functions which we provide here.</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22"><span class="co"> We do not need to inherit from the element_function class but we can do it</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23"><span class="co"> to ensure that we have implemented all the member functions.</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25"><span class="kw">class</span> <span class="va">m_logit_func</span> <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">  <span class="co">/// design matrices</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">  arma::mat <span class="at">const</span> X, Z;</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  <span class="co">/// outcomes</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">  arma::vec <span class="at">const</span> y;</a>
<a class="sourceLine" id="cb7-30" data-line-number="30">  <span class="co">/// inverse covariance matrix</span></a>
<a class="sourceLine" id="cb7-31" data-line-number="31">  arma::mat <span class="at">const</span> Sigma_inv;</a>
<a class="sourceLine" id="cb7-32" data-line-number="32"></a>
<a class="sourceLine" id="cb7-33" data-line-number="33"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb7-34" data-line-number="34">  <span class="va">m_logit_func</span>(List data):</a>
<a class="sourceLine" id="cb7-35" data-line-number="35">  X        (as&lt;arma::mat&gt;(data[<span class="st">&quot;X&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-36" data-line-number="36">  Z        (as&lt;arma::mat&gt;(data[<span class="st">&quot;Z&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-37" data-line-number="37">  y        (as&lt;arma::vec&gt;(data[<span class="st">&quot;y&quot;</span>        ])),</a>
<a class="sourceLine" id="cb7-38" data-line-number="38">  Sigma_inv(as&lt;arma::mat&gt;(data[<span class="st">&quot;Sigma_inv&quot;</span>])) { }</a>
<a class="sourceLine" id="cb7-39" data-line-number="39"></a>
<a class="sourceLine" id="cb7-40" data-line-number="40">  <span class="co">/// dimension of the global parameters</span></a>
<a class="sourceLine" id="cb7-41" data-line-number="41">  <span class="dt">size_t</span> global_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-42" data-line-number="42">    <span class="cf">return</span> X.n_rows;</a>
<a class="sourceLine" id="cb7-43" data-line-number="43">  }</a>
<a class="sourceLine" id="cb7-44" data-line-number="44">  <span class="co">/// dimension of the private parameters</span></a>
<a class="sourceLine" id="cb7-45" data-line-number="45">  <span class="dt">size_t</span> private_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-46" data-line-number="46">    <span class="cf">return</span> Z.n_rows;</a>
<a class="sourceLine" id="cb7-47" data-line-number="47">  }</a>
<a class="sourceLine" id="cb7-48" data-line-number="48"></a>
<a class="sourceLine" id="cb7-49" data-line-number="49">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-50" data-line-number="50"><span class="co">   computes the element function.</span></a>
<a class="sourceLine" id="cb7-51" data-line-number="51"><span class="co">   @param point point to compute function at.</span></a>
<a class="sourceLine" id="cb7-52" data-line-number="52"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-53" data-line-number="53">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-54" data-line-number="54">    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</a>
<a class="sourceLine" id="cb7-55" data-line-number="55">                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</a>
<a class="sourceLine" id="cb7-56" data-line-number="56"></a>
<a class="sourceLine" id="cb7-57" data-line-number="57">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-58" data-line-number="58">    <span class="cf">for</span>(<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</a>
<a class="sourceLine" id="cb7-59" data-line-number="59">      <span class="dt">double</span> <span class="at">const</span> eta =</a>
<a class="sourceLine" id="cb7-60" data-line-number="60">        arma::dot(beta, X.col(i)) + arma::dot(u, Z.col(i));</a>
<a class="sourceLine" id="cb7-61" data-line-number="61">      out -= y[i] * eta - log(<span class="dv">1</span> + exp(eta));</a>
<a class="sourceLine" id="cb7-62" data-line-number="62">    }</a>
<a class="sourceLine" id="cb7-63" data-line-number="63"></a>
<a class="sourceLine" id="cb7-64" data-line-number="64">    out += arma::dot(u, Sigma_inv * u) * <span class="fl">.5</span>;</a>
<a class="sourceLine" id="cb7-65" data-line-number="65"></a>
<a class="sourceLine" id="cb7-66" data-line-number="66">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-67" data-line-number="67">  }</a>
<a class="sourceLine" id="cb7-68" data-line-number="68"></a>
<a class="sourceLine" id="cb7-69" data-line-number="69">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-70" data-line-number="70"><span class="co">   computes the element function and its gradient.</span></a>
<a class="sourceLine" id="cb7-71" data-line-number="71"><span class="co">   @param point point to compute function at.</span></a>
<a class="sourceLine" id="cb7-72" data-line-number="72"><span class="co">   @param gr gradient vector with respect to global and private parameters.</span></a>
<a class="sourceLine" id="cb7-73" data-line-number="73"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-74" data-line-number="74">  <span class="dt">double</span> grad</a>
<a class="sourceLine" id="cb7-75" data-line-number="75">    (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-76" data-line-number="76">    arma::vec <span class="at">const</span> beta = vec_no_cp(point           , X.n_rows),</a>
<a class="sourceLine" id="cb7-77" data-line-number="77">                       u = vec_no_cp(point + X.n_rows, Z.n_rows);</a>
<a class="sourceLine" id="cb7-78" data-line-number="78"></a>
<a class="sourceLine" id="cb7-79" data-line-number="79">    <span class="co">// create objects to write to for the gradient</span></a>
<a class="sourceLine" id="cb7-80" data-line-number="80">    <span class="bu">std::</span>fill(gr, gr + beta.n_elem + u.n_elem, <span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb7-81" data-line-number="81">    arma::vec dbeta(gr              , beta.n_elem, <span class="kw">false</span>),</a>
<a class="sourceLine" id="cb7-82" data-line-number="82">              du   (gr + beta.n_elem, u.n_elem   , <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-83" data-line-number="83"></a>
<a class="sourceLine" id="cb7-84" data-line-number="84">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-85" data-line-number="85">    <span class="cf">for</span>(<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; y.n_elem; ++i){</a>
<a class="sourceLine" id="cb7-86" data-line-number="86">      arma::vec <span class="at">const</span> xi = X.unsafe_col(i),</a>
<a class="sourceLine" id="cb7-87" data-line-number="87">                      zi = Z.unsafe_col(i);</a>
<a class="sourceLine" id="cb7-88" data-line-number="88">      <span class="dt">double</span> <span class="at">const</span> eta = arma::dot(beta, xi) + arma::dot(u, zi),</a>
<a class="sourceLine" id="cb7-89" data-line-number="89">               exp_eta = exp(eta),</a>
<a class="sourceLine" id="cb7-90" data-line-number="90">               d_eta   = y[i] - exp_eta / (<span class="dv">1</span> + exp_eta);</a>
<a class="sourceLine" id="cb7-91" data-line-number="91">      out -= y[i] * eta - log(<span class="dv">1</span> + exp_eta);</a>
<a class="sourceLine" id="cb7-92" data-line-number="92">      dbeta -= d_eta * xi;</a>
<a class="sourceLine" id="cb7-93" data-line-number="93">      du    -= d_eta * zi;</a>
<a class="sourceLine" id="cb7-94" data-line-number="94">    }</a>
<a class="sourceLine" id="cb7-95" data-line-number="95"></a>
<a class="sourceLine" id="cb7-96" data-line-number="96">    arma::vec u_scaled = Sigma_inv * u;</a>
<a class="sourceLine" id="cb7-97" data-line-number="97">    out += arma::dot(u, u_scaled) * <span class="fl">.5</span>;</a>
<a class="sourceLine" id="cb7-98" data-line-number="98">    du += u_scaled;</a>
<a class="sourceLine" id="cb7-99" data-line-number="99"></a>
<a class="sourceLine" id="cb7-100" data-line-number="100">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-101" data-line-number="101">  }</a>
<a class="sourceLine" id="cb7-102" data-line-number="102"></a>
<a class="sourceLine" id="cb7-103" data-line-number="103">  <span class="co">/***</span></a>
<a class="sourceLine" id="cb7-104" data-line-number="104"><span class="co">   returns true if the member functions are thread-safe.</span></a>
<a class="sourceLine" id="cb7-105" data-line-number="105"><span class="co">   */</span></a>
<a class="sourceLine" id="cb7-106" data-line-number="106">  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb7-107" data-line-number="107">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb7-108" data-line-number="108">  }</a>
<a class="sourceLine" id="cb7-109" data-line-number="109">};</a>
<a class="sourceLine" id="cb7-110" data-line-number="110"></a>
<a class="sourceLine" id="cb7-111" data-line-number="111"><span class="kw">using</span> mlogit_topim = PSQN::optimizer&lt;<span class="va">m_logit_func</span>, PSQN::R_reporter,</a>
<a class="sourceLine" id="cb7-112" data-line-number="112">                                     PSQN::R_interrupter&gt;;</a>
<a class="sourceLine" id="cb7-113" data-line-number="113"></a>
<a class="sourceLine" id="cb7-114" data-line-number="114"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-115" data-line-number="115"><span class="co"> creates a pointer to an object which is needed in the optim_mlogit</span></a>
<a class="sourceLine" id="cb7-116" data-line-number="116"><span class="co"> function.</span></a>
<a class="sourceLine" id="cb7-117" data-line-number="117"><span class="co"> @param data list with data for each element function.</span></a>
<a class="sourceLine" id="cb7-118" data-line-number="118"><span class="co"> @param max_threads maximum number of threads to use.</span></a>
<a class="sourceLine" id="cb7-119" data-line-number="119"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-120" data-line-number="120"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-121" data-line-number="121">SEXP get_mlogit_optimizer(List data, <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</a>
<a class="sourceLine" id="cb7-122" data-line-number="122">  <span class="dt">size_t</span> <span class="at">const</span> n_elem_funcs = data.size();</a>
<a class="sourceLine" id="cb7-123" data-line-number="123">  <span class="bu">std::</span>vector&lt;<span class="va">m_logit_func</span>&gt; funcs;</a>
<a class="sourceLine" id="cb7-124" data-line-number="124">  funcs.reserve(n_elem_funcs);</a>
<a class="sourceLine" id="cb7-125" data-line-number="125">  <span class="cf">for</span>(<span class="kw">auto</span> dat : data)</a>
<a class="sourceLine" id="cb7-126" data-line-number="126">    funcs.emplace_back(List(dat));</a>
<a class="sourceLine" id="cb7-127" data-line-number="127"></a>
<a class="sourceLine" id="cb7-128" data-line-number="128">  <span class="co">// create an XPtr to the object we will need</span></a>
<a class="sourceLine" id="cb7-129" data-line-number="129">  XPtr&lt;mlogit_topim&gt; ptr(<span class="kw">new</span> mlogit_topim(funcs, max_threads));</a>
<a class="sourceLine" id="cb7-130" data-line-number="130"></a>
<a class="sourceLine" id="cb7-131" data-line-number="131">  <span class="co">// return the pointer to be used later</span></a>
<a class="sourceLine" id="cb7-132" data-line-number="132">  <span class="cf">return</span> ptr;</a>
<a class="sourceLine" id="cb7-133" data-line-number="133">}</a>
<a class="sourceLine" id="cb7-134" data-line-number="134"></a>
<a class="sourceLine" id="cb7-135" data-line-number="135"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-136" data-line-number="136"><span class="co"> performs the optimization.</span></a>
<a class="sourceLine" id="cb7-137" data-line-number="137"><span class="co"> @param val vector with starting value for the global and private</span></a>
<a class="sourceLine" id="cb7-138" data-line-number="138"><span class="co"> parameters.</span></a>
<a class="sourceLine" id="cb7-139" data-line-number="139"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-140" data-line-number="140"><span class="co"> @param rel_eps relative convergence threshold.</span></a>
<a class="sourceLine" id="cb7-141" data-line-number="141"><span class="co"> @param max_it maximum number iterations.</span></a>
<a class="sourceLine" id="cb7-142" data-line-number="142"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-143" data-line-number="143"><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></a>
<a class="sourceLine" id="cb7-144" data-line-number="144"><span class="co"> @param use_bfgs boolean for whether to use SR1 or BFGS updates.</span></a>
<a class="sourceLine" id="cb7-145" data-line-number="145"><span class="co"> @param trace integer where larger values gives more information during the</span></a>
<a class="sourceLine" id="cb7-146" data-line-number="146"><span class="co"> optimization.</span></a>
<a class="sourceLine" id="cb7-147" data-line-number="147"><span class="co"> @param cg_tol threshold for conjugate gradient method.</span></a>
<a class="sourceLine" id="cb7-148" data-line-number="148"><span class="co"> @param strong_wolfe true if the strong Wolfe condition should be used.</span></a>
<a class="sourceLine" id="cb7-149" data-line-number="149"><span class="co"> @param max_cg maximum number of conjugate gradient iterations in each</span></a>
<a class="sourceLine" id="cb7-150" data-line-number="150"><span class="co"> iteration. Use zero if there should not be a limit.</span></a>
<a class="sourceLine" id="cb7-151" data-line-number="151"><span class="co"> @param pre_method preconditioning method in conjugate gradient method.</span></a>
<a class="sourceLine" id="cb7-152" data-line-number="152"><span class="co"> zero yields no preconditioning and one yields diagonal preconditioning.</span></a>
<a class="sourceLine" id="cb7-153" data-line-number="153"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-154" data-line-number="154"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-155" data-line-number="155">List opti<span class="va">m_mlogit</span></a>
<a class="sourceLine" id="cb7-156" data-line-number="156">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb7-157" data-line-number="157">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb7-158" data-line-number="158">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0L</span>,</a>
<a class="sourceLine" id="cb7-159" data-line-number="159">   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb7-160" data-line-number="160">   <span class="dt">size_t</span> <span class="at">const</span> max_cg = <span class="dv">0L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1L</span>){</a>
<a class="sourceLine" id="cb7-161" data-line-number="161">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-162" data-line-number="162"></a>
<a class="sourceLine" id="cb7-163" data-line-number="163">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-164" data-line-number="164">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-165" data-line-number="165">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-166" data-line-number="166"></a>
<a class="sourceLine" id="cb7-167" data-line-number="167">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb7-168" data-line-number="168">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-169" data-line-number="169">  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</a>
<a class="sourceLine" id="cb7-170" data-line-number="170">                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb7-171" data-line-number="171">                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb7-172" data-line-number="172">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb7-173" data-line-number="173">    res.n_eval, res.n_grad,  res.n_cg);</a>
<a class="sourceLine" id="cb7-174" data-line-number="174">  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</a>
<a class="sourceLine" id="cb7-175" data-line-number="175"></a>
<a class="sourceLine" id="cb7-176" data-line-number="176">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb7-177" data-line-number="177">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb7-178" data-line-number="178">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</a>
<a class="sourceLine" id="cb7-179" data-line-number="179">    _[<span class="st">&quot;counts&quot;</span>] = counts,</a>
<a class="sourceLine" id="cb7-180" data-line-number="180">    _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged );</a>
<a class="sourceLine" id="cb7-181" data-line-number="181">}</a>
<a class="sourceLine" id="cb7-182" data-line-number="182"></a>
<a class="sourceLine" id="cb7-183" data-line-number="183"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-184" data-line-number="184"><span class="co"> performs the optimization but only for the private parameters.</span></a>
<a class="sourceLine" id="cb7-185" data-line-number="185"><span class="co"> @param val vector with starting value for the global and private</span></a>
<a class="sourceLine" id="cb7-186" data-line-number="186"><span class="co"> parameters.</span></a>
<a class="sourceLine" id="cb7-187" data-line-number="187"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-188" data-line-number="188"><span class="co"> @param rel_eps relative convergence threshold.</span></a>
<a class="sourceLine" id="cb7-189" data-line-number="189"><span class="co"> @param max_it maximum number iterations.</span></a>
<a class="sourceLine" id="cb7-190" data-line-number="190"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-191" data-line-number="191"><span class="co"> @param c1,c2 thresholds for Wolfe condition.</span></a>
<a class="sourceLine" id="cb7-192" data-line-number="192"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-193" data-line-number="193"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-194" data-line-number="194">NumericVector opti<span class="va">m_mlogit_private</span></a>
<a class="sourceLine" id="cb7-195" data-line-number="195">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb7-196" data-line-number="196">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1, <span class="dt">double</span> <span class="at">const</span> c2){</a>
<a class="sourceLine" id="cb7-197" data-line-number="197">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-198" data-line-number="198"></a>
<a class="sourceLine" id="cb7-199" data-line-number="199">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-200" data-line-number="200">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-201" data-line-number="201">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_mlogit_private: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-202" data-line-number="202"></a>
<a class="sourceLine" id="cb7-203" data-line-number="203">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb7-204" data-line-number="204">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-205" data-line-number="205">  <span class="dt">double</span> <span class="at">const</span> res = optim-&gt;optim_priv(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2);</a>
<a class="sourceLine" id="cb7-206" data-line-number="206">  par.attr(<span class="st">&quot;value&quot;</span>) = res;</a>
<a class="sourceLine" id="cb7-207" data-line-number="207">  <span class="cf">return</span> par;</a>
<a class="sourceLine" id="cb7-208" data-line-number="208">}</a>
<a class="sourceLine" id="cb7-209" data-line-number="209"></a>
<a class="sourceLine" id="cb7-210" data-line-number="210"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-211" data-line-number="211"><span class="co"> evaluates the partially separable function.</span></a>
<a class="sourceLine" id="cb7-212" data-line-number="212"><span class="co"> @param val vector with global and private parameters to evaluate the</span></a>
<a class="sourceLine" id="cb7-213" data-line-number="213"><span class="co"> function at.</span></a>
<a class="sourceLine" id="cb7-214" data-line-number="214"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-215" data-line-number="215"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-216" data-line-number="216"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-217" data-line-number="217"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-218" data-line-number="218"><span class="dt">double</span> eval_mlogit(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb7-219" data-line-number="219">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-220" data-line-number="220"></a>
<a class="sourceLine" id="cb7-221" data-line-number="221">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-222" data-line-number="222">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-223" data-line-number="223">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-224" data-line-number="224"></a>
<a class="sourceLine" id="cb7-225" data-line-number="225">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-226" data-line-number="226">  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb7-227" data-line-number="227">}</a>
<a class="sourceLine" id="cb7-228" data-line-number="228"></a>
<a class="sourceLine" id="cb7-229" data-line-number="229"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-230" data-line-number="230"><span class="co"> evaluates the gradient of a partially separable function.</span></a>
<a class="sourceLine" id="cb7-231" data-line-number="231"><span class="co"> @param val vector with global and private parameters to evaluate the</span></a>
<a class="sourceLine" id="cb7-232" data-line-number="232"><span class="co"> function at.</span></a>
<a class="sourceLine" id="cb7-233" data-line-number="233"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-234" data-line-number="234"><span class="co"> @param n_threads number of threads to use.</span></a>
<a class="sourceLine" id="cb7-235" data-line-number="235"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-236" data-line-number="236"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-237" data-line-number="237">NumericVector grad_mlogit(NumericVector val, SEXP ptr,</a>
<a class="sourceLine" id="cb7-238" data-line-number="238">                          <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb7-239" data-line-number="239">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-240" data-line-number="240"></a>
<a class="sourceLine" id="cb7-241" data-line-number="241">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb7-242" data-line-number="242">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb7-243" data-line-number="243">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_mlogit: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb7-244" data-line-number="244"></a>
<a class="sourceLine" id="cb7-245" data-line-number="245">  NumericVector grad(val.size());</a>
<a class="sourceLine" id="cb7-246" data-line-number="246">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb7-247" data-line-number="247">  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</a>
<a class="sourceLine" id="cb7-248" data-line-number="248"></a>
<a class="sourceLine" id="cb7-249" data-line-number="249">  <span class="cf">return</span> grad;</a>
<a class="sourceLine" id="cb7-250" data-line-number="250">}</a>
<a class="sourceLine" id="cb7-251" data-line-number="251"></a>
<a class="sourceLine" id="cb7-252" data-line-number="252"><span class="co">/***</span></a>
<a class="sourceLine" id="cb7-253" data-line-number="253"><span class="co"> returns the current Hessian approximation.</span></a>
<a class="sourceLine" id="cb7-254" data-line-number="254"><span class="co"> @param ptr returned object from get_mlogit_optimizer.</span></a>
<a class="sourceLine" id="cb7-255" data-line-number="255"><span class="co"> */</span></a>
<a class="sourceLine" id="cb7-256" data-line-number="256"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb7-257" data-line-number="257">NumericMatrix get_Hess_approx_mlogit(SEXP ptr){</a>
<a class="sourceLine" id="cb7-258" data-line-number="258">  XPtr&lt;mlogit_topim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb7-259" data-line-number="259"></a>
<a class="sourceLine" id="cb7-260" data-line-number="260">  NumericMatrix out(optim-&gt;n_par, optim-&gt;n_par);</a>
<a class="sourceLine" id="cb7-261" data-line-number="261">  optim-&gt;get_hess(&amp;out[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb7-262" data-line-number="262"></a>
<a class="sourceLine" id="cb7-263" data-line-number="263">  <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb7-264" data-line-number="264">}</a></code></pre></div>
<p>The <code>PSQN::R_reporter</code> class ensures that output will be printed when one passes a <code>trace</code> argument which is greater than zero. The <code>PSQN::R_interrupter</code> class ensures that the user can interrupt the computation. These two classes can be replaced with custom classes<br />
if one wants to and provide another implementation. See the source code of this package for the required members.</p>
<p>We can use the code by calling <code>Rcpp::sourceCpp</code> to compile the code:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">library</span>(Rcpp)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;mlogit-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</a></code></pre></div>
<p>Then we can create a pointer to an optimizer and check that it yields the correct value and gradient like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">optimizer &lt;-<span class="st"> </span><span class="kw">get_mlogit_optimizer</span>(sim_dat, <span class="dt">max_threads =</span> 4L)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">eval_integrand</span>(true_params), </a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)))</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">library</span>(numDeriv)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">gr_num &lt;-<span class="st"> </span><span class="kw">grad</span>(</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="cf">function</span>(par) <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L), </a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  true_params)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">gr_opt &lt;-<span class="st"> </span><span class="kw">grad_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb9-12" data-line-number="12"></a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(gr_num, gr_opt, <span class="dt">tolerance =</span> <span class="fl">1e-5</span>, </a>
<a class="sourceLine" id="cb9-14" data-line-number="14">                    <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">          <span class="co"># also check the function value!</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">          <span class="kw">all.equal</span>(<span class="kw">attr</span>(gr_opt, <span class="st">&quot;value&quot;</span>), </a>
<a class="sourceLine" id="cb9-17" data-line-number="17">                    <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, </a>
<a class="sourceLine" id="cb9-18" data-line-number="18">                                <span class="dt">n_threads =</span> 2L)))</a></code></pre></div>
<p>We can now use the BFGS implementation in the <code>optim</code> function to compare with like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">optim_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="kw">optim</span>(</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb10-4" data-line-number="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb10-6" data-line-number="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">reltol =</span> <span class="fl">1e-8</span>))</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">bfgs_res &lt;-<span class="st"> </span><span class="kw">optim_func</span>(start_val)</a></code></pre></div>
<p>We then use the quasi-Newton method like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L, <span class="dt">use_bfgs =</span> <span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                      <span class="dt">opt_private =</span> <span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  rel_eps &lt;-<span class="st"> </span><span class="fl">1e-8</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="cf">if</span>(opt_private){</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    <span class="co"># it may be useful to fix the global parameters and optimize the </span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">    <span class="co"># private parameters to get starting values. This is very fast as each </span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="co"># set of parameters can be optimized separately</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    par &lt;-<span class="st"> </span><span class="kw">optim_mlogit_private</span>(</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">      <span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="kw">sqrt</span>(rel_eps), <span class="dt">max_it =</span> <span class="dv">100</span>, </a>
<a class="sourceLine" id="cb11-11" data-line-number="11">      <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2)</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  }</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  <span class="kw">optim_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> rel_eps, </a>
<a class="sourceLine" id="cb11-14" data-line-number="14">               <span class="dt">max_it =</span> 1000L, <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </a>
<a class="sourceLine" id="cb11-15" data-line-number="15">               <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace, <span class="dt">use_bfgs =</span> use_bfgs)</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb11-17" data-line-number="17"></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val)</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="co"># using SR1 updates</span></a>
<a class="sourceLine" id="cb11-21" data-line-number="21">psqn_res_sr1 &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="kw">all.equal</span>(psqn_res_sr1<span class="op">$</span>value, psqn_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24"></a>
<a class="sourceLine" id="cb11-25" data-line-number="25"><span class="co"># w/ different starting values</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">psqn_res_diff_start &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(start_val, <span class="dt">opt_private =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb11-27" data-line-number="27"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, psqn_res_diff_start<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb11-28" data-line-number="28"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>The <code>counts</code> element contains the number of function evaluations, gradient evaluations, and the total number of conjugate gradient iterations:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">psqn_res<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">#&gt; function gradient     n_cg </span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="co">#&gt;       13       12       20</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co"># it is the same as we got from R</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>par, R_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, R_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co"># compare with optim</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">bfgs_res<span class="op">$</span>counts</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="co">#&gt; function gradient </span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co">#&gt;       63       19</span></a></code></pre></div>
<p>We can compare the solution with the solution from <code>optim</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">all.equal</span>(bfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co">#&gt; [1] &quot;Mean relative difference: 7.81e-05&quot;</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw">all.equal</span>(psqn_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value, <span class="dt">tolerance =</span> <span class="fl">1e-8</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>bfgs_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="co">#&gt; [1] -5.61e-06</span></a></code></pre></div>
<p>The <code>optim_mlogit</code> takes fewer iterations possibly because we quicker get a good approximation of the Hessian. Furthermore, we only take <code>psqn_res$counts[&quot;n_cg&quot;]</code>, 20, conjugate gradient iterations. This in contrast to the worst case scenario where we make <code>length(start_val)</code>, 3205, iterations for just one iteration of the quasi-Newton method! We can also compare with the limited memory BFGS minimizer from the <code>lbfgsb3c</code> package:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">library</span>(lbfgsb3c)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">lbfgsb3c_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">lbfgsb3c</span>(<span class="dt">par =</span> par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb14-4" data-line-number="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">factr =</span> <span class="fl">1e-8</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>, <span class="dt">maxit =</span> 1000L))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">lbfgsb3c_res &lt;-<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val)</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"></a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="co">#&gt; [1] &quot;Mean relative difference: 1.72e-05&quot;</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13"><span class="kw">all.equal</span>(lbfgsb3c_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgsb3c_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="co">#&gt; [1] 2.22e-06</span></a></code></pre></div>
<p>We can also compare with the limited memory BFGS minimizer from the <code>lbfgs</code> package:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">library</span>(lbfgs)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">lbfgs_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">lbfgs</span>(<span class="dt">vars =</span> par, <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb15-4" data-line-number="4">      <span class="kw">eval_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="cf">function</span>(par) </a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> n_threads), </a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    <span class="dt">invisible =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">lbfgs_res &lt;-<span class="st"> </span><span class="kw">lbfgs_func</span>(start_val)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"></a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>par, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"><span class="co">#&gt; [1] &quot;Mean relative difference: 1.83e-05&quot;</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="kw">all.equal</span>(lbfgs_res<span class="op">$</span>value, bfgs_res<span class="op">$</span>value)</a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">psqn_res<span class="op">$</span>value <span class="op">-</span><span class="st"> </span>lbfgs_res<span class="op">$</span>value</a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="co">#&gt; [1] 2.21e-06</span></a></code></pre></div>
<p>We can get the Hessian approximation by calling the <code>get_Hess_approx_mlogit</code> function we declared after calling the optimizer:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">aprox_hes &lt;-<span class="st"> </span><span class="kw">get_Hess_approx_mlogit</span>(<span class="dt">ptr =</span> optimizer)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">dim</span>(aprox_hes) <span class="co"># quite large; requires a lot of memory</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">#&gt; [1] 3205 3205</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co"># create a plot like before. Black entries are non-zero</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(.<span class="dv">5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>, <span class="fl">.5</span>))</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">idx &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">min</span>(<span class="dv">1000</span>, <span class="kw">NROW</span>(aprox_hes))</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">aprox_hes &lt;-<span class="st"> </span>aprox_hes[idx, idx] <span class="co"># reduce dimension to plot quickly</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">image</span>(<span class="kw">abs</span>(aprox_hes[, <span class="kw">NCOL</span>(aprox_hes)<span class="op">:</span><span class="dv">1</span>]) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="dt">xaxt =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">yaxt =</span> <span class="st">&quot;n&quot;</span>,</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">      <span class="dt">col =</span> <span class="kw">gray.colors</span>(2L, <span class="dv">1</span>, <span class="dv">0</span>))</a></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAqAAAAGACAMAAABFpiBcAAAAFVBMVEUAAAAaGhoiIiJFRUXd3d3l5eX///9ED91oAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAHu0lEQVR4nO3Y645UtxaF0U4Ifv9HPiekBQ1dVb0vvkzbY/wDCan2Wp9si7cCwd5G/wB4RaBEEyjRBEo0gRJNoEQTKNEESrRfgX77G0J8exDoX2/E+Gf0Dxjsr6eBNj6w4QiBEu1ZoP//s0YZ73mgRaOMJ1CivQz037+VKCN9FahjlKEESrSvAy0aZZxDgRZvUQYRKNGOBuqeZ4jjgRbHKP0JlGinAnXP09vJQItG6ep8oMVVTz8CJdqlQN3z9HIx0OIYpQuBEu16oO55OrgTaNEorQmUaA8D/T7il8Bn32+eoP/9S8corQiUaDUCLf7PiVYqBeoYpQ2BEq1aoEWjNFAz0OItSm0CJVrlQN3z1FU90KJRKmoRaHHVU4tAidYoUPc8dTQLtDhGqUCgRGsZqHue29oGWjTKPQIlWvNAi7coN/QI1DHKZQIlWp9Ai3uea7oF6hjlCoESrWOgRaOc1jfQ4i3KOd0DdYxyhkCJNiDQ4p7nsDGBOkY5SKBEGxVo0ShHDAy0eIvyJYESbWyg7nm+MDrQolFeESjRAgIt3qI8lRGoY5QnBEq0lECLe55HggJ1jPKZQIkWFWjRKH9IC7R4i/JRYKCOUX4RKNEiAy3ued6lBuoY5QeBEi030KJRwgMt3qLbEyjR0gN1z28uP9DiGN2ZQIk2RaDu+X1NEmjR6KYESrR5Ai3eojuaKlDH6H4ESrTJAi0a3cx8gRZv0Z1MGahjdB8CJdqkgRb3/CbmDdQxugWBEm3mQItG1zd5oMVbdHECJdr8gbrnl7ZCoMUxui6BEm2RQN3zq1om0KLRJQmUaCsFWrxF17NYoI7R1SwXaHGMLkWgRFsxUPf8QtYMtGh0FQIl2rKBFm/RJawcqGN0AQIl2tqBFo3ObvlAi7fo1ARKtB0Cdc9PbI9Ai2N0VgIl2jaBuufntFGgRaMTEijR9gq0eIvOZrtAHaNz2TDQ4hidiECJtmeg7vlp7Bpo0egcBEq0jQMt3qIT2DtQx2g8gW7zqXPaPdDins8m0OIYTSbQItBkAv3Php88B4H+tOVHxxPoT1t+dDyBfrDrdycT6O82/vRMAv3dxp+eSaCfbP3xcQT6wO7fn0Sgj5lACIE+ZgIhBPqMIUQQ6AvmMJ5AXzCH8QT6mkkMJtCvGMZQAv2KYQwl0AOMYxyBHmIiowj0EBMZRaBHGcoQAj3BWPoT6AnG0p9ATzGZ3gR6ltl0JdDzjKcjgZ5nPB0J9BIT6kWgV5lRFwK9yoy6EOh1xtSBQG8xqdYEeotJtSbQu8yqKYHeZ1wNCfQ+42pIoFUYWCsCrcTM2hBoJWbWhkDrMbYGBFqVwdUm0KoMrjaBVmZ2dQm0PtOrSKAtGGA1Am3BAKsRaCNmWIdA2zHFCgTajilWINCWDPI2gTZmlPcItDGjvEegzZnmHQLtwUAvE2gPBnqZQDsx0msE2o2pXiHQbkz1CoH2ZLCnCbQzoz1HoN2Z7hkC7c50zxDoCOZ7mEDHMOKDBDqGER8k0GFM+QiBjmTOXxLoSOb8JYGOZdRfEOhwhv2KQIcz7FcEGsC8nxNoBiN/QqAZjPwJgcYw9EcEGsTcPxNoEHP/TKBZTP4PAk1j+L8RaCDz/0Wggcz/F4FmsoF3Ak1lCT8INJUl/CDQYPYg0HTbL0Kg2bZfhEDTbb4MgU5g53UIdAI7r0OgU9h3IwKdxaZLEegsNl2KQCey41oEOpX9NiPQqey3GYHOZrPdCHQ+W61HoFPaZ0MCndI+GxLorDbZkUDntcWaBDqvLdYk0KmtvyiBTm71XQl0cqvvSqDzW3pdAl3CugsT6BLWXZhAF7HqzgS6jiXXJtB1LLk2gS5lvcUJdDGr7U6g61lqewJdz1LbE+iKFlqgQBe1yg4fBvp9xC+Bz747Qde1xBYFurIFFinQlS2wSIEubvZVCnR5c29ToMube5sC3cHECxXoJmZdqUA3MetKBbqNObcq0J1MuFeB7mTCvQp0L9OtVqDbmWu7At3RRPsV6I4m2q9A9zTNigW6rTm2LNBtzbFlge5sgj0LdG/xqxbo3uJXLdDtZS9boEQfowJFoMSLXblAeZe5dIHyLnPpAuWnxL0LlI/iNi9QPorbvED5XdjyBconSfsXKI/EFCBQHokpQKA8FhKBQHkqIQOB8lRCBgLlhfElCJTXBscgUF4TKOlG5iBQDhhXhEA5QKCkGxSFQDlsRBYC5TCBEq5/GQLlnM5tCJSzuuYhUM4SKOn6FSJQrunUiEC5RqCE65KJQLmhfSgC5QaBEq51KwLlrqa5CJS7BEq6dsEIlCpaNSNQqhAo6ZpUI1DqaRCOQKlHoKSr3Y5Aqa1qPQKlvooBCZT6BEq6Wg0JlFaqVCRQWhEo4SqEJFCaupuSQGlKoIS7V5NAae9GUAKlPYGS7mpSAqWTa1UJlE4ESroLXQmUnk6nJVA6O1eXQOlMoKQ70ZdAGeFwYgJlBIGS7lhkAmWYI50JlGEESrovUxMog72OTaAMJlDCvepNoCR4mpxASSBQ0j2OTqDEeNSdQIkhUNJ9Kk+gZPkjPoES52N/AiWOQEn3s0CBkuk9QoGSSaCk+zdDgYb7Z/QPGOrt7VGg3/6GEN8eBAqBBEo0gRJNoEQTKNEESjSBEk2gRBMo0f4H6Hw//A2MIj0AAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="cf">if</span>(<span class="ot">FALSE</span>){</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="co"># only feasible for smaller problem</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  hess_true &lt;-<span class="st"> </span><span class="kw">jacobian</span>(</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    <span class="cf">function</span>(par) <span class="kw">grad_mlogit</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer), </a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  </a>
<a class="sourceLine" id="cb17-7" data-line-number="7">  <span class="co"># should not hold exactly! Might not be that good of an approximation.</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">  <span class="kw">all.equal</span>(aprox_hes, hess_true) </a>
<a class="sourceLine" id="cb17-9" data-line-number="9">}</a></code></pre></div>
<p>The true Hessian is very sparse. Finally, here is a benchmark to compare the computation time:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  <span class="st">`</span><span class="dt">   optim BFGS (2 threads)</span><span class="st">`</span>  =<span class="st"> </span><span class="kw">optim_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="st">`</span><span class="dt">         lbfgs (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="st">`</span><span class="dt">         lbfgs(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="st">`</span><span class="dt">         lbfgs(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgs_func</span>   (start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="st">`</span><span class="dt">      lbfgsb3c (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="st">`</span><span class="dt">      lbfgsb3c(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">  <span class="st">`</span><span class="dt">      lbfgsb3c(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">lbfgsb3c_func</span>(start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">  <span class="st">`</span><span class="dt">       psqn (R; 1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">  <span class="st">`</span><span class="dt">       psqn(R; 2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">r_psqn_func</span>  (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">  <span class="st">`</span><span class="dt">     psqn (1 thread, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb18-12" data-line-number="12">                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">  <span class="st">`</span><span class="dt">     psqn(2 threads, SR1)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L, </a>
<a class="sourceLine" id="cb18-14" data-line-number="14">                                              <span class="dt">use_bfgs =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">  <span class="st">`</span><span class="dt">psqn  (1 thread, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 1L, </a>
<a class="sourceLine" id="cb18-16" data-line-number="16">                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  <span class="st">`</span><span class="dt">psqn (2 threads, opt pri.)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>   (start_val, <span class="dt">n_threads =</span> 2L, </a>
<a class="sourceLine" id="cb18-18" data-line-number="18">                                              <span class="dt">opt_private =</span> <span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">  <span class="st">`</span><span class="dt">          psqn (1 thread)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 1L),</a>
<a class="sourceLine" id="cb18-20" data-line-number="20">  <span class="st">`</span><span class="dt">          psqn(2 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 2L),</a>
<a class="sourceLine" id="cb18-21" data-line-number="21">  <span class="st">`</span><span class="dt">          psqn(4 threads)</span><span class="st">`</span> =<span class="st"> </span><span class="kw">psqn_func</span>    (start_val, <span class="dt">n_threads =</span> 4L),</a>
<a class="sourceLine" id="cb18-22" data-line-number="22">  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb18-23" data-line-number="23"><span class="co">#&gt; Warning: Some expressions had a GC in every iteration; so filtering is disabled.</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24"><span class="co">#&gt; # A tibble: 16 x 6</span></a>
<a class="sourceLine" id="cb18-25" data-line-number="25"><span class="co">#&gt;    expression                      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb18-26" data-line-number="26"><span class="co">#&gt;    &lt;bch:expr&gt;                 &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27"><span class="co">#&gt;  1    optim BFGS (2 threads)     1.13s    1.13s     0.882   42.41MB    0.705</span></a>
<a class="sourceLine" id="cb18-28" data-line-number="28"><span class="co">#&gt;  2          lbfgs (1 thread)  251.66ms 252.93ms     3.94    10.07MB    0.985</span></a>
<a class="sourceLine" id="cb18-29" data-line-number="29"><span class="co">#&gt;  3          lbfgs(2 threads)  136.38ms 136.89ms     7.22     9.99MB    0.976</span></a>
<a class="sourceLine" id="cb18-30" data-line-number="30"><span class="co">#&gt;  4          lbfgs(4 threads)   92.23ms  94.17ms    10.5     11.93MB    1.58 </span></a>
<a class="sourceLine" id="cb18-31" data-line-number="31"><span class="co">#&gt;  5       lbfgsb3c (1 thread)  298.11ms 306.41ms     3.19    22.71MB    0.997</span></a>
<a class="sourceLine" id="cb18-32" data-line-number="32"><span class="co">#&gt;  6       lbfgsb3c(2 threads)  180.32ms  180.9ms     5.14    25.25MB    1.58 </span></a>
<a class="sourceLine" id="cb18-33" data-line-number="33"><span class="co">#&gt;  7       lbfgsb3c(4 threads)   78.02ms  80.27ms    12.3     18.98MB    3.18 </span></a>
<a class="sourceLine" id="cb18-34" data-line-number="34"><span class="co">#&gt;  8        psqn (R; 1 thread)  168.67ms 177.44ms     5.49     6.78MB   12.0  </span></a>
<a class="sourceLine" id="cb18-35" data-line-number="35"><span class="co">#&gt;  9        psqn(R; 2 threads)  179.28ms 186.24ms     5.29     6.78MB   10.2  </span></a>
<a class="sourceLine" id="cb18-36" data-line-number="36"><span class="co">#&gt; 10      psqn (1 thread, SR1)   37.45ms  37.49ms    26.7     27.58KB    0    </span></a>
<a class="sourceLine" id="cb18-37" data-line-number="37"><span class="co">#&gt; 11      psqn(2 threads, SR1)   19.04ms  19.35ms    51.0     27.58KB    0    </span></a>
<a class="sourceLine" id="cb18-38" data-line-number="38"><span class="co">#&gt; 12 psqn  (1 thread, opt pri.)  24.12ms  24.77ms    40.2     60.23KB    0    </span></a>
<a class="sourceLine" id="cb18-39" data-line-number="39"><span class="co">#&gt; 13 psqn (2 threads, opt pri.)  13.27ms  13.46ms    73.9     55.16KB    0    </span></a>
<a class="sourceLine" id="cb18-40" data-line-number="40"><span class="co">#&gt; 14           psqn (1 thread)   18.29ms  18.36ms    53.7     27.58KB    0.199</span></a>
<a class="sourceLine" id="cb18-41" data-line-number="41"><span class="co">#&gt; 15           psqn(2 threads)   10.13ms  10.31ms    96.8     27.58KB    0    </span></a>
<a class="sourceLine" id="cb18-42" data-line-number="42"><span class="co">#&gt; 16           psqn(4 threads)       6ms   6.19ms   161.      27.58KB    0</span></a></code></pre></div>
<p>We see a large reduction. To be fair, we can use the C interface for the limited-memory BFGS methods to avoid re-allocating the gradient at every iteration. This will reduce their computation time. The R version of the quasi-Newton method is slower mainly as the R version to evaluate the log of the integrand and its derivative is slower than the version used by all the other methods. We can illustrate this by comparing with the computation time with the <code>eval_integrand</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  <span class="st">`</span><span class="dt">  R</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_integrand</span>(true_params), </a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="st">`</span><span class="dt">C++</span><span class="st">`</span> =<span class="st"> </span><span class="kw">eval_mlogit</span>(<span class="dt">val =</span> true_params, <span class="dt">ptr =</span> optimizer, <span class="dt">n_threads =</span> 1L), </a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="dt">min_iterations =</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="co">#&gt; # A tibble: 2 x 6</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8"><span class="co">#&gt; 1   R          2.94ms   3.26ms      280.  139.17KB     11.0</span></a>
<a class="sourceLine" id="cb19-9" data-line-number="9"><span class="co">#&gt; 2 C++        573.83µs 576.78µs     1705.    2.49KB      0</span></a></code></pre></div>
<p>There is a big difference. Moreover, there is an overhead with repeatedly going back and forward between R and C++. A fair comparison would use an R implementation for all methods.</p>
</div>
<div id="polynomial-example" class="section level3">
<h3>Polynomial Example</h3>
<p>We consider the following trivial (regression) example as there is an explicit solution to compare with:</p>
<p><span class="math display">\[
\begin{align*}
\mathcal G &amp;=\{1,\dots, p\} \\
\mathcal G  \cap \mathcal P_i &amp;= \emptyset \\
\mathcal P_j \cap \mathcal P_i &amp;= \emptyset, \qquad i\neq j \\
\mathcal I_i &amp;\in \{1,\dots, p\}^{\lvert\mathcal P_i\rvert} \\
f(\vec x) &amp;= (\vec x_{\mathcal G} - \vec\mu_{\mathcal G})^\top
  (\vec x_{\mathcal G} - \vec\mu_{\mathcal G}) +
  \sum_{i = 1}^n 
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i})^\top
  (\vec x_{\mathcal P_i} - \vec\mu_{\mathcal P_i} - 
   \mat\Psi_i\vec x_{\mathcal I_i}) 
\end{align*}
\]</span> This is not because the problem is interesting per se but it is meant as another illustration. R code to simulate from this model is given below:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co"># simulate the data</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">set.seed</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">n_global &lt;-<span class="st"> </span>10L</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">n_clusters &lt;-<span class="st"> </span>50L</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">mu_global &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_global)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">idx_start &lt;-<span class="st"> </span>n_global</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">cluster_dat &lt;-<span class="st"> </span><span class="kw">replicate</span>(n_clusters, {</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">  n_members &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n_global, 1L)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  g_idx &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">sample.int</span>(n_global, n_members))</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">  mu_cluster &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n_members)</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  Psi &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n_members <span class="op">*</span><span class="st"> </span>n_members), n_members, n_members)</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">  </a>
<a class="sourceLine" id="cb20-15" data-line-number="15">  out &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">idx =</span> idx_start <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span>n_members, <span class="dt">g_idx =</span> g_idx,</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">              <span class="dt">mu_cluster =</span> mu_cluster, <span class="dt">Psi =</span> Psi)</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">  idx_start &lt;&lt;-<span class="st"> </span>idx_start <span class="op">+</span><span class="st"> </span>n_members</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">  out</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">}, <span class="dt">simplify =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb20-20" data-line-number="20"></a>
<a class="sourceLine" id="cb20-21" data-line-number="21"><span class="co"># assign matrices needed for comparisons</span></a>
<a class="sourceLine" id="cb20-22" data-line-number="22"><span class="kw">library</span>(Matrix)</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">M &lt;-<span class="st"> </span><span class="kw">diag</span>(idx_start)</a>
<a class="sourceLine" id="cb20-24" data-line-number="24"><span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat)</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">  M[cl<span class="op">$</span>idx, cl<span class="op">$</span>g_idx] &lt;-<span class="st"> </span><span class="op">-</span>cl<span class="op">$</span>Psi</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">M &lt;-<span class="st"> </span><span class="kw">as</span>(M, <span class="st">&quot;dgCMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb20-27" data-line-number="27"></a>
<a class="sourceLine" id="cb20-28" data-line-number="28"><span class="co"># Assign two R functions to evaluate the objective function. There are two </span></a>
<a class="sourceLine" id="cb20-29" data-line-number="29"><span class="co"># versions of the function to show that we get the same with one being </span></a>
<a class="sourceLine" id="cb20-30" data-line-number="30"><span class="co"># closer to the shown equation</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">fn_one &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb20-32" data-line-number="32">  delta &lt;-<span class="st"> </span>par[<span class="dv">1</span><span class="op">:</span>n_global] <span class="op">-</span><span class="st"> </span>mu_global</a>
<a class="sourceLine" id="cb20-33" data-line-number="33">  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb20-34" data-line-number="34">  <span class="cf">for</span>(cl <span class="cf">in</span> cluster_dat){</a>
<a class="sourceLine" id="cb20-35" data-line-number="35">    delta &lt;-<span class="st"> </span><span class="kw">drop</span>(par[cl<span class="op">$</span>idx] <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>mu_cluster <span class="op">-</span><span class="st"> </span>cl<span class="op">$</span>Psi <span class="op">%*%</span><span class="st"> </span>par[cl<span class="op">$</span>g_idx])</a>
<a class="sourceLine" id="cb20-36" data-line-number="36">    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb20-37" data-line-number="37">  }</a>
<a class="sourceLine" id="cb20-38" data-line-number="38">  out</a>
<a class="sourceLine" id="cb20-39" data-line-number="39">}</a>
<a class="sourceLine" id="cb20-40" data-line-number="40">fn_two &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb20-42" data-line-number="42">  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">  <span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb20-44" data-line-number="44">}</a>
<a class="sourceLine" id="cb20-45" data-line-number="45"></a>
<a class="sourceLine" id="cb20-46" data-line-number="46">tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</a>
<a class="sourceLine" id="cb20-47" data-line-number="47"><span class="kw">all.equal</span>(<span class="kw">fn_one</span>(tmp), <span class="kw">fn_two</span>(tmp)) <span class="co"># we get the same w/ the two</span></a>
<a class="sourceLine" id="cb20-48" data-line-number="48"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb20-49" data-line-number="49">fn &lt;-<span class="st"> </span>fn_two</a>
<a class="sourceLine" id="cb20-50" data-line-number="50"><span class="kw">rm</span>(fn_one, fn_two, tmp)</a>
<a class="sourceLine" id="cb20-51" data-line-number="51"></a>
<a class="sourceLine" id="cb20-52" data-line-number="52"><span class="co"># assign gradient function</span></a>
<a class="sourceLine" id="cb20-53" data-line-number="53">gr &lt;-<span class="st"> </span><span class="cf">function</span>(par, ...){</a>
<a class="sourceLine" id="cb20-54" data-line-number="54">  mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb20-55" data-line-number="55">  <span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(M, <span class="kw">drop</span>(M <span class="op">%*%</span><span class="st"> </span>par <span class="op">-</span><span class="st"> </span>mu)))</a>
<a class="sourceLine" id="cb20-56" data-line-number="56">}</a>
<a class="sourceLine" id="cb20-57" data-line-number="57"></a>
<a class="sourceLine" id="cb20-58" data-line-number="58"><span class="co"># we can easily find the explicit solution</span></a>
<a class="sourceLine" id="cb20-59" data-line-number="59">mu &lt;-<span class="st"> </span><span class="kw">c</span>(mu_global, <span class="kw">unlist</span>(<span class="kw">sapply</span>(cluster_dat, <span class="st">&quot;[[&quot;</span>, <span class="st">&quot;mu_cluster&quot;</span>)))</a>
<a class="sourceLine" id="cb20-60" data-line-number="60">exp_res &lt;-<span class="st"> </span><span class="kw">drop</span>(<span class="kw">solve</span>(M, mu))</a>
<a class="sourceLine" id="cb20-61" data-line-number="61"><span class="kw">fn</span>(exp_res) <span class="co"># ~ zero as it should be</span></a>
<a class="sourceLine" id="cb20-62" data-line-number="62"><span class="co">#&gt; [1] 2.98e-29</span></a></code></pre></div>
<p>C++ code to work with this function is provided at <code>system.file(&quot;poly-ex.cpp&quot;, package = &quot;psqn&quot;)</code> with the package and given below:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">// see `mlogit-ex.cpp` for an example with more comments</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="co">// we will use openMP to perform the comptutation in parallel</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="co">// [[Rcpp::plugins(openmp, cpp11)]]</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="co">// we use RcppArmadillo to simplify the code</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="co">// [[Rcpp::depends(RcppArmadillo)]]</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="pp">#include </span><span class="im">&lt;RcppArmadillo.h&gt;</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="co">// [[Rcpp::depends(psqn)]]</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="pp">#include </span><span class="im">&quot;psqn.h&quot;</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="pp">#include </span><span class="im">&quot;psqn-reporter.h&quot;</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13"></a>
<a class="sourceLine" id="cb21-14" data-line-number="14"><span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</a>
<a class="sourceLine" id="cb21-15" data-line-number="15"></a>
<a class="sourceLine" id="cb21-16" data-line-number="16"><span class="co">/// simple function to avoid copying a vector. You can ignore this</span></a>
<a class="sourceLine" id="cb21-17" data-line-number="17"><span class="kw">inline</span> arma::vec vec_no_cp(<span class="dt">double</span> <span class="at">const</span> * x, <span class="dt">size_t</span> <span class="at">const</span> n_ele){</a>
<a class="sourceLine" id="cb21-18" data-line-number="18">  <span class="cf">return</span> arma::vec(<span class="kw">const_cast</span>&lt;<span class="dt">double</span> *&gt;(x), n_ele, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb21-20" data-line-number="20"></a>
<a class="sourceLine" id="cb21-21" data-line-number="21"><span class="kw">class</span> poly_func <span class="kw">final</span> : <span class="kw">public</span> PSQN::element_function {</a>
<a class="sourceLine" id="cb21-22" data-line-number="22">  <span class="co">/// global parameter indices</span></a>
<a class="sourceLine" id="cb21-23" data-line-number="23">  arma::uvec <span class="at">const</span> <span class="va">g_idx</span>;</a>
<a class="sourceLine" id="cb21-24" data-line-number="24">  <span class="co">/// centroid vector</span></a>
<a class="sourceLine" id="cb21-25" data-line-number="25">  arma::vec <span class="at">const</span> mu_cluster;</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">  <span class="co">/// matrix used to transform subset of global parameters</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27">  arma::mat <span class="at">const</span> Psi;</a>
<a class="sourceLine" id="cb21-28" data-line-number="28">  <span class="co">/// number of global parameters</span></a>
<a class="sourceLine" id="cb21-29" data-line-number="29">  <span class="dt">size_t</span> <span class="at">const</span> n_global;</a>
<a class="sourceLine" id="cb21-30" data-line-number="30">  <span class="co">/// global parameter centroid vector</span></a>
<a class="sourceLine" id="cb21-31" data-line-number="31">  arma::vec <span class="at">const</span> mu_global;</a>
<a class="sourceLine" id="cb21-32" data-line-number="32">  <span class="co">/**</span></a>
<a class="sourceLine" id="cb21-33" data-line-number="33"><span class="co">   true if this element function should compute the terms from the global</span></a>
<a class="sourceLine" id="cb21-34" data-line-number="34"><span class="co">   paramaters */</span></a>
<a class="sourceLine" id="cb21-35" data-line-number="35">  <span class="dt">bool</span> <span class="at">const</span> comp_global;</a>
<a class="sourceLine" id="cb21-36" data-line-number="36"></a>
<a class="sourceLine" id="cb21-37" data-line-number="37"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb21-38" data-line-number="38">  poly_func(List data, arma::vec <span class="at">const</span> &amp;mu_g, <span class="dt">bool</span> <span class="at">const</span> comp_global):</a>
<a class="sourceLine" id="cb21-39" data-line-number="39">  <span class="va">g_idx</span>     (as&lt;arma::uvec&gt;(data[<span class="st">&quot;g_idx&quot;</span>    ]) - <span class="dv">1L</span>),</a>
<a class="sourceLine" id="cb21-40" data-line-number="40">  mu_cluster(as&lt;arma::vec&gt;(data[<span class="st">&quot;mu_cluster&quot;</span>])     ),</a>
<a class="sourceLine" id="cb21-41" data-line-number="41">  Psi       (as&lt;arma::mat&gt;(data[<span class="st">&quot;Psi&quot;</span>       ])     ),</a>
<a class="sourceLine" id="cb21-42" data-line-number="42">  n_global(mu_g.n_elem),</a>
<a class="sourceLine" id="cb21-43" data-line-number="43">  mu_global(comp_global ? mu_g : arma::vec() ),</a>
<a class="sourceLine" id="cb21-44" data-line-number="44">  comp_global(comp_global)</a>
<a class="sourceLine" id="cb21-45" data-line-number="45">  { }</a>
<a class="sourceLine" id="cb21-46" data-line-number="46"></a>
<a class="sourceLine" id="cb21-47" data-line-number="47">  <span class="dt">size_t</span> global_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb21-48" data-line-number="48">    <span class="cf">return</span> n_global;</a>
<a class="sourceLine" id="cb21-49" data-line-number="49">  }</a>
<a class="sourceLine" id="cb21-50" data-line-number="50">  <span class="dt">size_t</span> private_dim() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb21-51" data-line-number="51">    <span class="cf">return</span> mu_cluster.n_elem;</a>
<a class="sourceLine" id="cb21-52" data-line-number="52">  }</a>
<a class="sourceLine" id="cb21-53" data-line-number="53"></a>
<a class="sourceLine" id="cb21-54" data-line-number="54">  <span class="dt">double</span> func(<span class="dt">double</span> <span class="at">const</span> *point) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb21-55" data-line-number="55">    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</a>
<a class="sourceLine" id="cb21-56" data-line-number="56">                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</a>
<a class="sourceLine" id="cb21-57" data-line-number="57">                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</a>
<a class="sourceLine" id="cb21-58" data-line-number="58"></a>
<a class="sourceLine" id="cb21-59" data-line-number="59">    <span class="co">// compute the function</span></a>
<a class="sourceLine" id="cb21-60" data-line-number="60">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb21-61" data-line-number="61">    out += arma::dot(delta, delta);</a>
<a class="sourceLine" id="cb21-62" data-line-number="62"></a>
<a class="sourceLine" id="cb21-63" data-line-number="63">    <span class="cf">if</span>(comp_global)</a>
<a class="sourceLine" id="cb21-64" data-line-number="64">      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</a>
<a class="sourceLine" id="cb21-65" data-line-number="65"></a>
<a class="sourceLine" id="cb21-66" data-line-number="66">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb21-67" data-line-number="67">  }</a>
<a class="sourceLine" id="cb21-68" data-line-number="68"></a>
<a class="sourceLine" id="cb21-69" data-line-number="69">  <span class="dt">double</span> grad</a>
<a class="sourceLine" id="cb21-70" data-line-number="70">  (<span class="dt">double</span> <span class="at">const</span> * point, <span class="dt">double</span> * gr) <span class="at">const</span> {</a>
<a class="sourceLine" id="cb21-71" data-line-number="71">    arma::vec <span class="at">const</span> x_glob = vec_no_cp(point           , n_global),</a>
<a class="sourceLine" id="cb21-72" data-line-number="72">                    x_priv = vec_no_cp(point + n_global, mu_cluster.n_elem),</a>
<a class="sourceLine" id="cb21-73" data-line-number="73">                     delta = x_priv - Psi * x_glob(<span class="va">g_idx</span>) - mu_cluster;</a>
<a class="sourceLine" id="cb21-74" data-line-number="74"></a>
<a class="sourceLine" id="cb21-75" data-line-number="75">    <span class="co">// create objects to write to for the gradient</span></a>
<a class="sourceLine" id="cb21-76" data-line-number="76">    <span class="bu">std::</span>fill(gr, gr + x_glob.n_elem, <span class="fl">0.</span>);</a>
<a class="sourceLine" id="cb21-77" data-line-number="77">    arma::vec d_glob(gr                , x_glob.n_elem, <span class="kw">false</span>),</a>
<a class="sourceLine" id="cb21-78" data-line-number="78">              d_priv(gr + x_glob.n_elem, x_priv.n_elem, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb21-79" data-line-number="79"></a>
<a class="sourceLine" id="cb21-80" data-line-number="80">    <span class="co">// compute the function and the gradient</span></a>
<a class="sourceLine" id="cb21-81" data-line-number="81">    <span class="dt">double</span> out(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb21-82" data-line-number="82">    out += arma::dot(delta, delta);</a>
<a class="sourceLine" id="cb21-83" data-line-number="83">    d_glob(<span class="va">g_idx</span>) -= <span class="dv">2</span> * Psi.t() * delta;</a>
<a class="sourceLine" id="cb21-84" data-line-number="84">    d_priv         = <span class="dv">2</span> * delta;</a>
<a class="sourceLine" id="cb21-85" data-line-number="85"></a>
<a class="sourceLine" id="cb21-86" data-line-number="86">    <span class="cf">if</span>(comp_global){</a>
<a class="sourceLine" id="cb21-87" data-line-number="87">      out += arma::dot(x_glob - mu_global, x_glob - mu_global);</a>
<a class="sourceLine" id="cb21-88" data-line-number="88">      d_glob += <span class="fl">2.</span> * x_glob;</a>
<a class="sourceLine" id="cb21-89" data-line-number="89">      d_glob -= <span class="dv">2</span> * mu_global;</a>
<a class="sourceLine" id="cb21-90" data-line-number="90">    }</a>
<a class="sourceLine" id="cb21-91" data-line-number="91"></a>
<a class="sourceLine" id="cb21-92" data-line-number="92">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb21-93" data-line-number="93">  }</a>
<a class="sourceLine" id="cb21-94" data-line-number="94"></a>
<a class="sourceLine" id="cb21-95" data-line-number="95">  <span class="dt">bool</span> thread_safe() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb21-96" data-line-number="96">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb21-97" data-line-number="97">  }</a>
<a class="sourceLine" id="cb21-98" data-line-number="98">};</a>
<a class="sourceLine" id="cb21-99" data-line-number="99"></a>
<a class="sourceLine" id="cb21-100" data-line-number="100"><span class="kw">using</span> poly_optim = PSQN::optimizer&lt;poly_func, PSQN::R_reporter,</a>
<a class="sourceLine" id="cb21-101" data-line-number="101">                                   PSQN::R_interrupter&gt;;</a>
<a class="sourceLine" id="cb21-102" data-line-number="102"></a>
<a class="sourceLine" id="cb21-103" data-line-number="103"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb21-104" data-line-number="104">SEXP get_poly_optimizer(List data, arma::vec <span class="at">const</span> &amp;mu_global,</a>
<a class="sourceLine" id="cb21-105" data-line-number="105">                        <span class="dt">unsigned</span> <span class="at">const</span> max_threads){</a>
<a class="sourceLine" id="cb21-106" data-line-number="106">  <span class="dt">size_t</span> <span class="at">const</span> n_elem_funcs = data.size();</a>
<a class="sourceLine" id="cb21-107" data-line-number="107">  <span class="bu">std::</span>vector&lt;poly_func&gt; funcs;</a>
<a class="sourceLine" id="cb21-108" data-line-number="108">  funcs.reserve(n_elem_funcs);</a>
<a class="sourceLine" id="cb21-109" data-line-number="109">  <span class="dt">bool</span> comp_global(<span class="kw">true</span>);</a>
<a class="sourceLine" id="cb21-110" data-line-number="110">  <span class="cf">for</span>(<span class="kw">auto</span> dat : data){</a>
<a class="sourceLine" id="cb21-111" data-line-number="111">    funcs.emplace_back(List(dat), mu_global, comp_global);</a>
<a class="sourceLine" id="cb21-112" data-line-number="112">    comp_global = <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb21-113" data-line-number="113">  }</a>
<a class="sourceLine" id="cb21-114" data-line-number="114"></a>
<a class="sourceLine" id="cb21-115" data-line-number="115">  <span class="co">// create an XPtr to the object we will need</span></a>
<a class="sourceLine" id="cb21-116" data-line-number="116">  XPtr&lt;poly_optim&gt;ptr(<span class="kw">new</span> poly_optim(funcs, max_threads));</a>
<a class="sourceLine" id="cb21-117" data-line-number="117"></a>
<a class="sourceLine" id="cb21-118" data-line-number="118">  <span class="co">// return the pointer to be used later</span></a>
<a class="sourceLine" id="cb21-119" data-line-number="119">  <span class="cf">return</span> ptr;</a>
<a class="sourceLine" id="cb21-120" data-line-number="120">}</a>
<a class="sourceLine" id="cb21-121" data-line-number="121"></a>
<a class="sourceLine" id="cb21-122" data-line-number="122"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb21-123" data-line-number="123">List opti<span class="va">m_poly</span></a>
<a class="sourceLine" id="cb21-124" data-line-number="124">  (NumericVector val, SEXP ptr, <span class="dt">double</span> <span class="at">const</span> rel_eps, <span class="dt">unsigned</span> <span class="at">const</span> max_it,</a>
<a class="sourceLine" id="cb21-125" data-line-number="125">   <span class="dt">unsigned</span> <span class="at">const</span> n_threads, <span class="dt">double</span> <span class="at">const</span> c1,</a>
<a class="sourceLine" id="cb21-126" data-line-number="126">   <span class="dt">double</span> <span class="at">const</span> c2, <span class="dt">bool</span> <span class="at">const</span> use_bfgs = <span class="kw">true</span>, <span class="dt">int</span> <span class="at">const</span> trace = <span class="dv">0L</span>,</a>
<a class="sourceLine" id="cb21-127" data-line-number="127">   <span class="dt">double</span> <span class="at">const</span> cg_tol = <span class="fl">.5</span>, <span class="dt">bool</span> <span class="at">const</span> strong_wolfe = <span class="kw">true</span>,</a>
<a class="sourceLine" id="cb21-128" data-line-number="128">   <span class="dt">size_t</span> <span class="at">const</span> max_cg = <span class="dv">0L</span>, <span class="dt">int</span> <span class="at">const</span> pre_method = <span class="dv">1L</span>){</a>
<a class="sourceLine" id="cb21-129" data-line-number="129">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb21-130" data-line-number="130"></a>
<a class="sourceLine" id="cb21-131" data-line-number="131">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb21-132" data-line-number="132">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb21-133" data-line-number="133">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;optim_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb21-134" data-line-number="134"></a>
<a class="sourceLine" id="cb21-135" data-line-number="135">  NumericVector par = clone(val);</a>
<a class="sourceLine" id="cb21-136" data-line-number="136">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb21-137" data-line-number="137">  <span class="kw">auto</span> res = optim-&gt;optim(&amp;par[<span class="dv">0</span>], rel_eps, max_it, c1, c2,</a>
<a class="sourceLine" id="cb21-138" data-line-number="138">                          use_bfgs, trace, cg_tol, strong_wolfe, max_cg,</a>
<a class="sourceLine" id="cb21-139" data-line-number="139">                          <span class="kw">static_cast</span>&lt;PSQN::precondition&gt;(pre_method));</a>
<a class="sourceLine" id="cb21-140" data-line-number="140">  NumericVector counts = NumericVector::create(</a>
<a class="sourceLine" id="cb21-141" data-line-number="141">    res.n_eval, res.n_grad,  res.n_cg);</a>
<a class="sourceLine" id="cb21-142" data-line-number="142">  counts.names() = CharacterVector::create(<span class="st">&quot;function&quot;</span>, <span class="st">&quot;gradient&quot;</span>, <span class="st">&quot;n_cg&quot;</span>);</a>
<a class="sourceLine" id="cb21-143" data-line-number="143"></a>
<a class="sourceLine" id="cb21-144" data-line-number="144">  <span class="dt">int</span> <span class="at">const</span> info = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(res.info);</a>
<a class="sourceLine" id="cb21-145" data-line-number="145">  <span class="cf">return</span> List::create(</a>
<a class="sourceLine" id="cb21-146" data-line-number="146">    _[<span class="st">&quot;par&quot;</span>] = par, _[<span class="st">&quot;value&quot;</span>] = res.value, _[<span class="st">&quot;info&quot;</span>] = info,</a>
<a class="sourceLine" id="cb21-147" data-line-number="147">      _[<span class="st">&quot;counts&quot;</span>] = counts,</a>
<a class="sourceLine" id="cb21-148" data-line-number="148">      _[<span class="st">&quot;convergence&quot;</span>] =  res.info == PSQN::info_code::converged);</a>
<a class="sourceLine" id="cb21-149" data-line-number="149">}</a>
<a class="sourceLine" id="cb21-150" data-line-number="150"></a>
<a class="sourceLine" id="cb21-151" data-line-number="151"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb21-152" data-line-number="152"><span class="dt">double</span> eval_poly(NumericVector val, SEXP ptr, <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb21-153" data-line-number="153">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb21-154" data-line-number="154"></a>
<a class="sourceLine" id="cb21-155" data-line-number="155">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb21-156" data-line-number="156">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb21-157" data-line-number="157">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;eval_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb21-158" data-line-number="158"></a>
<a class="sourceLine" id="cb21-159" data-line-number="159">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb21-160" data-line-number="160">  <span class="cf">return</span> optim-&gt;eval(&amp;val[<span class="dv">0</span>], <span class="kw">nullptr</span>, <span class="kw">false</span>);</a>
<a class="sourceLine" id="cb21-161" data-line-number="161">}</a>
<a class="sourceLine" id="cb21-162" data-line-number="162"></a>
<a class="sourceLine" id="cb21-163" data-line-number="163"><span class="co">// [[Rcpp::export]]</span></a>
<a class="sourceLine" id="cb21-164" data-line-number="164">NumericVector grad_poly(NumericVector val, SEXP ptr,</a>
<a class="sourceLine" id="cb21-165" data-line-number="165">                        <span class="dt">unsigned</span> <span class="at">const</span> n_threads){</a>
<a class="sourceLine" id="cb21-166" data-line-number="166">  XPtr&lt;poly_optim&gt; optim(ptr);</a>
<a class="sourceLine" id="cb21-167" data-line-number="167"></a>
<a class="sourceLine" id="cb21-168" data-line-number="168">  <span class="co">// check that we pass a parameter value of the right length</span></a>
<a class="sourceLine" id="cb21-169" data-line-number="169">  <span class="cf">if</span>(optim-&gt;n_par != <span class="kw">static_cast</span>&lt;<span class="dt">size_t</span>&gt;(val.size()))</a>
<a class="sourceLine" id="cb21-170" data-line-number="170">    <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument(<span class="st">&quot;grad_poly: invalid parameter size&quot;</span>);</a>
<a class="sourceLine" id="cb21-171" data-line-number="171"></a>
<a class="sourceLine" id="cb21-172" data-line-number="172">  NumericVector grad(val.size());</a>
<a class="sourceLine" id="cb21-173" data-line-number="173">  optim-&gt;set_n_threads(n_threads);</a>
<a class="sourceLine" id="cb21-174" data-line-number="174">  grad.attr(<span class="st">&quot;value&quot;</span>) = optim-&gt;eval(&amp;val[<span class="dv">0</span>], &amp;grad[<span class="dv">0</span>], <span class="kw">true</span>);</a>
<a class="sourceLine" id="cb21-175" data-line-number="175"></a>
<a class="sourceLine" id="cb21-176" data-line-number="176">  <span class="cf">return</span> grad;</a>
<a class="sourceLine" id="cb21-177" data-line-number="177">}</a></code></pre></div>
<p>We can <code>Rcpp::sourceCpp</code> the file and use the code like below to find the solution:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">library</span>(Rcpp)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">sourceCpp</span>(<span class="kw">system.file</span>(<span class="st">&quot;poly-ex.cpp&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;psqn&quot;</span>))</a>
<a class="sourceLine" id="cb22-3" data-line-number="3"></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="co"># get a pointer to C++ object</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">optimizer &lt;-<span class="st"> </span><span class="kw">get_poly_optimizer</span>(cluster_dat, <span class="dt">mu_global =</span> mu_global, </a>
<a class="sourceLine" id="cb22-6" data-line-number="6">                                <span class="dt">max_threads =</span> 2L)</a>
<a class="sourceLine" id="cb22-7" data-line-number="7"></a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="co"># we get the same function value and gradient</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">tmp &lt;-<span class="st"> </span><span class="kw">rnorm</span>(idx_start)</a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="kw">all.equal</span>(<span class="kw">fn</span>       (tmp), </a>
<a class="sourceLine" id="cb22-11" data-line-number="11">          <span class="kw">eval_poly</span>(tmp, optimizer, 1L))</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="kw">all.equal</span>(<span class="kw">gr</span>       (tmp), </a>
<a class="sourceLine" id="cb22-14" data-line-number="14">          <span class="kw">grad_poly</span>(tmp, optimizer, 1L), </a>
<a class="sourceLine" id="cb22-15" data-line-number="15">          <span class="dt">check.attributes =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb22-16" data-line-number="16"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"></a>
<a class="sourceLine" id="cb22-18" data-line-number="18"><span class="co"># run the optimization</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb22-20" data-line-number="20">                      <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L)</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">  <span class="kw">optim_poly</span>(<span class="dt">val =</span> par, <span class="dt">ptr =</span> optimizer, <span class="dt">rel_eps =</span> <span class="fl">1e-8</span>, <span class="dt">max_it =</span> 1000L, </a>
<a class="sourceLine" id="cb22-22" data-line-number="22">             <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, </a>
<a class="sourceLine" id="cb22-23" data-line-number="23">             <span class="dt">c2 =</span> c2, <span class="dt">trace =</span> trace)</a>
<a class="sourceLine" id="cb22-24" data-line-number="24"></a>
<a class="sourceLine" id="cb22-25" data-line-number="25">psqn_res &lt;-<span class="st"> </span><span class="kw">psqn_func</span>(<span class="kw">numeric</span>(idx_start))</a>
<a class="sourceLine" id="cb22-26" data-line-number="26"><span class="kw">all.equal</span>(exp_res, psqn_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb22-27" data-line-number="27"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
<p>A version using the R function <code>psqn</code> is:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co"># assign function to pass to psqn</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">r_func &lt;-<span class="st"> </span><span class="cf">function</span>(i, par, comp_grad){</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  dat &lt;-<span class="st"> </span>cluster_dat[[i]]</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  g_idx &lt;-<span class="st"> </span>dat<span class="op">$</span>g_idx</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  mu_cluster &lt;-<span class="st"> </span>dat<span class="op">$</span>mu_cluster</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  Psi &lt;-<span class="st"> </span>dat<span class="op">$</span>Psi</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  </a>
<a class="sourceLine" id="cb23-8" data-line-number="8">  <span class="cf">if</span>(<span class="kw">length</span>(par) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="co"># requested the dimension of the parameter</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    <span class="kw">return</span>(<span class="kw">c</span>(<span class="dt">global_dim =</span> <span class="kw">length</span>(mu_global), </a>
<a class="sourceLine" id="cb23-11" data-line-number="11">             <span class="dt">private_dim =</span> <span class="kw">length</span>(mu_cluster)))</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  </a>
<a class="sourceLine" id="cb23-13" data-line-number="13">  is_glob &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(mu_global)</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  x_glob &lt;-<span class="st"> </span>par[is_glob]</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  x_priv &lt;-<span class="st"> </span>par[<span class="op">-</span>is_glob]</a>
<a class="sourceLine" id="cb23-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb23-17" data-line-number="17">  delta &lt;-<span class="st"> </span><span class="kw">drop</span>(x_priv <span class="op">-</span><span class="st"> </span>Psi <span class="op">%*%</span><span class="st"> </span>x_glob[g_idx] <span class="op">-</span><span class="st"> </span>mu_cluster)</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">  </a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  out &lt;-<span class="st"> </span><span class="kw">drop</span>(delta <span class="op">%*%</span><span class="st"> </span>delta)</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">  <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L){</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">    delta_glob &lt;-<span class="st"> </span>x_glob <span class="op">-</span><span class="st"> </span>mu_global</a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    out &lt;-<span class="st"> </span>out <span class="op">+</span><span class="st"> </span><span class="kw">drop</span>(delta_glob <span class="op">%*%</span><span class="st"> </span>delta_glob)</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">  }</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">  </a>
<a class="sourceLine" id="cb23-25" data-line-number="25">  <span class="cf">if</span>(comp_grad){</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">    grad &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(mu_cluster) <span class="op">+</span><span class="st"> </span><span class="kw">length</span>(mu_global))</a>
<a class="sourceLine" id="cb23-27" data-line-number="27">    grad[g_idx] &lt;-<span class="st"> </span><span class="dv">-2</span> <span class="op">*</span><span class="st"> </span><span class="kw">drop</span>(<span class="kw">crossprod</span>(Psi, delta))</a>
<a class="sourceLine" id="cb23-28" data-line-number="28">    grad[<span class="op">-</span>is_glob] &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta</a>
<a class="sourceLine" id="cb23-29" data-line-number="29">    <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb23-30" data-line-number="30">      grad[is_glob] &lt;-<span class="st"> </span>grad[is_glob] <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta_glob</a>
<a class="sourceLine" id="cb23-31" data-line-number="31">    <span class="kw">attr</span>(out, <span class="st">&quot;grad&quot;</span>) &lt;-<span class="st"> </span>grad</a>
<a class="sourceLine" id="cb23-32" data-line-number="32">  }</a>
<a class="sourceLine" id="cb23-33" data-line-number="33">  </a>
<a class="sourceLine" id="cb23-34" data-line-number="34">  out</a>
<a class="sourceLine" id="cb23-35" data-line-number="35">}</a>
<a class="sourceLine" id="cb23-36" data-line-number="36"></a>
<a class="sourceLine" id="cb23-37" data-line-number="37"><span class="co"># use the function</span></a>
<a class="sourceLine" id="cb23-38" data-line-number="38">r_psqn_func &lt;-<span class="st"> </span><span class="cf">function</span>(par, <span class="dt">n_threads =</span> 2L, <span class="dt">c1 =</span> <span class="fl">1e-4</span>, </a>
<a class="sourceLine" id="cb23-39" data-line-number="39">                        <span class="dt">c2 =</span> <span class="fl">.9</span>, <span class="dt">trace =</span> 0L)</a>
<a class="sourceLine" id="cb23-40" data-line-number="40">  <span class="kw">psqn</span>(<span class="dt">par =</span> par, <span class="dt">fn =</span> r_func, <span class="dt">n_ele_func =</span> n_clusters, </a>
<a class="sourceLine" id="cb23-41" data-line-number="41">       <span class="dt">n_threads =</span> n_threads, <span class="dt">c1 =</span> c1, <span class="dt">c2 =</span> c2, </a>
<a class="sourceLine" id="cb23-42" data-line-number="42">       <span class="dt">trace =</span> trace, <span class="dt">max_it =</span> 1000L)</a>
<a class="sourceLine" id="cb23-43" data-line-number="43"></a>
<a class="sourceLine" id="cb23-44" data-line-number="44">R_res &lt;-<span class="st"> </span><span class="kw">r_psqn_func</span>(<span class="kw">numeric</span>(idx_start))</a>
<a class="sourceLine" id="cb23-45" data-line-number="45"><span class="kw">all.equal</span>(exp_res, R_res<span class="op">$</span>par)</a>
<a class="sourceLine" id="cb23-46" data-line-number="46"><span class="co">#&gt; [1] TRUE</span></a></code></pre></div>
</div>
</div>
<div id="details" class="section level2">
<h2>Details</h2>
<div id="using-the-code-in-a-package" class="section level3">
<h3>Using the Code in a Package</h3>
<p>The main part of this packages is a header-only library. Thus, the code can be used within a R package by adding <code>psqn</code> to <code>LinkingTo</code> in the DESCRIPTION file. This is an advantage as one can avoid repeated compilation of the code.</p>
<p>Moreover, since the main part of the code is a header-only library, this package can easily be used within languages which can easily call C++ code.</p>
</div>
<div id="bfgs-method" class="section level3">
<h3>BFGS Method</h3>
<p>There is also a BFGS implementation in the package. This is both available in R through the <code>psqn_bfgs</code> function and in C++ in the psqn-bfgs.h header file. An example is provided below using the example from <code>optim</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co"># declare function and gradient from the example from help(optim)</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">fn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">gr &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb24-9" data-line-number="9">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">  <span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">     <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="co"># we need a different function for the method in this package</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">gr_psqn &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">  x1 &lt;-<span class="st"> </span>x[<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">  x2 &lt;-<span class="st"> </span>x[<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">  out &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">400</span> <span class="op">*</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1) <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1),</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">            <span class="dv">200</span> <span class="op">*</span><span class="st">      </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1))</a>
<a class="sourceLine" id="cb24-20" data-line-number="20">  <span class="kw">attr</span>(out, <span class="st">&quot;value&quot;</span>) &lt;-<span class="st"> </span><span class="dv">100</span> <span class="op">*</span><span class="st"> </span>(x2 <span class="op">-</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>x1)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb24-21" data-line-number="21">  out</a>
<a class="sourceLine" id="cb24-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb24-23" data-line-number="23"></a>
<a class="sourceLine" id="cb24-24" data-line-number="24"><span class="co"># we get the same</span></a>
<a class="sourceLine" id="cb24-25" data-line-number="25"><span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>)<span class="op">$</span>par</a>
<a class="sourceLine" id="cb24-26" data-line-number="26"><span class="co">#&gt; [1] 1 1</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27"><span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn)            <span class="op">$</span>par</a>
<a class="sourceLine" id="cb24-28" data-line-number="28"><span class="co">#&gt; [1] 1 1</span></a>
<a class="sourceLine" id="cb24-29" data-line-number="29"></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"><span class="co"># they run in about the same time</span></a>
<a class="sourceLine" id="cb24-31" data-line-number="31">bench<span class="op">::</span><span class="kw">mark</span>(</a>
<a class="sourceLine" id="cb24-32" data-line-number="32">  <span class="dt">optim     =</span> <span class="kw">optim</span>    (<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr, <span class="dt">method =</span> <span class="st">&quot;BFGS&quot;</span>), </a>
<a class="sourceLine" id="cb24-33" data-line-number="33">  <span class="dt">psqn_bfgs =</span> <span class="kw">psqn_bfgs</span>(<span class="kw">c</span>(<span class="op">-</span><span class="fl">1.2</span>, <span class="dv">1</span>), fn, gr_psqn), </a>
<a class="sourceLine" id="cb24-34" data-line-number="34">  <span class="dt">check =</span> <span class="ot">FALSE</span>, <span class="dt">min_time =</span> <span class="fl">.5</span>)</a>
<a class="sourceLine" id="cb24-35" data-line-number="35"><span class="co">#&gt; # A tibble: 2 x 6</span></a>
<a class="sourceLine" id="cb24-36" data-line-number="36"><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></a>
<a class="sourceLine" id="cb24-37" data-line-number="37"><span class="co">#&gt;   &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb24-38" data-line-number="38"><span class="co">#&gt; 1 optim       111.9µs  126.8µs     7834.      384B     14.5</span></a>
<a class="sourceLine" id="cb24-39" data-line-number="39"><span class="co">#&gt; 2 psqn_bfgs    86.3µs   94.3µs    10432.    2.49KB     12.6</span></a></code></pre></div>
</div>
<div id="bfgs-and-partially-separable-quasi-newton" class="section level3">
<h3>BFGS and Partially Separable Quasi-Newton</h3>
<p>Below we show the ratio of flops required in the matrix-vector product in a BFGS method relative to the flops required in the matrix-vector product for the conjugate gradient method for the quasi-Newton method:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">n =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">8</span><span class="op">:</span><span class="dv">13</span>), <span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>))</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  flops_qsn &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q) <span class="op">*</span><span class="st"> </span>(p <span class="op">+</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>1L)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  flops_bfgs &lt;-<span class="st"> </span>2L <span class="op">*</span><span class="st"> </span>(q <span class="op">*</span><span class="st"> </span>n <span class="op">+</span><span class="st"> </span>p)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  ratio &lt;-<span class="st"> </span>flops_bfgs <span class="op">/</span><span class="st"> </span>flops_qsn</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">})</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">nq &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q))</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(vals<span class="op">$</span>n[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], </a>
<a class="sourceLine" id="cb25-9" data-line-number="9">           vals<span class="op">$</span>p[<span class="kw">seq_len</span>(<span class="kw">NROW</span>(vals) <span class="op">/</span><span class="st"> </span>nq)], <span class="kw">floor</span>(vals[, <span class="st">&quot;ratio&quot;</span>]))</a>
<a class="sourceLine" id="cb25-10" data-line-number="10"></a>
<a class="sourceLine" id="cb25-11" data-line-number="11">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb25-12" data-line-number="12">  tvals, <span class="dt">ncol =</span> nq <span class="op">+</span><span class="st"> </span>2L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb25-13" data-line-number="13">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;n&quot;</span>, <span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb25-14" data-line-number="14">knitr<span class="op">::</span><span class="kw">kable</span>(vals)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">n</th>
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">256</td>
<td align="right">4</td>
<td align="right">57</td>
<td align="right">105</td>
<td align="right">156</td>
<td align="right">196</td>
<td align="right">223</td>
<td align="right">238</td>
<td align="right">247</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">4</td>
<td align="right">114</td>
<td align="right">210</td>
<td align="right">312</td>
<td align="right">393</td>
<td align="right">447</td>
<td align="right">477</td>
<td align="right">494</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">4</td>
<td align="right">228</td>
<td align="right">420</td>
<td align="right">624</td>
<td align="right">787</td>
<td align="right">894</td>
<td align="right">955</td>
<td align="right">988</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">4</td>
<td align="right">455</td>
<td align="right">840</td>
<td align="right">1248</td>
<td align="right">1574</td>
<td align="right">1787</td>
<td align="right">1911</td>
<td align="right">1977</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">4</td>
<td align="right">910</td>
<td align="right">1680</td>
<td align="right">2496</td>
<td align="right">3149</td>
<td align="right">3575</td>
<td align="right">3822</td>
<td align="right">3955</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">4</td>
<td align="right">1820</td>
<td align="right">3361</td>
<td align="right">4993</td>
<td align="right">6297</td>
<td align="right">7151</td>
<td align="right">7645</td>
<td align="right">7911</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">8</td>
<td align="right">26</td>
<td align="right">60</td>
<td align="right">109</td>
<td align="right">160</td>
<td align="right">199</td>
<td align="right">225</td>
<td align="right">239</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">8</td>
<td align="right">52</td>
<td align="right">120</td>
<td align="right">218</td>
<td align="right">320</td>
<td align="right">399</td>
<td align="right">450</td>
<td align="right">479</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">8</td>
<td align="right">105</td>
<td align="right">241</td>
<td align="right">437</td>
<td align="right">639</td>
<td align="right">798</td>
<td align="right">900</td>
<td align="right">959</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">8</td>
<td align="right">210</td>
<td align="right">482</td>
<td align="right">874</td>
<td align="right">1279</td>
<td align="right">1596</td>
<td align="right">1801</td>
<td align="right">1918</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">8</td>
<td align="right">420</td>
<td align="right">964</td>
<td align="right">1748</td>
<td align="right">2557</td>
<td align="right">3192</td>
<td align="right">3601</td>
<td align="right">3837</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">8</td>
<td align="right">840</td>
<td align="right">1928</td>
<td align="right">3495</td>
<td align="right">5115</td>
<td align="right">6384</td>
<td align="right">7203</td>
<td align="right">7674</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">16</td>
<td align="right">10</td>
<td align="right">27</td>
<td align="right">62</td>
<td align="right">111</td>
<td align="right">162</td>
<td align="right">201</td>
<td align="right">226</td>
</tr>
<tr class="even">
<td align="right">512</td>
<td align="right">16</td>
<td align="right">19</td>
<td align="right">55</td>
<td align="right">124</td>
<td align="right">223</td>
<td align="right">323</td>
<td align="right">401</td>
<td align="right">451</td>
</tr>
<tr class="odd">
<td align="right">1024</td>
<td align="right">16</td>
<td align="right">39</td>
<td align="right">109</td>
<td align="right">248</td>
<td align="right">446</td>
<td align="right">647</td>
<td align="right">803</td>
<td align="right">903</td>
</tr>
<tr class="even">
<td align="right">2048</td>
<td align="right">16</td>
<td align="right">78</td>
<td align="right">218</td>
<td align="right">496</td>
<td align="right">892</td>
<td align="right">1294</td>
<td align="right">1607</td>
<td align="right">1807</td>
</tr>
<tr class="odd">
<td align="right">4096</td>
<td align="right">16</td>
<td align="right">156</td>
<td align="right">437</td>
<td align="right">993</td>
<td align="right">1783</td>
<td align="right">2589</td>
<td align="right">3214</td>
<td align="right">3615</td>
</tr>
<tr class="even">
<td align="right">8192</td>
<td align="right">16</td>
<td align="right">312</td>
<td align="right">874</td>
<td align="right">1986</td>
<td align="right">3567</td>
<td align="right">5178</td>
<td align="right">6428</td>
<td align="right">7230</td>
</tr>
</tbody>
</table>
<p>The</p>
<p><span class="math display">\[\frac{\bar q^2}{p^2 + 2p\bar q + \bar q^2}\]</span></p>
<p>ratio from the section called <a href="#conjugate-gradient-method">Conjugate Gradient Method</a> is shown below:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(p<span class="op">^</span><span class="dv">2</span>  <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">})</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.7901</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.6400</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.4444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.2500</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
<td align="right">0.940</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.1111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
<td align="right">0.886</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.0400</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
<td align="right">0.790</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0002</td>
<td align="right">0.0009</td>
<td align="right">0.0035</td>
<td align="right">0.0123</td>
<td align="right">0.040</td>
<td align="right">0.111</td>
<td align="right">0.250</td>
<td align="right">0.444</td>
<td align="right">0.640</td>
</tr>
</tbody>
</table>
<p>We can get rid of the <span class="math inline">\(p^2\)</span> term which gives us:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">vals &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">p =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">8</span>), <span class="dt">q =</span> <span class="dv">2</span><span class="op">^</span>(<span class="dv">2</span><span class="op">:</span><span class="dv">10</span>))</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">vals &lt;-<span class="st"> </span><span class="kw">within</span>(vals, {</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  ratio &lt;-<span class="st"> </span>q<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>q<span class="op">^</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">})</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">tvals &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">unique</span>(vals<span class="op">$</span>p), vals[, <span class="st">&quot;ratio&quot;</span>])</a>
<a class="sourceLine" id="cb27-6" data-line-number="6"></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">vals &lt;-<span class="st"> </span><span class="kw">matrix</span>(</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  tvals, <span class="dt">ncol =</span> <span class="kw">length</span>(<span class="kw">unique</span>(vals<span class="op">$</span>q)) <span class="op">+</span><span class="st"> </span>1L, <span class="dt">dimnames =</span> <span class="kw">list</span>(</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">    <span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;p/q&quot;</span>, <span class="kw">unique</span>(vals<span class="op">$</span>q))))</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">knitr<span class="op">::</span><span class="kw">kable</span>(vals, <span class="dt">digits =</span> <span class="dv">4</span>)</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">p/q</th>
<th align="right">4</th>
<th align="right">8</th>
<th align="right">16</th>
<th align="right">32</th>
<th align="right">64</th>
<th align="right">128</th>
<th align="right">256</th>
<th align="right">512</th>
<th align="right">1024</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">4</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.8000</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
<td align="right">0.992</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.6667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
<td align="right">0.985</td>
</tr>
<tr class="odd">
<td align="right">16</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.5000</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
<td align="right">0.970</td>
</tr>
<tr class="even">
<td align="right">32</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.3333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
<td align="right">0.941</td>
</tr>
<tr class="odd">
<td align="right">64</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.2000</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
<td align="right">0.889</td>
</tr>
<tr class="even">
<td align="right">128</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.1111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
<td align="right">0.800</td>
</tr>
<tr class="odd">
<td align="right">256</td>
<td align="right">0.0078</td>
<td align="right">0.0154</td>
<td align="right">0.0303</td>
<td align="right">0.0588</td>
<td align="right">0.111</td>
<td align="right">0.200</td>
<td align="right">0.333</td>
<td align="right">0.500</td>
<td align="right">0.667</td>
</tr>
</tbody>
</table>
<p>This is implemented.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-nocedal06">
<p>Nocedal, Jorge, and Stephen Wright. 2006. <em>Numerical Optimization</em>. 2nd ed. Springer Science &amp; Business Media. <a href="https://doi.org/10.1007/978-0-387-40065-5">https://doi.org/10.1007/978-0-387-40065-5</a>.</p>
</div>
<div id="ref-Ormerod11">
<p>Ormerod, J. T. 2011. “Skew-Normal Variational Approximations for Bayesian Inference.” <em>Unpublished Article</em>.</p>
</div>
<div id="ref-Ormerod12">
<p>Ormerod, J. T., and M. P. Wand. 2012. “Gaussian Variational Approximate Inference for Generalized Linear Mixed Models.” <em>Journal of Computational and Graphical Statistics</em> 21 (1). Taylor &amp; Francis: 2–17. <a href="https://doi.org/10.1198/jcgs.2011.09118">https://doi.org/10.1198/jcgs.2011.09118</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
