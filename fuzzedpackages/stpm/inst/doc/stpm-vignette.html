<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>  %\VignetteEncoding{UTF-8}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>title: &ldquo;Stochastic Process Model for Analysis of Longitudinal and Time-to-Event Outcomes&rdquo;
author: &ldquo;Ilya Y. Zhbannikov&rdquo;
date: &ldquo;2020-11-28&rdquo;
output: rmarkdown::html_document
bibliography: &ldquo;references.bib&rdquo;
vignette: &gt;</p>

<p>%\VignetteIndexEntry{stpm}
  %\VignetteEngine{knitr::rmarkdown}
  usepackage[utf8]{inputenc}</p>

<h2>  %\VignetteEncoding{UTF-8}</h2>

<h2>Overview</h2>

<p>The Stochastic Process Model (SPM) was developed several decades ago [@Woodbury_1977, @Yashin_2007], and applied for analyses of clinical, demographic, epidemiologic longitudinal data as well as in many other studies that relate stochastic dynamics of repeated measures to the probability of end-points (outcomes). SPM links the dynamic of stochastical variables with a hazard rate as a quadratic function of the state variables [@Yashin_2007]. The R-package, &ldquo;stpm&rdquo;, is a set of utilities to estimate parameters of stochastic process and modeling survival trajectories and time-to-event outcomes observed from longitudinal studies. It is a general framework for studying and modeling survival (censored) traits depending on random trajectories (stochastic paths) of variables.</p>

<h2>Installation</h2>

<h3>Stable version from CRAN</h3>

<pre><code class="r">install.packages(&quot;stpm&quot;)
</code></pre>

<h3>Most-recent version from GitHub</h3>

<pre><code class="r">require(devtools)
devtools::install_github(&quot;izhbannikov/stpm&quot;)
</code></pre>

<h2>Data description</h2>

<p>Data represents a typical longitudinal data in form of two datasets: longitudinal dataset (follow-up studies), in which one record represents a single observation, and vital (survival) statistics, where one record represents all information about the subject. Longitudinal dataset cat contain a subject ID (identification number), status (event(1)/censored(0)), time and measurements across the variables.</p>

<p>Below there is an example of clinical data that can be used in <code>stpm</code> and we will discuss the fields later.</p>

<p>Longitudinal table:</p>

<pre><code>##   ID IndicatorDeath Age      DBP      BMI
## 1  1              0  30 80.00000 25.00000
## 2  1              0  32 80.51659 26.61245
## 3  1              0  34 77.78412 29.16790
## 4  1              0  36 77.86665 32.40359
## 5  1              0  38 96.55673 31.92014
## 6  1              0  40 94.48616 32.89139
</code></pre>

<h4>Description of data fields</h4>

<ul>
<li>ID - subject unique identificatin number.</li>
<li>IndicatorDeath - 0/1, indicates death of a subject.</li>
<li>Age - current age of subject at observation.</li>
<li>DBP, BMI - covariates, here &ldquo;DBP&rdquo; represents a diastolic blood pressure, &ldquo;BMI&rdquo; a body-mass index.</li>
</ul>

<h4>&ldquo;Short&rdquo; and &ldquo;Long&rdquo; longitudinal data formats</h4>

<p>The packate accepts longitudinal data in two formats: &ldquo;short&rdquo; and &ldquo;long&rdquo;. </p>

<h5>&ldquo;Short&rdquo; format</h5>

<pre><code>##   id xi  t          y1
## 1  1  0 30   36.133394
## 2  1  0 31   -5.539881
## 3  1  0 32  -45.129493
## 4  1  0 33  -82.739624
## 5  1  0 34 -118.469249
## 6  1  0 35 -152.412392
</code></pre>

<h5>&ldquo;Long&rdquo; format</h5>

<pre><code>##   id xi t1 t2          y1     y1.next
## 1  1  0 30 31   36.133394   -5.539881
## 2  1  0 31 32   -5.539881  -45.129493
## 3  1  0 32 33  -45.129493  -82.739624
## 4  1  0 33 34  -82.739624 -118.469249
## 5  1  0 34 35 -118.469249 -152.412392
## 6  1  0 35 36 -152.412392 -184.658379
</code></pre>

<h2>Discrete- and continuous-time models</h2>

<p>There are two main SPM types in the package: discrete-time model [@Akushevich_2005] and continuous-time model [@Yashin_2007]. Discrete model assumes equal intervals between follow-up observations. The example of discrete dataset is given below.</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_discr(N=10) # simulate data for 10 individuals, &quot;long&quot; format (default)
head(data)
</code></pre>

<pre><code>##   id xi t1 t2          y1     y1.next
## 1  1  0 30 31   36.133394   -5.539881
## 2  1  0 31 32   -5.539881  -45.129493
## 3  1  0 32 33  -45.129493  -82.739624
## 4  1  0 33 34  -82.739624 -118.469249
## 5  1  0 34 35 -118.469249 -152.412392
## 6  1  0 35 36 -152.412392 -184.658379
</code></pre>

<p>In this case there are equal intervals between \(t_1\) and \(t_2\).</p>

<p>In the continuous-time SPM, in which intervals between observations are not equal (arbitrary or random). The example of such dataset is shown below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=5, format=&quot;short&quot;) # simulate data for 5 individuals, &quot;short&quot; format
head(data)
</code></pre>

<pre><code>##   id xi  t         y1
## 1  0  0 30   71.22668
## 2  0  0 31   28.86212
## 3  0  0 32  -11.43627
## 4  0  0 33  -49.76927
## 5  0  0 34  -86.23273
## 6  0  0 35 -120.91783
</code></pre>

<h3>Discrete-time model</h3>

<p>The discrete model assumes fixed time intervals between consecutive observations. In this model, \(\mathbf{Y}(t)\) (a \(k \times 1\) matrix of the values of covariates, where \(k\) is the number of considered covariates) and \(\mu(t, \mathbf{Y}(t))\) (the hazard rate) have the following form:</p>

<p>\(\mathbf{Y}(t+1) = \mathbf{u} + \mathbf{R} \mathbf{Y}(t) + \mathbf{\epsilon}\)</p>

<p>\(\mu (t, \mathbf{Y}(t)) = [\mu_0 + \mathbf{b} \mathbf{Y}(t) + \mathbf{Y}(t)^* \mathbf{Q} \mathbf{Y}(t)] e^{\theta t}\)</p>

<p>Coefficients \(\mathbf{u}\) (a \(k \times 1\) matrix, where \(k\) is a number of covariates), \(\mathbf{R}\) (a \(k \times k\) matrix), \(\mu_0\), \(\mathbf{b}\) (a \(1 \times k\) matrix), \(\mathbf{Q}\) (a \(k \times k\) matrix) are assumed to be constant in the particular implementation of this model in the R-package <code>stpm</code>. \(\mathbf{\epsilon}\) are normally-distributed random residuals, \(k \times 1\) matrix. A symbol &#39;*&#39; denotes transpose operation. \(\theta\) is a parameter to be estimated along with other parameters (\(\mathbf{u}\), \(\mathbf{R}\), \(\mathbf{\mu_0}\), \(\mathbf{b}\), \(\mathbf{Q}\)).</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Data simulation (200 individuals)
data &lt;- simdata_discr(N=100)
#Estimation of parameters
pars &lt;- spm_discrete(data)
pars
</code></pre>

<pre><code>## $dmodel
## $dmodel$theta
## [1] 0.2
## 
## $dmodel$mu0
## [1] 9.136222991e-06
## 
## $dmodel$b
## [1] 2.477520974e-08
## 
## $dmodel$Q
##                 [,1]
## [1,] 1.678638383e-11
## 
## $dmodel$u
## [1] -39.86660584
## 
## $dmodel$u.std.err
##     (Intercept) 
## 1.072800413e-13 
## 
## $dmodel$R
##      [,1]
## [1,] 0.95
## 
## $dmodel$R.std.err
##                 y1_1
## [1,] 1.830749633e-16
## 
## $dmodel$Sigma
## [1] 3.194195589e-12
## 
## 
## $cmodel
## $cmodel$a
##       [,1]
## [1,] -0.05
## 
## $cmodel$f1
##              [,1]
## [1,] -797.3321169
## 
## $cmodel$Q
##                 [,1]
## [1,] 1.678638383e-11
## 
## $cmodel$f
##              [,1]
## [1,] -737.9555354
## 
## $cmodel$b
##                 [,1]
## [1,] 3.194195589e-12
## 
## $cmodel$mu0
##                  [,1]
## [1,] -5.278592871e-09
## 
## $cmodel$theta
## [1] 0.2
## 
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.discrete&quot;
</code></pre>

<h3>Continuous-time model</h3>

<p>In the specification of the SPM described in 2007 paper by Yashin and collegaues [@Yashin_2007] the stochastic differential equation describing the age dynamics of a covariate is:</p>

<p>\(d\mathbf{Y}(t)= \mathbf{a}(t)(\mathbf{Y}(t) -\mathbf{f}_1(t))dt + \mathbf{b}(t)d\mathbf{W}(t), \mathbf{Y}(t=t_0)\)</p>

<p>In this equation, \(\mathbf{Y}(t)\) (a \(k \times 1\) matrix) is the value of a particular covariate at a time (age) \(t\). \(\mathbf{f}_1(t)\) (a \(k \times 1\) matrix) corresponds to the long-term mean value of the stochastic process \(\mathbf{Y}(t)\), which describes a trajectory of individual covariate influenced by different factors represented by a random Wiener process \(\mathbf{W}(t)\). Coefficient \(\mathbf{a}(t)\) (a \(k \times k\) matrix) is a negative feedback coefficient, which characterizes the rate at which the process reverts to its mean. 
In the area of research on aging, \(\mathbf{f}_1(t)\) represents the mean allostatic trajectory and \(\mathbf{a}(t)\) represents the adaptive capacity of the organism. Coefficient \(\mathbf{b}(t)\) (a \(k \times 1\) matrix) characterizes a strength of the random disturbances from Wiener process \(\mathbf{W}(t)\).</p>

<p>The following function \(\mu(t, \mathbf{Y}(t))\) represents a hazard rate:</p>

<p>\(\mu(t, \mathbf{Y}(t)) = \mu_0(t) + (\mathbf{Y}(t) - \mathbf{f}(t))^* \mathbf{Q}(t) (\mathbf{Y}(t) - \mathbf{f}(t))\)</p>

<p>here \(\mu_0(t)\) is the baseline hazard, which represents a risk when \(\mathbf{Y}(t)\) follows its optimal trajectory; \(\mathbf{f}(t)\) (a \(k \times 1\) matrix) represents the optimal trajectory that minimizes the risk and \(\mathbf{Q}(t)\) (\(k \times k\) matrix) represents a sensitivity of risk function to deviation from the norm.</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Simulate some data for 50 individuals
data &lt;- simdata_cont(N=50)
head(data)
</code></pre>

<pre><code>##   id xi t1 t2            y1       y1.next
## 1  0  0 30 31   71.22667883   28.86212066
## 2  0  0 31 32   28.86212066  -11.43627413
## 3  0  0 32 33  -11.43627413  -49.76927447
## 4  0  0 33 34  -49.76927447  -86.23273469
## 5  0  0 34 35  -86.23273469 -120.91783418
## 6  0  0 35 36 -120.91783418 -153.91130546
</code></pre>

<pre><code class="r">#Estimate parameters
# a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=2e-5, theta=0.08 are starting values for estimation procedure
pars &lt;- spm_continuous(dat=data,a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=2e-5, theta=0.08)
</code></pre>

<pre><code>## Parameter a achieved lower/upper bound.
## 0 
## Parameter Q achieved lower/upper bound.
## 0 
## Parameter b achieved lower/upper bound.
## 5.5 
## Parameter mu0 achieved lower/upper bound.
## 1.8e-05
</code></pre>

<pre><code class="r">pars
</code></pre>

<pre><code>## $a
##      [,1]
## [1,]    0
## 
## $f1
##             [,1]
## [1,] 87.20242295
## 
## $Q
##      [,1]
## [1,]    0
## 
## $f
##             [,1]
## [1,] 74.69160644
## 
## $b
##      [,1]
## [1,]  5.5
## 
## $mu0
## [1] 1.8e-05
## 
## $theta
## [1] 0.08763157956
## 
## $status
## [1] 5
## 
## $LogLik
## [1] -25284.7227
## 
## $objective
## [1] 25284.7227
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] TRUE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h3>Coefficient conversion between continuous- and discrete-time models</h3>

<p>The coefficient conversion between continuous- and discrete-time models is as follows (&#39;c&#39; and &#39;d&#39; denote continuous- and discrete-time models respectively; note: these equations can be used if intervals between consecutive observations of discrete- and continuous-time models are equal; it also required that matrices \(\mathbf{a}_c\) and \(\mathbf{Q}_{c,d}\) must be full-rank matrices):</p>

<p>\(\mathbf{Q}_c = \mathbf{Q}_d\)</p>

<p>\(\mathbf{a}_c = \mathbf{R}_d - I(k)\)</p>

<p>\(\mathbf{b}_c = \mathbf{\Sigma}\)</p>

<p>\({\mathbf{f}_1}_c = -\mathbf{a}_c^{-1} \times \mathbf{u}_d\)</p>

<p>\(\mathbf{f}_c = -0.5 \mathbf{b}_d \times \mathbf{Q}^{-1}_d\)</p>

<p>\({\mu_0}_c = {\mu _0}_d - \mathbf{f}_c \times \mathbf{Q_c} \times \mathbf{f}_c^*\)</p>

<p>\(\theta_c = \theta_d\)</p>

<p>where \(k\) is a number of covariates, which is equal to model&#39;s dimension and &#39;*&#39; denotes transpose operation; \(\mathbf{\Sigma}\) is a \(k \times 1\) matrix which contains <code>s.d.</code>s of corresponding residuals  (residuals of a linear regression \(\mathbf{Y}(t+1) = \mathbf{u} + \mathbf{R}\mathbf{Y}(t) + \mathbf{\epsilon}\); <code>s.d.</code> is a standard deviation), \(I(k)\) is an identity \(k \times k\) matrix.</p>

<h3>Model with time-dependent coefficients</h3>

<p>In previous models, we assumed that coefficients is sort of time-dependant: we multiplied them on to \(e^{\theta t}\). In general, this may not be the case [@Yashin_2007a]. We extend this to a general case, i.e. (we consider one-dimensional case):</p>

<p>\(\mathbf{a(t)} = \mathbf{par}_1 t + \mathbf{par}_2\) - linear function. </p>

<p>The corresponding equations will be equivalent to one-dimensional continuous case described above.</p>

<h4>Example</h4>

<pre><code class="r">library(stpm)
#Data preparation:
n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, 
                        start = list(a = -0.05, f1 = 80, Q = 2e-08, f = 80, b = 5, mu0 = 0.001), 
                        frm = list(at = &quot;a&quot;, f1t = &quot;f1&quot;, Qt = &quot;Q&quot;, ft = &quot;f&quot;, bt = &quot;b&quot;, mu0t= &quot;mu0&quot;))
opt.par
</code></pre>

<pre><code>## $a
## [1] -0.05
## 
## $f1
## [1] 80
## 
## $Q
## [1] 2e-08
## 
## $f
## [1] 80
## 
## $b
## [1] 5
## 
## $mu0
## [1] 0.001
</code></pre>

<h2>Setting lower and upper boundaries of the model parameters</h2>

<p>Lower and upper boundaries can be set up with parameters \(lb\) and \(ub\), which represents simple numeric vectors. Note: lengths of  \(lb\) and \(ub\) must be the same as the total length of the parameters. Lower and upper boundaries can be set for continuous-time and time-dependent models only.</p>

<h3>Setting lb and ub for continuous-time model</h3>

<h4>One covariate</h4>

<p>Below we show the example of setting up \(lb\) and \(ub\) when we have a single covariate:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=10, ystart = 80, a = -0.1, Q = 1e-06, mu0 = 1e-5, theta = 0.08, f1 = 80, f=80, b=1, dt=1, sd0=5)
ans &lt;- spm_continuous(dat=data,
                      a = -0.1,
                      f1 = 82, 
                      Q = 1.4e-6,
                      f = 77,
                      b = 1,
                      mu0 = 1.6e-5,
                      theta = 0.1,
                      stopifbound = FALSE,
                      lb=c(-0.2, 60, 0.1e-6, 60, 0.1, 0.1e-5, 0.01), 
                      ub=c(0, 140, 5e-06, 140, 3, 5e-5, 0.20))
ans
</code></pre>

<pre><code>## $a
##                [,1]
## [1,] -0.09031734508
## 
## $f1
##             [,1]
## [1,] 79.45710275
## 
## $Q
##                 [,1]
## [1,] 1.612486204e-07
## 
## $f
##            [,1]
## [1,] 99.7029661
## 
## $b
##              [,1]
## [1,] 0.9906096625
## 
## $mu0
## [1] 1.136897362e-05
## 
## $theta
## [1] 0.1114342063
## 
## $status
## [1] 5
## 
## $LogLik
## [1] -529.0602187
## 
## $objective
## [1] 529.0103672
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h4>Two covariates</h4>

<p>This is an example for two physiological variables (covariates).</p>

<pre><code class="r">library(stpm)

data &lt;- simdata_cont(N=10, 
                     a=matrix(c(-0.1,  0.001, 0.001, -0.1), nrow = 2, ncol = 2, byrow = T),
                     f1=t(matrix(c(100, 200), nrow = 2, ncol = 1, byrow = F)),
                     Q=matrix(c(1e-06, 1e-7, 1e-7,  1e-06), nrow = 2, ncol = 2, byrow = T),
                     f=t(matrix(c(100, 200), nrow = 2, ncol = 1, byrow = F)),
                     b=matrix(c(1, 2), nrow = 2, ncol = 1, byrow = F),
                     mu0=1e-4,
                     theta=0.08,
                     ystart = c(100,200), sd0=c(5, 10), dt=1)

a.d &lt;- matrix(c(-0.15,  0.002, 0.002, -0.15), nrow = 2, ncol = 2, byrow = T)
f1.d &lt;- t(matrix(c(95, 195), nrow = 2, ncol = 1, byrow = F))
Q.d &lt;- matrix(c(1.2e-06, 1.2e-7, 1.2e-7,  1.2e-06), nrow = 2, ncol = 2, byrow = T)
f.d &lt;- t(matrix(c(105, 205), nrow = 2, ncol = 1, byrow = F))
b.d &lt;- matrix(c(1, 2), nrow = 2, ncol = 1, byrow = F)
mu0.d &lt;- 1.1e-4
theta.d &lt;- 0.07

ans &lt;- spm_continuous(dat=data,
                      a = a.d, 
                      f1 = f1.d,
                      Q = Q.d,
                      f = f.d,
                      b = b.d,
                      mu0 = mu0.d,
                      theta = theta.d,
                      lb=c(-0.5, ifelse(a.d[2,1] &gt; 0, a.d[2,1]-0.5*a.d[2,1], a.d[2,1]+0.5*a.d[2,1]), ifelse(a.d[1,2] &gt; 0, a.d[1,2]-0.5*a.d[1,2], a.d[1,2]+0.5*a.d[1,2]), -0.5,  
                           80, 100, 
                           Q.d[1,1]-0.5*Q.d[1,1], ifelse(Q.d[2,1] &gt; 0, Q.d[2,1]-0.5*Q.d[2,1], Q.d[2,1]+0.5*Q.d[2,1]), ifelse(Q.d[1,2] &gt; 0, Q.d[1,2]-0.5*Q.d[1,2], Q.d[1,2]+0.5*Q.d[1,2]), Q.d[2,2]-0.5*Q.d[2,2],
                           80, 100,
                           0.1, 0.5,
                           0.1e-4,
                           0.01),
                      ub=c(-0.08,  0.002,  0.002, -0.08,  
                           110, 220, 
                           Q.d[1,1]+0.1*Q.d[1,1], ifelse(Q.d[2,1] &gt; 0, Q.d[2,1]+0.1*Q.d[2,1], Q.d[2,1]-0.1*Q.d[2,1]), ifelse(Q.d[1,2] &gt; 0, Q.d[1,2]+0.1*Q.d[1,2], Q.d[1,2]-0.1*Q.d[1,2]), Q.d[2,2]+0.1*Q.d[2,2],
                           110, 220,
                           1.5, 2.5,
                           1.2e-4,
                           0.10))
ans
</code></pre>

<pre><code>## $a
##                 [,1]            [,2]
## [1,] -0.150678872024  0.001695644868
## [2,]  0.001981464291 -0.149129598829
## 
## $f1
##             [,1]
## [1,] 105.1278134
## [2,] 194.5480463
## 
## $Q
##                 [,1]            [,2]
## [1,] 1.216268259e-06 1.217400485e-07
## [2,] 1.216825424e-07 1.211856991e-06
## 
## $f
##             [,1]
## [1,] 105.0953201
## [2,] 204.8977588
## 
## $b
##             [,1]
## [1,] 1.122142611
## [2,] 1.934691907
## 
## $mu0
## [1] 0.0001110265608
## 
## $theta
## [1] 0.07362559726
## 
## $status
## [1] 5
## 
## $LogLik
## [1] 1597.030875
## 
## $objective
## [1] -1986.370923
## 
## $message
## [1] &quot;NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was reached.&quot;
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;spm.continuous&quot;
</code></pre>

<h3>Setting lb and ub for model with time-dependent coefficients</h3>

<p>This model uses only one covariate, therefore setting-up model parameters is easy:</p>

<pre><code class="r">n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, start=list(a=-0.05, f1=80, Q=2e-08, f=80, b=5, mu0=0.001), 
                        lb=c(-1, 30, 1e-8, 30, 1, 1e-6), ub=c(0, 120, 5e-8, 130, 10, 1e-2))
opt.par
</code></pre>

<pre><code>## $a
## [1] -0.05
## 
## $f1
## [1] 80
## 
## $Q
## [1] 2e-08
## 
## $f
## [1] 80
## 
## $b
## [1] 5
## 
## $mu0
## [1] 0.001
</code></pre>

<h4>Special case when some model parameter functions are equal to zero</h4>

<p>Imagine a situation when one parameter function you want to be equal to zero: \(f=0\). Let&#39;s emulate this case:</p>

<pre><code class="r">library(stpm)
n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Estimation:
opt.par &lt;- spm_time_dep(data, frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;0&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;))
opt.par
</code></pre>

<pre><code>## $a
## [1] -0.05
## 
## $f1
## [1] 80
## 
## $Q
## [1] 2e-08
## 
## $b
## [1] 80
## 
## $mu0
## [1] 5
## 
## $&lt;NA&gt;
## &lt;NA&gt; 
##   NA
</code></pre>

<p>As you can see, there is no parameter \(f\) in \(opt.par\). This is because we set \(f=0\) in \(frm\)!</p>

<p>Then, is you want to set the constraints, you must not specify the starting value (parameter \(start\)) and \(lb\)/\(ub\) for the parameter \(f\) (otherwise, the function raises an error):</p>

<pre><code class="r">n &lt;- 10
data &lt;- simdata_time_dep(N=n)
# Temporarily commented below
# Estimation:
opt.par &lt;- spm_time_dep(data, frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;0&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;), 
                        start=list(a=-0.05, f1=80, Q=2e-08, b=5, mu0=0.001), 
                        lb=c(-1, 30, 1e-8, 1, 1e-6), ub=c(0, 120, 5e-8, 10, 1e-2))
opt.par
</code></pre>

<pre><code>## $a
## [1] -0.05
## 
## $f1
## [1] 80
## 
## $Q
## [1] 2e-08
## 
## $b
## [1] 5
## 
## $mu0
## [1] 0.001
</code></pre>

<p>You can do the same manner if you want two or more parameters to be equal to zero.</p>

<h2>Fast parameter estimating for one-dimentional model using spm_con_1d</h2>

<p>Function <code>spm_con_1d(...)</code> allows for very fast parameter estimating for one-dimensional model. This function implements a analytical solution to estimate the parameters in the continuous SPM model by assuming all the parameters are constants. Below there is an example.</p>

<pre><code class="r">library(stpm) 
dat &lt;- simdata_cont(N=500)
colnames(dat) &lt;- c(&quot;id&quot;, &quot;xi&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;y&quot;, &quot;y.next&quot;)
res &lt;- spm_con_1d(as.data.frame(dat), a=-0.05, b=2, q=1e-8, f=80, f1=90, mu0=1e-3, theta=0.08)
</code></pre>

<pre><code>## [1] &quot;Initial values:&quot;
## [1] -5e-02  2e+00  1e-08  8e+01  9e+01  1e-03  8e-02
## [1] &quot;Lower bounds:&quot;
## [1] -2.5e-01  2.0e-01  1.0e-10  4.0e+01  4.5e+01  1.0e-04  8.0e-02
## [1] &quot;Upper bounds:&quot;
## [1] -2.5e-03  1.0e+01  1.0e-07  1.6e+02  1.8e+02  1.0e-02  8.0e-02
</code></pre>

<pre><code class="r">res
</code></pre>

<pre><code>## $est
##               Coeff. Std. Err.   z p value
## a     -0.05154002558       NaN NaN     NaN
## b      4.95735487285       NaN NaN     NaN
## q      0.00000000010       NaN NaN     NaN
## f     79.99999757449       NaN NaN     NaN
## f1    80.21370253549       NaN NaN     NaN
## mu0    0.00010000000       NaN NaN     NaN
## theta  0.08000000000       NaN NaN     NaN
## 
## $hessian
##                      a                b   q                f               f1
## a      2.640661511e+05  6.276954008e+03 NaN  8.040033859e-07 -1.232944694e+01
## b      6.276954008e+03  1.738407871e+03 NaN  5.123800236e-14 -2.089436783e-08
## q                  NaN              NaN NaN              NaN              NaN
## f      8.040033859e-07  5.123800236e-14 NaN  5.716158494e-06  4.840379724e-08
## f1    -1.232944694e+01 -2.089436783e-08 NaN  4.840379724e-08  3.453682533e+00
## mu0    9.123466430e-01  2.367570941e-02 NaN -5.205070487e-03  2.535442120e-04
## theta  1.342515458e-02  3.099587825e-04 NaN -6.248100674e-05  2.922396894e-06
##                    mu0            theta
## a      9.123466430e-01  1.342515458e-02
## b      2.367570941e-02  3.099587825e-04
## q                  NaN              NaN
## f     -5.205070487e-03 -6.248100674e-05
## f1     2.535442120e-04  2.922396894e-06
## mu0   -1.909090923e+08  1.873273175e+09
## theta  1.873273175e+09  1.729401196e+07
## 
## $lik
## [1] 50612.58895
## 
## $con
## [1] 4
## 
## $message
## [1] &quot;NLOPT_XTOL_REACHED: Optimization stopped because xtol_rel or xtol_abs (above) was reached.&quot;
</code></pre>

<h2>Simulation (individual trajectory projection, also known as microsimulations)</h2>

<p>We added one- and multi- dimensional simulation to be able to generate test data for hyphotesis testing. Data,  which can be simulated can be discrete (equal intervals between observations) and continuous (with arbitrary intervals).</p>

<h3>Discrete-time simulation</h3>

<p>The corresponding function is (<code>k</code> - a number of variables(covariates), equal to model&#39;s dimension):</p>

<p><code>simdata_discr(N=100, a=-0.05, f1=80, Q=2e-8, f=80, b=5, mu0=1e-5, theta=0.08, ystart=80, tstart=30, tend=105, dt=1)</code></p>

<p>Here:</p>

<p><code>N</code> - Number of individuals</p>

<p><code>a</code> - A matrix of <code>k</code>x<code>k</code>, which characterize the rate of the adaptive response</p>

<p><code>f1</code> - A particular state, which if a deviation from the normal (or optimal). This is a vector with length of <code>k</code></p>

<p><code>Q</code> - A matrix of <code>k</code> by <code>k</code>, which is a non-negative-definite symmetric matrix</p>

<p><code>f</code> - A vector-function (with length <code>k</code>) of the normal (or optimal) state</p>

<p><code>b</code> - A diffusion coefficient, <code>k</code> by <code>k</code> matrix</p>

<p><code>mu0</code> - mortality at start period of time (baseline hazard)</p>

<p><code>theta</code> - A displacement coefficient of the Gompertz function</p>

<p><code>ystart</code> - A vector with length equal to number of dimensions used, defines starting values of covariates</p>

<p><code>tstart</code> - A number that defines a start time (30 by default). Can be a number (30 by default) or a vector of two numbers: c(a, b) - in this case, starting value of time is simulated via uniform(a,b) distribution.</p>

<p><code>tend</code> - A number, defines a final time (105 by default)</p>

<p><code>dt</code> - A time interval between observations.</p>

<p>This function returns a table with simulated data, as shown in example below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_discr(N=10)
head(data)
</code></pre>

<pre><code>##   id xi t1 t2          y1     y1.next
## 1  1  0 30 31 82.58098816 85.53705702
## 2  1  0 31 32 85.53705702 87.96047382
## 3  1  0 32 33 87.96047382 91.42769481
## 4  1  0 33 34 91.42769481 86.92396439
## 5  1  0 34 35 86.92396439 87.68313777
## 6  1  0 35 36 87.68313777 87.10164423
</code></pre>

<h3>Continuous-time simulation</h3>

<p>The corresponding function is (<code>k</code> - a number of variables(covariates), equal to model&#39;s dimension):</p>

<p><code>simdata_cont(N=100, a=-0.05, f1=80, Q=2e-07, f=80, b=5, mu0=2e-05, theta=0.08, ystart=80, tstart=c(30,50), tend=105)</code></p>

<p>Here:</p>

<p><code>N</code> - Number of individuals</p>

<p><code>a</code> - A matrix of <code>k</code>x<code>k</code>, which characterize the rate of the adaptive response</p>

<p><code>f1</code> - A particular state, which if a deviation from the normal (or optimal). This is a vector with length of <code>k</code></p>

<p><code>Q</code> - A matrix of <code>k</code> by <code>k</code>, which is a non-negative-definite symmetric matrix</p>

<p><code>f</code> - A vector-function (with length <code>k</code>) of the normal (or optimal) state</p>

<p><code>b</code> - A diffusion coefficient, <code>k</code> by <code>k</code> matrix</p>

<p><code>mu0</code> - mortality at start period of time (baseline hazard)</p>

<p><code>theta</code> - A displacement coefficient of the Gompertz function</p>

<p><code>ystart</code> - A vector with length equal to number of dimensions used, defines starting values of covariates</p>

<p><code>tstart</code> - A number that defines a start time (30 by default). Can be a number (30 by default) or a vector of two numbers: c(a, b) - in this case, starting value of time is simulated via uniform(a,b) distribution.</p>

<p><code>tend</code> - A number, defines a final time (105 by default)</p>

<p>This function returns a table with simulated data, as shown in example below:</p>

<pre><code class="r">library(stpm)
data &lt;- simdata_cont(N=10)
head(data)
</code></pre>

<pre><code>##   id xi          t1          t2           y1      y1.next
## 1  0  0 38.59519502 40.28167144  78.67833186  79.58517161
## 2  0  0 40.28167144 41.40018081  79.58517161  86.73389787
## 3  0  0 41.40018081 43.26282328  86.73389787  92.79329971
## 4  0  0 43.26282328 44.77508025  92.79329971 107.15008114
## 5  0  0 44.77508025 46.17216013 107.15008114  98.73339760
## 6  0  0 46.17216013 47.99891699  98.73339760  97.74309482
</code></pre>

<h2>SPM with partially observed covariates</h2>

<p>Stochastic Process Model has many applications in analysis of longitudinal biodemographic data. Such data contain various physiological variables (known as covariates). Data can also potentially contain genetic information available for all or a part of participants. Taking advantage from both genetic and non-genetic information can provide future insights into a broad range of processes describing aging-related changes in the organism.</p>

<h3>Method</h3>

<p>In this package, SPM with partially observed covariates is implemented in form of GenSPM (Genetic SPM), presented in [@Arbeev_2009] and further advanced in [@Arbeev_2014], further elaborates the basic stochastic process model conception by introducing a categorical variable, \(Z\), which may be a specific value of a genetic marker or, in general, any categorical variable. Currently, \(Z\) has two gradations: 0 or 1 in a genetic group of interest, assuming that \(P(Z=1) = p\), \(p \in [0, 1]\), were \(p\) is the proportion of carriers and non-carriers of an allele in a population. Example of longitudinal data with genetic component \(Z\) is provided below.</p>

<pre><code class="r">library(stpm)
data &lt;- sim_pobs(N=10)
head(data)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 87.21089230 88.17811744 0 79.98233206 81.60908832
## 2  0  0 88.17811744 89.17214398 0 81.60908832 73.14241126
## 3  0  0 89.17214398 90.12955040 0 73.14241126 72.00132985
## 4  0  0 90.12955040 91.08371950 0 72.00132985 66.89753164
## 5  0  0 91.08371950 91.99514342 0 66.89753164 64.42219281
## 6  0  0 91.99514342 93.03106766 0 64.42219281 58.44734165
</code></pre>

<p>In the specification of the SPM described in 2007 paper by Yashin and colleagues [@Yashin_2007] the stochastic differential equation describing the age dynamics of a physiological variable (a dynamic component of the model) is:</p>

<p>\(dY(t) = a(Z, t)(Y(t) - f1(Z, t))dt + b(Z, t)dW(t), Y(t = t_0)\)</p>

<p>Here in this equation, \(Y(t)\) is a \(k \times 1\) matrix, where \(k\) is a number of covariates, which is a model dimension) describing the value of a physiological variable at a time (e.g. age) t. \(f_1(Z,t)\) is a \(k \times 1\) matrix that corresponds to the long-term average value of the stochastic process \(Y(t)\), which describes a trajectory of individual variable influenced by different factors represented by a random Wiener process \(W(t)\). The negative feedback coefficient \(a(Z,t)\) (\(k \times k\) matrix) characterizes the rate at which the stochastic process goes to its mean. In research on aging and well-being, \(f_1(Z,t)\) represents the average allostatic trajectory and \(a(t)\) in this case represents the adaptive capacity of the organism. Coefficient \(b(Z,t)\) (\(k \times 1\) matrix) characterizes a strength of the random disturbances from Wiener process \(W(t)\). All of these parameters depend on \(Z\) (a genetic marker having values 1 or 0).
The following function \(\mu(t,Y(t))\) represents a hazard rate:</p>

<p>\(\mu(t,Y(t)) = \mu_0(t) + (Y(t) - f(Z, t))^*Q(Z, t)(Y(t) - f(Z, t))\)</p>

<p>In this equation: \(\mu_0(t)\) is the baseline hazard, which represents a risk when \(Y(t)\) follows its optimal trajectory; f(t) (\(k \times 1\) matrix) represents the optimal trajectory that minimizes the risk and \(Q(Z, t)\) (\(k \times k\) matrix) represents a sensitivity of risk function to deviation from the norm. In general, model coefficients \(a(Z, t)\), \(f1(Z, t)\), \(Q(Z, t)\), \(f(Z, t)\), \(b(Z, t)\) and \(\mu_0(t)\) are time(age)-dependent.
Once we have data, we then can run analysis, i.e. estimate coefficients (they are assumed to be time-independent and data here is simulated):</p>

<pre><code class="r">library(stpm)
#Generating data:
data &lt;- sim_pobs(N=10)
head(data)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 63.11667825 64.02130508 0 77.56719074 74.46960087
## 2  0  0 64.02130508 65.02631509 0 74.46960087 71.59804672
## 3  0  0 65.02631509 66.04423365 0 71.59804672 68.89249589
## 4  0  0 66.04423365 67.04513816 0 68.89249589 76.81077774
## 5  0  0 67.04513816 68.13836281 0 76.81077774 74.96693614
## 6  0  0 68.13836281 69.14715014 0 74.96693614 64.42327653
</code></pre>

<pre><code class="r">#Parameters estimation:
pars &lt;- spm_pobs(x=data)
pars
</code></pre>

<pre><code>## $aH
##                [,1]
## [1,] -0.05406488234
## 
## $aL
##                 [,1]
## [1,] -0.009931526099
## 
## $f1H
##             [,1]
## [1,] 54.48500195
## 
## $f1L
##             [,1]
## [1,] 87.21420888
## 
## $QH
##                 [,1]
## [1,] 1.878640675e-08
## 
## $QL
##                 [,1]
## [1,] 2.616943089e-08
## 
## $fH
##            [,1]
## [1,] 57.2508126
## 
## $fL
##             [,1]
## [1,] 83.07859361
## 
## $bH
##             [,1]
## [1,] 3.611982031
## 
## $bL
##             [,1]
## [1,] 5.169067084
## 
## $mu0H
## [1] 8.330474754e-06
## 
## $mu0L
## [1] 9.007042292e-06
## 
## $thetaH
## [1] 0.07321248004
## 
## $thetaL
## [1] 0.09005961411
## 
## $p
## [1] 0.2384110394
## 
## $limit
## [1] FALSE
## 
## attr(,&quot;class&quot;)
## [1] &quot;pobs.spm&quot;
</code></pre>

<p>Here \textbf{H} and \textbf{L} represents parameters when \(Z\) = 1 (<strong>H</strong>) and 0 (<strong>L</strong>).</p>

<p>###Joint analysis of two datasets: first dataset with genetic and second dataset with non-genetic component</p>

<pre><code class="r">library(stpm)
data.genetic &lt;- sim_pobs(N=5, mode=&#39;observed&#39;)
head(data.genetic)
</code></pre>

<pre><code>##   id xi          t1          t2 Z          y1     y1.next
## 1  0  0 36.57300264 37.54328884 1 81.71260624 82.56430012
## 2  0  0 37.54328884 38.52377532 1 82.56430012 84.41819331
## 3  0  0 38.52377532 39.61619584 1 84.41819331 89.48995318
## 4  0  0 39.61619584 40.55648777 1 89.48995318 76.61111401
## 5  0  0 40.55648777 41.49180407 1 76.61111401 79.11805016
## 6  0  0 41.49180407 42.47815248 1 79.11805016 74.40481637
</code></pre>

<pre><code class="r">data.nongenetic &lt;- sim_pobs(N=10, mode=&#39;unobserved&#39;)
head(data.nongenetic)
</code></pre>

<pre><code>##   id xi          t1          t2          y1     y1.next
## 1  0  0 45.40504819 46.47892624 80.46564725 77.39762958
## 2  0  0 46.47892624 47.40445410 77.39762958 74.10118173
## 3  0  0 47.40445410 48.47629261 74.10118173 68.69041857
## 4  0  0 48.47629261 49.51821072 68.69041857 71.55355641
## 5  0  0 49.51821072 50.50122545 71.55355641 73.27115267
## 6  0  0 50.50122545 51.55911484 73.27115267 74.61010574
</code></pre>

<pre><code class="r">#Parameters estimation:
pars &lt;- spm_pobs(x=data.genetic, y = data.nongenetic, mode=&#39;combined&#39;)
</code></pre>

<pre><code>## Parameter thetaH achieved lower/upper bound.
## 0.072
</code></pre>

<pre><code class="r">pars
</code></pre>

<pre><code>## $aH
##                [,1]
## [1,] -0.03669878625
## 
## $aL
##                [,1]
## [1,] -0.01080678315
## 
## $f1H
##             [,1]
## [1,] 55.83314604
## 
## $f1L
##             [,1]
## [1,] 83.56409523
## 
## $QH
##                [,1]
## [1,] 2.14296873e-08
## 
## $QL
##                 [,1]
## [1,] 1.702318677e-08
## 
## $fH
##             [,1]
## [1,] 56.09645823
## 
## $fL
##             [,1]
## [1,] 80.03943036
## 
## $bH
##             [,1]
## [1,] 4.226919935
## 
## $bL
##             [,1]
## [1,] 4.902493514
## 
## $mu0H
## [1] 7.202059299e-06
## 
## $mu0L
## [1] 9.036337798e-06
## 
## $thetaH
## [1] 0.072
## 
## $thetaL
## [1] 0.09007933941
## 
## $p
## [1] 0.2749075696
## 
## $limit
## [1] TRUE
## 
## attr(,&quot;class&quot;)
## [1] &quot;pobs.spm&quot;
</code></pre>

<p>Here mode &#39;observed&#39; is used for simlation of data with genetic component \(Z\) and &#39;unobserved&#39; - without genetic component.</p>

<h2>Genetic SPM &#39;GSPM&#39;</h2>

<p>This type of SPM also uses genetic component by analogy from the previous chapters but uses explicit gradient function which speeds up computations significantly. See [@He_2017] for details. Below we provide examples of usage:</p>

<pre><code class="r">library(stpm) 
data(ex_spmcon1dg)
head(ex_data$spm_data)
</code></pre>

<pre><code>##   id xi t1 t2           y      y.next
## 1  1  0 30 31 2.000000000 2.024328135
## 2  1  0 31 32 2.024328135 1.927486318
## 3  1  0 32 33 1.927486318 1.899083801
## 4  1  0 33 34 1.899083801 2.061574385
## 5  1  0 34 35 2.061574385 2.034558435
## 6  1  0 35 36 2.034558435 2.114382051
</code></pre>

<pre><code class="r">head(ex_data$gene_data)
</code></pre>

<pre><code>##   id geno
## 1  1    1
## 2  2    1
## 3  3    0
## 4  4    0
## 5  5    1
## 6  6    0
</code></pre>

<pre><code class="r">res &lt;- spm_con_1d_g(spm_data=ex_data$spm_data, 
                    gene_data=ex_data$gene_data, 
                    a = -0.02, b=0.2, q=0.01, f=3, f1=3, mu0=0.01, theta=1e-05, 
                    upper=c(-0.01,3,0.1,10,10,0.1,1e-05), lower=c(-1,0.01,0.00001,1,1,0.001,1e-07), 
                    effect=c(&#39;q&#39;), method = &quot;tnewton&quot;)
</code></pre>

<pre><code>## [1] &quot;Initial values:&quot;
##  [1] -2e-02 -2e-02  2e-01  2e-01  1e-02  1e-02  3e+00  3e+00  3e+00  3e+00
## [11]  1e-02  1e-02  1e-05
## [1] &quot;Lower bounds:&quot;
##  [1] -1e+00 -1e+00  1e-02  1e-02  1e-05  1e-05  1e+00  1e+00  1e+00  1e+00
## [11]  1e-03  1e-03  1e-07
## [1] &quot;Upper bounds:&quot;
##  [1] -1e-02 -1e-02  3e+00  3e+00  1e-01  1e-01  1e+01  1e+01  1e+01  1e+01
## [11]  1e-01  1e-01  1e-05
</code></pre>

<pre><code class="r">res
</code></pre>

<pre><code>## $est
##                Coeff.       Std. Err.                z      p value
## a     -0.031238526396 9.063948538e-04 -3.446458932e+01 0.0000000000
## b      0.101329776535 2.785757812e-04  3.637422323e+02 0.0000000000
## q_0    0.000010000000 3.124724202e-03  3.200282442e-03 0.9974465484
## q_2    0.003608789876 5.278940497e-03  6.836201087e-01 0.4942150834
## f      2.999731527110 3.052250225e-02  9.827934494e+01 0.0000000000
## f1     3.000056947322 1.716252597e-02  1.748027622e+02 0.0000000000
## mu0    0.001000000000 1.552500478e+04  6.441221851e-08 0.9999999486
## theta  0.000000100000 8.987112435e+01  1.112704450e-09 0.9999999991
## 
## $lik
## [1] -121546.402
## 
## $con
## [1] -1
## 
## $message
## [1] &quot;NLOPT_FAILURE: Generic failure code.&quot;
## 
## $hessian
##                      a                b             q_0              q_2
## a      2.354652039e+06  6.786921795e+05   158.058062204    82.3853495314
## b      6.786921795e+05  1.325446527e+07  1517.123161715   775.1749357615
## q_0    1.580580622e+02  1.517123162e+03   -39.193641214   -13.8346645758
## q_2    8.238534953e+01  7.751749358e+02   -13.834664576   -13.8346698668
## f      3.489487410e-01 -4.196232148e-03 36528.531980456 19000.8175924782
## f1    -8.446522178e+04  5.065699701e+01    -2.840122726    -1.4581382745
## mu0    2.228043741e-03  8.307251846e-04     1.053761684     0.6444883984
## theta  4.230830818e-01  1.744572073e-01   194.433867000   117.7827687934
##                      f               f1              mu0            theta
## a      3.489487410e-01 -8.446522178e+04  2.228043741e-03   0.423083081841
## b     -4.196232148e-03  5.065699701e+01  8.307251846e-04   0.174457207322
## q_0    3.652853198e+04 -2.840122726e+00  1.053761684e+00 194.433867000043
## q_2    1.900081759e+04 -1.458138275e+00  6.444883984e-01 117.782768793404
## f      1.670661873e+02 -1.202720644e-02  3.587745596e-03   0.465787947178
## f1    -1.202720644e-02  6.470562259e+03 -5.237961886e-05  -0.006925314665
## mu0    3.587745596e-03 -5.237961886e-05  0.000000000e+00   0.000000000000
## theta  4.657879472e-01 -6.925314665e-03  0.000000000e+00   0.000000000000
## 
## $beta
##                  Coeff.      Std. Err.         Chi. Sq      p value
## beta_a               NA             NA              NA           NA
## beta_b               NA             NA              NA           NA
## beta_q   0.001799394938 0.004201832138 0.0007705738917 0.9778541969
## beta_f               NA             NA              NA           NA
## beta_f1              NA             NA              NA           NA
## beta_mu0             NA             NA              NA           NA
</code></pre>

<p>Here:
<code>spm_data</code> - A dataset for the SPM model. See the STPM package for more details about the format.</p>

<p><code>gene_data</code> - A two column dataset containing the genotypes for the individuals in spm_data. The first column <code>id</code> is the ID of the individuals in dataset <code>spm_data</code>, and the second column <code>geno</code> is the genotype. </p>

<p><code>a</code> - The initial value for the paramter \eqn{a}. The initial value will be predicted if not specified.</p>

<p><code>b</code> - The initial value for the paramter \eqn{b}. The initial value will be predicted if not specified. </p>

<p><code>q</code> - The initial value for the paramter \eqn{q}. The initial value will be predicted if not specified.</p>

<p><code>f</code> -  The initial value for the paramter \eqn{f}. The initial value will be predicted if not specified.</p>

<p><code>f1</code> - The initial value for the paramter \eqn{f_1}. The initial value will be predicted if not specified.</p>

<p><code>mu0</code> - The initial value for the paramter \eqn{\mu_0} in the baseline hazard. The initial value will be predicted if not specified.</p>

<p><code>theta</code> - The initial value for the paramter \eqn{\theta} in the baseline hazard. The initial value will be predicted if not specified.</p>

<p><code>lower</code> - A vector of the lower bound of the parameters.</p>

<p><code>upper</code> - A vector of the upper bound of the parameters.</p>

<p><code>effect</code> - A character vector of the parameters that are linked to genotypes. The vector can contain any combination of \code{a}, \code{b}, \code{q}, \code{f}, \code{mu0}.</p>

<p><code>control</code> - A list of the control parameters for the optimization paramters.</p>

<p><code>global</code> - A logical variable indicating whether the MLSL (TRUE) or the L-BFGS (FALSE) algorithm is used for the optimization.</p>

<p><code>verbose</code> - A logical variable indicating whether initial information is printed.</p>

<p><code>ahessian</code> - A logical variable indicating whether the approximate (FALSE) or analytical (TRUE) Hessian is returned.</p>

<p><code>est</code> - The estimates of the parameters.</p>

<p><code>hessian</code> - The Hessian matrix of the estimates.</p>

<p><code>lik</code> - The minus log-likelihood.</p>

<p><code>con</code> - A number indicating the convergence. See the &#39;nloptr&#39; package for more details.</p>

<p><code>message</code> - Extra message about the convergence. See the &#39;nloptr&#39; package for more details.</p>

<p><code>beta</code> - The coefficients of the genetic effect on the parameters to be linked to genotypes.</p>

<h2>Multiple imputation with spm.impute(&hellip;)</h2>

<p>The SPM offers longitudinal data imputation with results that are better than from other imputation tools since it preserves data structure, i.e. relation between 
Y(t) and mu(Y(t),t). Below there are two examples of multiple data imputation with function spm.impute(&hellip;).</p>

<pre><code class="r">library(stpm)

#######################################################################
############## One dimensional case (one covariate) ###################
#######################################################################

## Data preparation (short format)#
data &lt;- simdata_discr(N=1000, dt = 2, format=&quot;short&quot;)

miss.id &lt;- sample(x=dim(data)[1], size=round(dim(data)[1]/4)) # ~25% missing data
incomplete.data &lt;- data
incomplete.data[miss.id,4] &lt;- NA
# End of data preparation #

##### Multiple imputation with SPM #####
imp.data &lt;- spm.impute(x=incomplete.data, id=1, case=&quot;xi&quot;, t1=3, covariates=&quot;y1&quot;, minp=1, theta_range=seq(0.075, 0.09, by=0.001))$imputed

##### Look at the incomplete data with missings #####
head(incomplete.data)
</code></pre>

<pre><code>##   id xi  t          y1
## 1  1  0 30 82.21397004
## 2  1  0 32          NA
## 3  1  0 34 85.03517916
## 4  1  0 36 85.42723336
## 5  1  0 38 82.62521178
## 6  1  0 40          NA
</code></pre>

<pre><code class="r">##### Look at the imputed data #####
head(imp.data)
</code></pre>

<pre><code>##   id xi  t          y1
## 1  1  0 30 82.21397004
## 2  1  0 32 81.93599225
## 3  1  0 34 85.03517916
## 4  1  0 36 85.42723336
## 5  1  0 38 82.62521178
## 6  1  0 40 82.32537105
</code></pre>

<pre><code class="r">#########################################################
################ Two-dimensional case ###################
#########################################################

## Parameters for data simulation #
a &lt;- matrix(c(-0.05, 0.01, 0.01, -0.05), nrow=2)
f1 &lt;- matrix(c(90, 30), nrow=1, byrow=FALSE)
Q &lt;- matrix(c(1e-7, 1e-8, 1e-8, 1e-7), nrow=2)
f0 &lt;- matrix(c(80, 25), nrow=1, byrow=FALSE)
b &lt;- matrix(c(5, 3), nrow=2, byrow=TRUE)
mu0 &lt;- 1e-04
theta &lt;- 0.07
ystart &lt;- matrix(c(80, 25), nrow=2, byrow=TRUE)

## Data preparation #
data &lt;- simdata_discr(N=1000, a=a, f1=f1, Q=Q, f=f0, b=b, ystart=ystart, mu0 = mu0, theta=theta, dt=2, format=&quot;short&quot;)

## Delete some observations in order to have approx. 25% missing data
incomplete.data &lt;- data
miss.id &lt;- sample(x=dim(data)[1], size=round(dim(data)[1]/4)) 
incomplete.data &lt;- data
incomplete.data[miss.id,4] &lt;- NA
miss.id &lt;- sample(x=dim(data)[1], size=round(dim(data)[1]/4)) 
incomplete.data[miss.id,5] &lt;- NA
## End of data preparation #

###### Multiple imputation with SPM #####
imp.data &lt;- spm.impute(x=incomplete.data, id=1, case=&quot;xi&quot;, t1=3, covariates=c(&quot;y1&quot;, &quot;y2&quot;), minp=1, theta_range=seq(0.060, 0.07, by=0.001))$imputed

###### Look at the incomplete data with missings #####
head(incomplete.data)
</code></pre>

<pre><code>##   id xi  t          y1          y2
## 1  1  0 30 73.58167132 17.53079936
## 2  1  0 32 83.53203831 20.71095517
## 3  1  0 34 81.32282321          NA
## 4  1  0 36 84.73096312          NA
## 5  1  0 38 84.78126323 23.52301468
## 6  1  0 40 79.48244838 26.76178054
</code></pre>

<pre><code class="r">###### Look at the imputed data #####
head(imp.data)
</code></pre>

<pre><code>##   id xi  t          y1          y2
## 1  1  0 30 73.58167132 17.53079936
## 2  1  0 32 83.53203831 20.71095517
## 3  1  0 34 81.32282321 20.60595418
## 4  1  0 36 84.73096312 20.48709461
## 5  1  0 38 84.78126323 23.52301468
## 6  1  0 40 79.48244838 26.76178054
</code></pre>

<h2>Prediction</h2>

<p>We provide a simple function to predict the next value of \code{Y}.
Refer to the example below:</p>

<pre><code class="r">#library(stpm)
#data &lt;- simdata_discr(N=100, format=&quot;long&quot;)
#res &lt;- spm_discrete(data)
#splitted &lt;- split(data, data$id)
#df &lt;- data.frame()
#lapply(1:100, function(i) {df&lt;&lt;-rbind(df,splitted[[i]][dim(splitted[[i]])[1],c(&quot;id&quot;, &quot;xi&quot;, &quot;t1&quot;, &quot;y1&quot;)])})
#names(df) &lt;- c(&quot;id&quot;, &quot;xi&quot;, &quot;t&quot;, &quot;y&quot;)
#predicted &lt;- predict(object=res, data=df, dt=3)
#head(predicted)
</code></pre>

<h2>Hypothesis testing</h2>

<p>The package offers following five hypotheses to test for \code{spm_time_dep(&hellip;)} function [@Arbeev_2016]:</p>

<p><code>H01</code>: \(Q(t)=0\) (i.e., \(a_Q = 0\) and \(b_Q = 0\),so that there is no quadratic term in the hazard rate and mortality is described by the baseline Gompertz rate \(_0(t)\)).</p>

<p><code>H02</code>: \(Q(t) = a_Q\) (i.e., \(b_Q = 0\)). </p>

<p><code>H03</code>: \(f_1(t) = 0\) (i.e., \(a_{f1} = 0\) and \(b_{f1} = 0\)).</p>

<p><code>H04</code>: \(f_1(t) = a_{f_1}\) (i.e., \(b_{f_1} = 0\)).</p>

<p><code>H05</code>: \(a(t) = a_Y\) (i.e., \(b_Y = 0\)).</p>

<p>To perform hypothesis testing you should put the variable <code>lrtest</code> to <code>TRUE</code> (this is <code>&quot;H01&quot;</code> by default) or to any of the following: <code>&quot;H01&quot;</code>, <code>&quot;H02&quot;</code>, <code>&quot;H03&quot;</code>, <code>&quot;H04&quot;</code>, <code>&quot;H05&quot;</code>.</p>

<h3>Examples of hypothesis testing</h3>

<pre><code class="r">library(stpm)
n &lt;- 1000

# Data simulation:
data &lt;- simdata_time_dep(N=n, format=&quot;long&quot;)
head(data)

# Hypotheses testing

## H01
res &lt;- spm_time_dep(data, verbose=F, 
                    frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;f&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;),
                    start=list(a=-0.05, f1=80, Q=1e-8, f=90, b=5, mu0=0.001), 
                    lb=c(a=-1, f1=30, Q=1e-9, f=10, b=1, mu0=1e-6), 
                    ub=c(a=0, f1=120, Q=1e-7, f=150, b=10, mu0=1e-2),
                    opts = list(algorithm = &quot;NLOPT_LN_NELDERMEAD&quot;, 
                    maxeval = 200, ftol_rel = 1e-12), lrtest=&quot;H01&quot;)

res$alternative$lr.test.pval

## H02
res &lt;- spm_time_dep(data, verbose=F, 
                    frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;1e-6&quot;, ft=&quot;f&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;),
                    start=list(a=-0.05, f1=80, Q=1e-8, f=90, b=5, mu0=0.001), 
                    lb=c(a=-1, f1=30, Q=1e-9, f=10, b=1, mu0=1e-6), 
                    ub=c(a=0, f1=120, Q=1e-7, f=150, b=10, mu0=1e-2),
                    opts = list(algorithm = &quot;NLOPT_LN_NELDERMEAD&quot;, 
                    maxeval = 200, ftol_rel = 1e-12), lrtest=&quot;H02&quot;)

res$alternative$lr.test.pval

## H03
res &lt;- spm_time_dep(data, verbose=F, 
                    frm = list(at=&quot;a&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;f&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;),
                    start=list(a=-0.05, f1=80, Q=1e-8, f=90, b=5, mu0=0.001), 
                    ub=c(a=0, f1=120, Q=1e-7, f=150, b=10, mu0=1e-2),
                    opts = list(algorithm = &quot;NLOPT_LN_NELDERMEAD&quot;, 
                    maxeval = 200, ftol_rel = 1e-12), lrtest=&quot;H03&quot;)

res$alternative$lr.test.pval

## H04
res &lt;- spm_time_dep(data, verbose=F, 
                    frm = list(at=&quot;a&quot;, f1t=&quot;120&quot;, Qt=&quot;Q&quot;, ft=&quot;f&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;),
                    start=list(a=-0.05, f1=80, Q=1e-8, f=90, b=5, mu0=0.001), 
                    lb=list(a=-1, f1=30, Q=1e-9, f=10, b=1, mu0=1e-6), 
                    opts = list(algorithm = &quot;NLOPT_LN_NELDERMEAD&quot;, 
                    maxeval = 200, ftol_rel = 1e-12), lrtest=&quot;H04&quot;)

res$alternative$lr.test.pval

## H05
res &lt;- spm_time_dep(data, verbose=F, 
                    frm = list(at=&quot;-0.1&quot;, f1t=&quot;f1&quot;, Qt=&quot;Q&quot;, ft=&quot;f&quot;, bt=&quot;b&quot;, mu0t=&quot;mu0&quot;),
                    start=list(a=-0.05, f1=80, Q=1e-8, f=90, b=5, mu0=0.001), 
                    opts = list(algorithm = &quot;NLOPT_LN_NELDERMEAD&quot;, 
                    maxeval = 200, ftol_rel = 1e-12), lrtest=&quot;H05&quot;)

res$alternative$lr.test.pval
</code></pre>

<p>##References</p>

</body>

</html>
