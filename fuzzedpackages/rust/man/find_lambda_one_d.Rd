% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/box_cox_functions.R
\name{find_lambda_one_d}
\alias{find_lambda_one_d}
\title{Selecting Box-Cox parameter lambda in the one-dimensional case}
\usage{
find_lambda_one_d(
  logf,
  ...,
  ep_bc = 1e-04,
  min_phi = ep_bc,
  max_phi = 10,
  num = 1001,
  xdiv = 100,
  probs = seq(0.01, 0.99, by = 0.01),
  lambda_range = c(-3, 3),
  phi_to_theta = NULL,
  log_j = NULL
)
}
\arguments{
\item{logf}{A function returning the log of the target density f.}

\item{...}{further arguments to be passed to \code{logf} and related
functions.}

\item{ep_bc}{A (positive) numeric scalar. Smallest possible value of phi
to consider.  Used to avoid negative values of phi.}

\item{min_phi, max_phi}{Numeric scalars.  Smallest and largest values
of phi at which to evaluate logf, i.e. the range of values of phi over
which to evaluate logf. Any components in min_phi that are not positive
are set to ep_bc.}

\item{num}{A numeric scalar. Number of values at which to evaluate logf.}

\item{xdiv}{A numeric scalar.  Only values of phi at which the density f is
greater than the (maximum of f) / \code{xdiv} are used.}

\item{probs}{A numeric scalar. Probabilities at which to estimate the
quantiles of that will be used as data to find lambda.}

\item{lambda_range}{A numeric vector of length 2.  Range of lambda over
which to optimise.}

\item{phi_to_theta}{A function returning (inverse) of the transformation
from theta to phi used to ensure positivity of phi prior to Box-Cox
transformation.  The argument is phi and the returned value is theta.}

\item{log_j}{A function returning the log of the Jacobian of the
transformation from theta to phi, i.e. based on derivatives of phi with
respect to theta. Takes theta as its argument.
If this is not supplied then a constant Jacobian is used.}
}
\value{
A list containing the following components
  \item{lambda}{A numeric scalar.  The value of \code{lambda}.}
  \item{gm}{A numeric scalar.  Box-cox scaling parameter, estimated by the
    geometric mean of the quantiles used in the optimisation to find the
    value of lambda.}
  \item{init_psi}{A numeric scalar.  An initial estimate of the mode of the
    Box-Cox transformed density}
  \item{sd_psi}{A numeric scalar.  Estimates of the marginal standard
    deviations of the Box-Cox transformed variables.}
 \item{phi_to_theta}{as detailed above (only if \code{phi_to_theta} is
   supplied)}
 \item{log_j}{as detailed above (only if \code{log_j} is supplied)}
}
\description{
Finds a value of the Box-Cox transformation parameter lambda for which
the (positive univariate) random variable with log-density logf
has a density closer to that of a Gaussian random variable.
Works by estimating a set of quantiles of the distribution implied
by logf and treating those quantiles as data in a standard Box-Cox
analysis.  In the following we use theta to denote the argument of
logf on the original scale and phi on the Box-Cox transformed scale.
}
\details{
The general idea is to estimate quantiles of f corresponding to a
  set of equally-spaced probabilities in \code{probs} and to use these
  estimated quantiles as data in a standard estimation of the Box-Cox
  transformation parameter \code{lambda}.

  The density f is first evaluated at \code{num} points equally spaced over
  the interval (\code{min_phi}, \code{max_phi}).  The continuous density f
  is approximated by attaching trapezium-rule estimates of probabilities
  to the midpoints of the intervals between the points.  After standardizing
  to account for the fact that f may not be normalized,
  (\code{min_phi}, \code{max_phi}) is reset so that values with small
  estimated probability (determined by \code{xdiv}) are excluded and the
  procedure is repeated on this new range.  Then the required quantiles are
  estimated by inferring them from a weighted empirical distribution
  function based on treating the midpoints as data and the estimated
  probabilities at the midpoints as weights.
}
\examples{
# Log-normal density ===================

# Note: the default value of max_phi = 10 is OK here but this will not
# always be the case.

lambda <- find_lambda_one_d(logf = dlnorm, log = TRUE)
lambda
x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = "BC",
        lambda = lambda)

# Gamma density ===================

alpha <- 1
# Choose a sensible value of max_phi
max_phi <- qgamma(0.999, shape = alpha)
# [I appreciate that typically the quantile function won't be available.
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

lambda <- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,
                            max_phi = max_phi)
lambda
x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)

alpha <- 0.1
# NB. for alpha < 1 the gamma(alpha, beta) density is not bounded
# So the ratio-of-uniforms emthod can't be used but it may work after a
# Box-Cox transformation.
# find_lambda_one_d() works much better than find_lambda() here.

max_phi <- qgamma(0.999, shape = alpha)
lambda <- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,
                            max_phi = max_phi)
lambda
x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)

\donttest{
plot(x)
plot(x, ru_scale = TRUE)
}
}
\references{
Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
 Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
 211-252.

Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
 Transformations of Multivariate Data, Biometrics, 27(4).
}
\seealso{
\code{\link{ru}} and \code{\link{ru_rcpp}} to perform
  ratio-of-uniforms sampling.

\code{\link{find_lambda}} and \code{\link{find_lambda_rcpp}}
  to produce (somewhat) automatically
  a list for the argument \code{lambda} of \code{ru}/\code{ru_rcpp}
  for any value of \code{d}.

\code{\link{find_lambda_one_d_rcpp}} for a version of
  \code{\link{find_lambda_one_d}} that uses the Rcpp package to improve
  efficiency.
}
