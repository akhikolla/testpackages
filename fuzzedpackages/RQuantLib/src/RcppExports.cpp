// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/RQuantLib.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// affineWithRebuiltCurveEngine
Rcpp::List affineWithRebuiltCurveEngine(Rcpp::List rparam, Rcpp::List legparams, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec, Rcpp::NumericVector swaptionMat, Rcpp::NumericVector swapLengths, Rcpp::NumericVector swaptionVols);
RcppExport SEXP _RQuantLib_affineWithRebuiltCurveEngine(SEXP rparamSEXP, SEXP legparamsSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP swaptionMatSEXP, SEXP swapLengthsSEXP, SEXP swaptionVolsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type legparams(legparamsSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionMat(swaptionMatSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swapLengths(swapLengthsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionVols(swaptionVolsSEXP);
    rcpp_result_gen = Rcpp::wrap(affineWithRebuiltCurveEngine(rparam, legparams, dateVec, zeroVec, swaptionMat, swapLengths, swaptionVols));
    return rcpp_result_gen;
END_RCPP
}
// asianOptionEngine
Rcpp::List asianOptionEngine(std::string averageType, std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double first, double length, size_t fixings);
RcppExport SEXP _RQuantLib_asianOptionEngine(SEXP averageTypeSEXP, SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP firstSEXP, SEXP lengthSEXP, SEXP fixingsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type averageType(averageTypeSEXP);
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< double >::type first(firstSEXP);
    Rcpp::traits::input_parameter< double >::type length(lengthSEXP);
    Rcpp::traits::input_parameter< size_t >::type fixings(fixingsSEXP);
    rcpp_result_gen = Rcpp::wrap(asianOptionEngine(averageType, type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, first, length, fixings));
    return rcpp_result_gen;
END_RCPP
}
// binaryOptionEngine
Rcpp::List binaryOptionEngine(std::string binType, std::string type, std::string excType, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double cashPayoff);
RcppExport SEXP _RQuantLib_binaryOptionEngine(SEXP binTypeSEXP, SEXP typeSEXP, SEXP excTypeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP cashPayoffSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type binType(binTypeSEXP);
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< std::string >::type excType(excTypeSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< double >::type cashPayoff(cashPayoffSEXP);
    rcpp_result_gen = Rcpp::wrap(binaryOptionEngine(binType, type, excType, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, cashPayoff));
    return rcpp_result_gen;
END_RCPP
}
// binaryOptionImpliedVolatilityEngine
double binaryOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double cashPayoff);
RcppExport SEXP _RQuantLib_binaryOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP cashPayoffSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< double >::type cashPayoff(cashPayoffSEXP);
    rcpp_result_gen = Rcpp::wrap(binaryOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, cashPayoff));
    return rcpp_result_gen;
END_RCPP
}
// barrierOptionEngine
Rcpp::List barrierOptionEngine(std::string barrType, std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double barrier, double rebate);
RcppExport SEXP _RQuantLib_barrierOptionEngine(SEXP barrTypeSEXP, SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP barrierSEXP, SEXP rebateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type barrType(barrTypeSEXP);
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< double >::type barrier(barrierSEXP);
    Rcpp::traits::input_parameter< double >::type rebate(rebateSEXP);
    rcpp_result_gen = Rcpp::wrap(barrierOptionEngine(barrType, type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, barrier, rebate));
    return rcpp_result_gen;
END_RCPP
}
// bermudanFromYieldEngine
Rcpp::List bermudanFromYieldEngine(Rcpp::List rparam, Rcpp::NumericVector yield, Rcpp::NumericVector swaptionMat, Rcpp::NumericVector swapLengths, Rcpp::NumericMatrix swaptionVols);
RcppExport SEXP _RQuantLib_bermudanFromYieldEngine(SEXP rparamSEXP, SEXP yieldSEXP, SEXP swaptionMatSEXP, SEXP swapLengthsSEXP, SEXP swaptionVolsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type yield(yieldSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionMat(swaptionMatSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swapLengths(swapLengthsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type swaptionVols(swaptionVolsSEXP);
    rcpp_result_gen = Rcpp::wrap(bermudanFromYieldEngine(rparam, yield, swaptionMat, swapLengths, swaptionVols));
    return rcpp_result_gen;
END_RCPP
}
// bermudanWithRebuiltCurveEngine
Rcpp::List bermudanWithRebuiltCurveEngine(Rcpp::List rparam, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec, Rcpp::NumericVector swaptionMat, Rcpp::NumericVector swapLengths, Rcpp::NumericMatrix swaptionVols);
RcppExport SEXP _RQuantLib_bermudanWithRebuiltCurveEngine(SEXP rparamSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP swaptionMatSEXP, SEXP swapLengthsSEXP, SEXP swaptionVolsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionMat(swaptionMatSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swapLengths(swapLengthsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type swaptionVols(swaptionVolsSEXP);
    rcpp_result_gen = Rcpp::wrap(bermudanWithRebuiltCurveEngine(rparam, dateVec, zeroVec, swaptionMat, swapLengths, swaptionVols));
    return rcpp_result_gen;
END_RCPP
}
// zeroPriceByYieldEngine
double zeroPriceByYieldEngine(double yield, double faceAmount, double dayCounter, double frequency, double businessDayConvention, double compound, QuantLib::Date maturityDate, QuantLib::Date issueDate);
static SEXP _RQuantLib_zeroPriceByYieldEngine_try(SEXP yieldSEXP, SEXP faceAmountSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type yield(yieldSEXP);
    Rcpp::traits::input_parameter< double >::type faceAmount(faceAmountSEXP);
    Rcpp::traits::input_parameter< double >::type dayCounter(dayCounterSEXP);
    Rcpp::traits::input_parameter< double >::type frequency(frequencySEXP);
    Rcpp::traits::input_parameter< double >::type businessDayConvention(businessDayConventionSEXP);
    Rcpp::traits::input_parameter< double >::type compound(compoundSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturityDate(maturityDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP);
    rcpp_result_gen = Rcpp::wrap(zeroPriceByYieldEngine(yield, faceAmount, dayCounter, frequency, businessDayConvention, compound, maturityDate, issueDate));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_zeroPriceByYieldEngine(SEXP yieldSEXP, SEXP faceAmountSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_zeroPriceByYieldEngine_try(yieldSEXP, faceAmountSEXP, dayCounterSEXP, frequencySEXP, businessDayConventionSEXP, compoundSEXP, maturityDateSEXP, issueDateSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// zeroYieldByPriceEngine
double zeroYieldByPriceEngine(double price, double faceAmount, double dayCounter, double frequency, double businessDayConvention, double compound, QuantLib::Date maturityDate, QuantLib::Date issueDate);
static SEXP _RQuantLib_zeroYieldByPriceEngine_try(SEXP priceSEXP, SEXP faceAmountSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type price(priceSEXP);
    Rcpp::traits::input_parameter< double >::type faceAmount(faceAmountSEXP);
    Rcpp::traits::input_parameter< double >::type dayCounter(dayCounterSEXP);
    Rcpp::traits::input_parameter< double >::type frequency(frequencySEXP);
    Rcpp::traits::input_parameter< double >::type businessDayConvention(businessDayConventionSEXP);
    Rcpp::traits::input_parameter< double >::type compound(compoundSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturityDate(maturityDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP);
    rcpp_result_gen = Rcpp::wrap(zeroYieldByPriceEngine(price, faceAmount, dayCounter, frequency, businessDayConvention, compound, maturityDate, issueDate));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_zeroYieldByPriceEngine(SEXP priceSEXP, SEXP faceAmountSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_zeroYieldByPriceEngine_try(priceSEXP, faceAmountSEXP, dayCounterSEXP, frequencySEXP, businessDayConventionSEXP, compoundSEXP, maturityDateSEXP, issueDateSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fixedRateBondYieldByPriceEngine
double fixedRateBondYieldByPriceEngine(double settlementDays, double price, std::string cal, double faceAmount, double businessDayConvention, double compound, double redemption, double dayCounter, double frequency, QuantLib::Date maturityDate, QuantLib::Date issueDate, QuantLib::Date effectiveDate, std::vector<double> rates);
static SEXP _RQuantLib_fixedRateBondYieldByPriceEngine_try(SEXP settlementDaysSEXP, SEXP priceSEXP, SEXP calSEXP, SEXP faceAmountSEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP redemptionSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP, SEXP effectiveDateSEXP, SEXP ratesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type settlementDays(settlementDaysSEXP);
    Rcpp::traits::input_parameter< double >::type price(priceSEXP);
    Rcpp::traits::input_parameter< std::string >::type cal(calSEXP);
    Rcpp::traits::input_parameter< double >::type faceAmount(faceAmountSEXP);
    Rcpp::traits::input_parameter< double >::type businessDayConvention(businessDayConventionSEXP);
    Rcpp::traits::input_parameter< double >::type compound(compoundSEXP);
    Rcpp::traits::input_parameter< double >::type redemption(redemptionSEXP);
    Rcpp::traits::input_parameter< double >::type dayCounter(dayCounterSEXP);
    Rcpp::traits::input_parameter< double >::type frequency(frequencySEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturityDate(maturityDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type effectiveDate(effectiveDateSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type rates(ratesSEXP);
    rcpp_result_gen = Rcpp::wrap(fixedRateBondYieldByPriceEngine(settlementDays, price, cal, faceAmount, businessDayConvention, compound, redemption, dayCounter, frequency, maturityDate, issueDate, effectiveDate, rates));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_fixedRateBondYieldByPriceEngine(SEXP settlementDaysSEXP, SEXP priceSEXP, SEXP calSEXP, SEXP faceAmountSEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP redemptionSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP, SEXP effectiveDateSEXP, SEXP ratesSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_fixedRateBondYieldByPriceEngine_try(settlementDaysSEXP, priceSEXP, calSEXP, faceAmountSEXP, businessDayConventionSEXP, compoundSEXP, redemptionSEXP, dayCounterSEXP, frequencySEXP, maturityDateSEXP, issueDateSEXP, effectiveDateSEXP, ratesSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fixedRateBondPriceByYieldEngine
double fixedRateBondPriceByYieldEngine(double settlementDays, double yield, std::string cal, double faceAmount, double businessDayConvention, double compound, double redemption, double dayCounter, double frequency, QuantLib::Date maturityDate, QuantLib::Date issueDate, QuantLib::Date effectiveDate, std::vector<double> rates);
static SEXP _RQuantLib_fixedRateBondPriceByYieldEngine_try(SEXP settlementDaysSEXP, SEXP yieldSEXP, SEXP calSEXP, SEXP faceAmountSEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP redemptionSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP, SEXP effectiveDateSEXP, SEXP ratesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< double >::type settlementDays(settlementDaysSEXP);
    Rcpp::traits::input_parameter< double >::type yield(yieldSEXP);
    Rcpp::traits::input_parameter< std::string >::type cal(calSEXP);
    Rcpp::traits::input_parameter< double >::type faceAmount(faceAmountSEXP);
    Rcpp::traits::input_parameter< double >::type businessDayConvention(businessDayConventionSEXP);
    Rcpp::traits::input_parameter< double >::type compound(compoundSEXP);
    Rcpp::traits::input_parameter< double >::type redemption(redemptionSEXP);
    Rcpp::traits::input_parameter< double >::type dayCounter(dayCounterSEXP);
    Rcpp::traits::input_parameter< double >::type frequency(frequencySEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturityDate(maturityDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type effectiveDate(effectiveDateSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type rates(ratesSEXP);
    rcpp_result_gen = Rcpp::wrap(fixedRateBondPriceByYieldEngine(settlementDays, yield, cal, faceAmount, businessDayConvention, compound, redemption, dayCounter, frequency, maturityDate, issueDate, effectiveDate, rates));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_fixedRateBondPriceByYieldEngine(SEXP settlementDaysSEXP, SEXP yieldSEXP, SEXP calSEXP, SEXP faceAmountSEXP, SEXP businessDayConventionSEXP, SEXP compoundSEXP, SEXP redemptionSEXP, SEXP dayCounterSEXP, SEXP frequencySEXP, SEXP maturityDateSEXP, SEXP issueDateSEXP, SEXP effectiveDateSEXP, SEXP ratesSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_fixedRateBondPriceByYieldEngine_try(settlementDaysSEXP, yieldSEXP, calSEXP, faceAmountSEXP, businessDayConventionSEXP, compoundSEXP, redemptionSEXP, dayCounterSEXP, frequencySEXP, maturityDateSEXP, issueDateSEXP, effectiveDateSEXP, ratesSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FloatBond1
Rcpp::List FloatBond1(Rcpp::List bond, std::vector<double> gearings, std::vector<double> caps, std::vector<double> spreads, std::vector<double> floors, Rcpp::List indexparams, Rcpp::List index, Rcpp::List discountCurve, Rcpp::List dateparams);
static SEXP _RQuantLib_FloatBond1_try(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP indexSEXP, SEXP discountCurveSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bond(bondSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type gearings(gearingsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type caps(capsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type floors(floorsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type indexparams(indexparamsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index(indexSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type discountCurve(discountCurveSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(FloatBond1(bond, gearings, caps, spreads, floors, indexparams, index, discountCurve, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FloatBond1(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP indexSEXP, SEXP discountCurveSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FloatBond1_try(bondSEXP, gearingsSEXP, capsSEXP, spreadsSEXP, floorsSEXP, indexparamsSEXP, indexSEXP, discountCurveSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FloatBond2
Rcpp::List FloatBond2(Rcpp::List bond, std::vector<double> gearings, std::vector<double> caps, std::vector<double> spreads, std::vector<double> floors, Rcpp::List indexparams, Rcpp::List index_params, Rcpp::List index_tsQuotes, Rcpp::List index_times, Rcpp::List discountCurve, Rcpp::List dateparams);
static SEXP _RQuantLib_FloatBond2_try(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP index_paramsSEXP, SEXP index_tsQuotesSEXP, SEXP index_timesSEXP, SEXP discountCurveSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bond(bondSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type gearings(gearingsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type caps(capsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type floors(floorsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type indexparams(indexparamsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_params(index_paramsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_tsQuotes(index_tsQuotesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_times(index_timesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type discountCurve(discountCurveSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(FloatBond2(bond, gearings, caps, spreads, floors, indexparams, index_params, index_tsQuotes, index_times, discountCurve, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FloatBond2(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP index_paramsSEXP, SEXP index_tsQuotesSEXP, SEXP index_timesSEXP, SEXP discountCurveSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FloatBond2_try(bondSEXP, gearingsSEXP, capsSEXP, spreadsSEXP, floorsSEXP, indexparamsSEXP, index_paramsSEXP, index_tsQuotesSEXP, index_timesSEXP, discountCurveSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FloatBond3
Rcpp::List FloatBond3(Rcpp::List bond, std::vector<double> gearings, std::vector<double> caps, std::vector<double> spreads, std::vector<double> floors, Rcpp::List indexparams, Rcpp::List index, Rcpp::List disc_params, Rcpp::List disc_tsQuotes, Rcpp::List disc_times, Rcpp::List dateparams);
static SEXP _RQuantLib_FloatBond3_try(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP indexSEXP, SEXP disc_paramsSEXP, SEXP disc_tsQuotesSEXP, SEXP disc_timesSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bond(bondSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type gearings(gearingsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type caps(capsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type floors(floorsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type indexparams(indexparamsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index(indexSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_params(disc_paramsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_tsQuotes(disc_tsQuotesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_times(disc_timesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(FloatBond3(bond, gearings, caps, spreads, floors, indexparams, index, disc_params, disc_tsQuotes, disc_times, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FloatBond3(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP indexSEXP, SEXP disc_paramsSEXP, SEXP disc_tsQuotesSEXP, SEXP disc_timesSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FloatBond3_try(bondSEXP, gearingsSEXP, capsSEXP, spreadsSEXP, floorsSEXP, indexparamsSEXP, indexSEXP, disc_paramsSEXP, disc_tsQuotesSEXP, disc_timesSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FloatBond4
Rcpp::List FloatBond4(Rcpp::List bond, std::vector<double> gearings, std::vector<double> caps, std::vector<double> spreads, std::vector<double> floors, Rcpp::List indexparams, Rcpp::List index_params, Rcpp::List index_tsQuotes, Rcpp::List index_times, Rcpp::List disc_params, Rcpp::List disc_tsQuotes, Rcpp::List disc_times, Rcpp::List dateparams);
static SEXP _RQuantLib_FloatBond4_try(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP index_paramsSEXP, SEXP index_tsQuotesSEXP, SEXP index_timesSEXP, SEXP disc_paramsSEXP, SEXP disc_tsQuotesSEXP, SEXP disc_timesSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bond(bondSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type gearings(gearingsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type caps(capsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type floors(floorsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type indexparams(indexparamsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_params(index_paramsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_tsQuotes(index_tsQuotesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type index_times(index_timesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_params(disc_paramsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_tsQuotes(disc_tsQuotesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type disc_times(disc_timesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(FloatBond4(bond, gearings, caps, spreads, floors, indexparams, index_params, index_tsQuotes, index_times, disc_params, disc_tsQuotes, disc_times, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FloatBond4(SEXP bondSEXP, SEXP gearingsSEXP, SEXP capsSEXP, SEXP spreadsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP index_paramsSEXP, SEXP index_tsQuotesSEXP, SEXP index_timesSEXP, SEXP disc_paramsSEXP, SEXP disc_tsQuotesSEXP, SEXP disc_timesSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FloatBond4_try(bondSEXP, gearingsSEXP, capsSEXP, spreadsSEXP, floorsSEXP, indexparamsSEXP, index_paramsSEXP, index_tsQuotesSEXP, index_timesSEXP, disc_paramsSEXP, disc_tsQuotesSEXP, disc_timesSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// floatingWithRebuiltCurveEngine
Rcpp::List floatingWithRebuiltCurveEngine(Rcpp::List bondparams, std::vector<double> gearings, std::vector<double> spreads, std::vector<double> caps, std::vector<double> floors, Rcpp::List indexparams, std::vector<QuantLib::Date> iborDateVec, std::vector<double> iborzeroVec, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec, Rcpp::List dateparams);
static SEXP _RQuantLib_floatingWithRebuiltCurveEngine_try(SEXP bondparamsSEXP, SEXP gearingsSEXP, SEXP spreadsSEXP, SEXP capsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP iborDateVecSEXP, SEXP iborzeroVecSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bondparams(bondparamsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type gearings(gearingsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type caps(capsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type floors(floorsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type indexparams(indexparamsSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type iborDateVec(iborDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type iborzeroVec(iborzeroVecSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(floatingWithRebuiltCurveEngine(bondparams, gearings, spreads, caps, floors, indexparams, iborDateVec, iborzeroVec, dateVec, zeroVec, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_floatingWithRebuiltCurveEngine(SEXP bondparamsSEXP, SEXP gearingsSEXP, SEXP spreadsSEXP, SEXP capsSEXP, SEXP floorsSEXP, SEXP indexparamsSEXP, SEXP iborDateVecSEXP, SEXP iborzeroVecSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_floatingWithRebuiltCurveEngine_try(bondparamsSEXP, gearingsSEXP, spreadsSEXP, capsSEXP, floorsSEXP, indexparamsSEXP, iborDateVecSEXP, iborzeroVecSEXP, dateVecSEXP, zeroVecSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FixedRateWithYield
Rcpp::List FixedRateWithYield(Rcpp::List bondparam, std::vector<double> ratesVec, Rcpp::List scheduleparam, Rcpp::List calcparam, double yield);
static SEXP _RQuantLib_FixedRateWithYield_try(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP yieldSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bondparam(bondparamSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type ratesVec(ratesVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type scheduleparam(scheduleparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type calcparam(calcparamSEXP);
    Rcpp::traits::input_parameter< double >::type yield(yieldSEXP);
    rcpp_result_gen = Rcpp::wrap(FixedRateWithYield(bondparam, ratesVec, scheduleparam, calcparam, yield));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FixedRateWithYield(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP yieldSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FixedRateWithYield_try(bondparamSEXP, ratesVecSEXP, scheduleparamSEXP, calcparamSEXP, yieldSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FixedRateWithPrice
Rcpp::List FixedRateWithPrice(Rcpp::List bondparam, std::vector<double> ratesVec, Rcpp::List scheduleparam, Rcpp::List calcparam, double price);
static SEXP _RQuantLib_FixedRateWithPrice_try(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP priceSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bondparam(bondparamSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type ratesVec(ratesVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type scheduleparam(scheduleparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type calcparam(calcparamSEXP);
    Rcpp::traits::input_parameter< double >::type price(priceSEXP);
    rcpp_result_gen = Rcpp::wrap(FixedRateWithPrice(bondparam, ratesVec, scheduleparam, calcparam, price));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FixedRateWithPrice(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP priceSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FixedRateWithPrice_try(bondparamSEXP, ratesVecSEXP, scheduleparamSEXP, calcparamSEXP, priceSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// FixedRateWithRebuiltCurve
Rcpp::List FixedRateWithRebuiltCurve(Rcpp::List bondparam, std::vector<double> ratesVec, Rcpp::List scheduleparam, Rcpp::List calcparam, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec);
static SEXP _RQuantLib_FixedRateWithRebuiltCurve_try(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bondparam(bondparamSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type ratesVec(ratesVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type scheduleparam(scheduleparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type calcparam(calcparamSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    rcpp_result_gen = Rcpp::wrap(FixedRateWithRebuiltCurve(bondparam, ratesVec, scheduleparam, calcparam, dateVec, zeroVec));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_FixedRateWithRebuiltCurve(SEXP bondparamSEXP, SEXP ratesVecSEXP, SEXP scheduleparamSEXP, SEXP calcparamSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_FixedRateWithRebuiltCurve_try(bondparamSEXP, ratesVecSEXP, scheduleparamSEXP, calcparamSEXP, dateVecSEXP, zeroVecSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// ZeroBondWithRebuiltCurve
Rcpp::List ZeroBondWithRebuiltCurve(Rcpp::List bond, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec, Rcpp::List dateparams);
static SEXP _RQuantLib_ZeroBondWithRebuiltCurve_try(SEXP bondSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP dateparamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type bond(bondSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type dateparams(dateparamsSEXP);
    rcpp_result_gen = Rcpp::wrap(ZeroBondWithRebuiltCurve(bond, dateVec, zeroVec, dateparams));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_ZeroBondWithRebuiltCurve(SEXP bondSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP dateparamsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_ZeroBondWithRebuiltCurve_try(bondSEXP, dateVecSEXP, zeroVecSEXP, dateparamsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// convertibleZeroBondEngine
Rcpp::List convertibleZeroBondEngine(Rcpp::List rparam, Rcpp::List processParam, std::vector<QuantLib::Date> dividendYieldDateVec, std::vector<double> dividendYieldZeroVec, std::vector<QuantLib::Date> rffDateVec, std::vector<double> rffZeroVec, Rcpp::DataFrame dividendScheduleFrame, Rcpp::DataFrame callabilityScheduleFrame, Rcpp::List datemisc);
static SEXP _RQuantLib_convertibleZeroBondEngine_try(SEXP rparamSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type processParam(processParamSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dividendYieldDateVec(dividendYieldDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type dividendYieldZeroVec(dividendYieldZeroVecSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type rffDateVec(rffDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type rffZeroVec(rffZeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type dividendScheduleFrame(dividendScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type callabilityScheduleFrame(callabilityScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type datemisc(datemiscSEXP);
    rcpp_result_gen = Rcpp::wrap(convertibleZeroBondEngine(rparam, processParam, dividendYieldDateVec, dividendYieldZeroVec, rffDateVec, rffZeroVec, dividendScheduleFrame, callabilityScheduleFrame, datemisc));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_convertibleZeroBondEngine(SEXP rparamSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_convertibleZeroBondEngine_try(rparamSEXP, processParamSEXP, dividendYieldDateVecSEXP, dividendYieldZeroVecSEXP, rffDateVecSEXP, rffZeroVecSEXP, dividendScheduleFrameSEXP, callabilityScheduleFrameSEXP, datemiscSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// convertibleFixedBondEngine
Rcpp::List convertibleFixedBondEngine(Rcpp::List rparam, Rcpp::NumericVector rates, Rcpp::List processParam, std::vector<QuantLib::Date> dividendYieldDateVec, std::vector<double> dividendYieldZeroVec, std::vector<QuantLib::Date> rffDateVec, std::vector<double> rffZeroVec, Rcpp::DataFrame dividendScheduleFrame, Rcpp::DataFrame callabilityScheduleFrame, Rcpp::List datemisc);
static SEXP _RQuantLib_convertibleFixedBondEngine_try(SEXP rparamSEXP, SEXP ratesSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type rates(ratesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type processParam(processParamSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dividendYieldDateVec(dividendYieldDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type dividendYieldZeroVec(dividendYieldZeroVecSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type rffDateVec(rffDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type rffZeroVec(rffZeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type dividendScheduleFrame(dividendScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type callabilityScheduleFrame(callabilityScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type datemisc(datemiscSEXP);
    rcpp_result_gen = Rcpp::wrap(convertibleFixedBondEngine(rparam, rates, processParam, dividendYieldDateVec, dividendYieldZeroVec, rffDateVec, rffZeroVec, dividendScheduleFrame, callabilityScheduleFrame, datemisc));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_convertibleFixedBondEngine(SEXP rparamSEXP, SEXP ratesSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_convertibleFixedBondEngine_try(rparamSEXP, ratesSEXP, processParamSEXP, dividendYieldDateVecSEXP, dividendYieldZeroVecSEXP, rffDateVecSEXP, rffZeroVecSEXP, dividendScheduleFrameSEXP, callabilityScheduleFrameSEXP, datemiscSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// convertibleFloatingBondEngine
Rcpp::List convertibleFloatingBondEngine(Rcpp::List rparam, Rcpp::List processParam, std::vector<QuantLib::Date> dividendYieldDateVec, std::vector<double> dividendYieldZeroVec, std::vector<QuantLib::Date> rffDateVec, std::vector<double> rffZeroVec, std::vector<QuantLib::Date> iborIndexDateVec, std::vector<double> iborIndexZeroVec, Rcpp::List iborparams, std::vector<double> spreads, Rcpp::DataFrame dividendScheduleFrame, Rcpp::DataFrame callabilityScheduleFrame, Rcpp::List datemisc);
static SEXP _RQuantLib_convertibleFloatingBondEngine_try(SEXP rparamSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP iborIndexDateVecSEXP, SEXP iborIndexZeroVecSEXP, SEXP iborparamsSEXP, SEXP spreadsSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type processParam(processParamSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dividendYieldDateVec(dividendYieldDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type dividendYieldZeroVec(dividendYieldZeroVecSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type rffDateVec(rffDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type rffZeroVec(rffZeroVecSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type iborIndexDateVec(iborIndexDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type iborIndexZeroVec(iborIndexZeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type iborparams(iborparamsSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type spreads(spreadsSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type dividendScheduleFrame(dividendScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type callabilityScheduleFrame(callabilityScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type datemisc(datemiscSEXP);
    rcpp_result_gen = Rcpp::wrap(convertibleFloatingBondEngine(rparam, processParam, dividendYieldDateVec, dividendYieldZeroVec, rffDateVec, rffZeroVec, iborIndexDateVec, iborIndexZeroVec, iborparams, spreads, dividendScheduleFrame, callabilityScheduleFrame, datemisc));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_convertibleFloatingBondEngine(SEXP rparamSEXP, SEXP processParamSEXP, SEXP dividendYieldDateVecSEXP, SEXP dividendYieldZeroVecSEXP, SEXP rffDateVecSEXP, SEXP rffZeroVecSEXP, SEXP iborIndexDateVecSEXP, SEXP iborIndexZeroVecSEXP, SEXP iborparamsSEXP, SEXP spreadsSEXP, SEXP dividendScheduleFrameSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_convertibleFloatingBondEngine_try(rparamSEXP, processParamSEXP, dividendYieldDateVecSEXP, dividendYieldZeroVecSEXP, rffDateVecSEXP, rffZeroVecSEXP, iborIndexDateVecSEXP, iborIndexZeroVecSEXP, iborparamsSEXP, spreadsSEXP, dividendScheduleFrameSEXP, callabilityScheduleFrameSEXP, datemiscSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// callableBondEngine
Rcpp::List callableBondEngine(Rcpp::List rparam, Rcpp::List hwparam, Rcpp::NumericVector coupon, Rcpp::DataFrame callabilityScheduleFrame, Rcpp::List datemisc);
static SEXP _RQuantLib_callableBondEngine_try(SEXP rparamSEXP, SEXP hwparamSEXP, SEXP couponSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type hwparam(hwparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type coupon(couponSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type callabilityScheduleFrame(callabilityScheduleFrameSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type datemisc(datemiscSEXP);
    rcpp_result_gen = Rcpp::wrap(callableBondEngine(rparam, hwparam, coupon, callabilityScheduleFrame, datemisc));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_callableBondEngine(SEXP rparamSEXP, SEXP hwparamSEXP, SEXP couponSEXP, SEXP callabilityScheduleFrameSEXP, SEXP datemiscSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_callableBondEngine_try(rparamSEXP, hwparamSEXP, couponSEXP, callabilityScheduleFrameSEXP, datemiscSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// fittedBondCurveEngine
Rcpp::List fittedBondCurveEngine(Rcpp::List curveparam, Rcpp::NumericVector length, Rcpp::NumericVector coupons, Rcpp::NumericVector marketQuotes, Rcpp::List datemisc);
static SEXP _RQuantLib_fittedBondCurveEngine_try(SEXP curveparamSEXP, SEXP lengthSEXP, SEXP couponsSEXP, SEXP marketQuotesSEXP, SEXP datemiscSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type curveparam(curveparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type length(lengthSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type coupons(couponsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type marketQuotes(marketQuotesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type datemisc(datemiscSEXP);
    rcpp_result_gen = Rcpp::wrap(fittedBondCurveEngine(curveparam, length, coupons, marketQuotes, datemisc));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_fittedBondCurveEngine(SEXP curveparamSEXP, SEXP lengthSEXP, SEXP couponsSEXP, SEXP marketQuotesSEXP, SEXP datemiscSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_fittedBondCurveEngine_try(curveparamSEXP, lengthSEXP, couponsSEXP, marketQuotesSEXP, datemiscSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// setCalendarContext
bool setCalendarContext(std::string calendar, int fixingDays, QuantLib::Date settleDate);
RcppExport SEXP _RQuantLib_setCalendarContext(SEXP calendarSEXP, SEXP fixingDaysSEXP, SEXP settleDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< int >::type fixingDays(fixingDaysSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type settleDate(settleDateSEXP);
    rcpp_result_gen = Rcpp::wrap(setCalendarContext(calendar, fixingDays, settleDate));
    return rcpp_result_gen;
END_RCPP
}
// isBusinessDay
std::vector<bool> isBusinessDay(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_isBusinessDay(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(isBusinessDay(calendar, dates));
    return rcpp_result_gen;
END_RCPP
}
// isHoliday
std::vector<bool> isHoliday(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_isHoliday(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(isHoliday(calendar, dates));
    return rcpp_result_gen;
END_RCPP
}
// isWeekend
std::vector<bool> isWeekend(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_isWeekend(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(isWeekend(calendar, dates));
    return rcpp_result_gen;
END_RCPP
}
// isEndOfMonth
std::vector<bool> isEndOfMonth(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_isEndOfMonth(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(isEndOfMonth(calendar, dates));
    return rcpp_result_gen;
END_RCPP
}
// getEndOfMonth
std::vector<QuantLib::Date> getEndOfMonth(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_getEndOfMonth(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(getEndOfMonth(calendar, dates));
    return rcpp_result_gen;
END_RCPP
}
// adjust
std::vector<QuantLib::Date> adjust(std::string calendar, std::vector<QuantLib::Date> dates, int bdc);
RcppExport SEXP _RQuantLib_adjust(SEXP calendarSEXP, SEXP datesSEXP, SEXP bdcSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    Rcpp::traits::input_parameter< int >::type bdc(bdcSEXP);
    rcpp_result_gen = Rcpp::wrap(adjust(calendar, dates, bdc));
    return rcpp_result_gen;
END_RCPP
}
// advance1
std::vector<QuantLib::Date> advance1(std::string calendar, double amount, double unit, int bdcVal, double emr, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_advance1(SEXP calendarSEXP, SEXP amountSEXP, SEXP unitSEXP, SEXP bdcValSEXP, SEXP emrSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< double >::type amount(amountSEXP);
    Rcpp::traits::input_parameter< double >::type unit(unitSEXP);
    Rcpp::traits::input_parameter< int >::type bdcVal(bdcValSEXP);
    Rcpp::traits::input_parameter< double >::type emr(emrSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(advance1(calendar, amount, unit, bdcVal, emr, dates));
    return rcpp_result_gen;
END_RCPP
}
// advance2
std::vector<QuantLib::Date> advance2(std::string calendar, double period, int bdcVal, double emr, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_advance2(SEXP calendarSEXP, SEXP periodSEXP, SEXP bdcValSEXP, SEXP emrSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< double >::type period(periodSEXP);
    Rcpp::traits::input_parameter< int >::type bdcVal(bdcValSEXP);
    Rcpp::traits::input_parameter< double >::type emr(emrSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    rcpp_result_gen = Rcpp::wrap(advance2(calendar, period, bdcVal, emr, dates));
    return rcpp_result_gen;
END_RCPP
}
// businessDaysBetween
std::vector<double> businessDaysBetween(std::string calendar, std::vector<QuantLib::Date> from, std::vector<QuantLib::Date> to, bool includeFirst, bool includeLast);
RcppExport SEXP _RQuantLib_businessDaysBetween(SEXP calendarSEXP, SEXP fromSEXP, SEXP toSEXP, SEXP includeFirstSEXP, SEXP includeLastSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type from(fromSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type to(toSEXP);
    Rcpp::traits::input_parameter< bool >::type includeFirst(includeFirstSEXP);
    Rcpp::traits::input_parameter< bool >::type includeLast(includeLastSEXP);
    rcpp_result_gen = Rcpp::wrap(businessDaysBetween(calendar, from, to, includeFirst, includeLast));
    return rcpp_result_gen;
END_RCPP
}
// getHolidayList
std::vector<QuantLib::Date> getHolidayList(std::string calendar, QuantLib::Date from, QuantLib::Date to, bool includeWeekends);
RcppExport SEXP _RQuantLib_getHolidayList(SEXP calendarSEXP, SEXP fromSEXP, SEXP toSEXP, SEXP includeWeekendsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type from(fromSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type to(toSEXP);
    Rcpp::traits::input_parameter< bool >::type includeWeekends(includeWeekendsSEXP);
    rcpp_result_gen = Rcpp::wrap(getHolidayList(calendar, from, to, includeWeekends));
    return rcpp_result_gen;
END_RCPP
}
// addHolidays
void addHolidays(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_addHolidays(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    addHolidays(calendar, dates);
    return R_NilValue;
END_RCPP
}
// removeHolidays
void removeHolidays(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP _RQuantLib_removeHolidays(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP);
    removeHolidays(calendar, dates);
    return R_NilValue;
END_RCPP
}
// advanceDate
QuantLib::Date advanceDate(QuantLib::Date issueDate, int days);
static SEXP _RQuantLib_advanceDate_try(SEXP issueDateSEXP, SEXP daysSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP);
    Rcpp::traits::input_parameter< int >::type days(daysSEXP);
    rcpp_result_gen = Rcpp::wrap(advanceDate(issueDate, days));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_advanceDate(SEXP issueDateSEXP, SEXP daysSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_advanceDate_try(issueDateSEXP, daysSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// dayCount
std::vector<double> dayCount(std::vector<QuantLib::Date> startDates, std::vector<QuantLib::Date> endDates, std::vector<double> dayCounters);
static SEXP _RQuantLib_dayCount_try(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type startDates(startDatesSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type endDates(endDatesSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type dayCounters(dayCountersSEXP);
    rcpp_result_gen = Rcpp::wrap(dayCount(startDates, endDates, dayCounters));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_dayCount(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_dayCount_try(startDatesSEXP, endDatesSEXP, dayCountersSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// yearFraction
std::vector<double> yearFraction(std::vector<QuantLib::Date> startDates, std::vector<QuantLib::Date> endDates, std::vector<double> dayCounters);
static SEXP _RQuantLib_yearFraction_try(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type startDates(startDatesSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type endDates(endDatesSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type dayCounters(dayCountersSEXP);
    rcpp_result_gen = Rcpp::wrap(yearFraction(startDates, endDates, dayCounters));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_yearFraction(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_yearFraction_try(startDatesSEXP, endDatesSEXP, dayCountersSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// setEvaluationDate
bool setEvaluationDate(QuantLib::Date evalDate);
static SEXP _RQuantLib_setEvaluationDate_try(SEXP evalDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP);
    rcpp_result_gen = Rcpp::wrap(setEvaluationDate(evalDate));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_setEvaluationDate(SEXP evalDateSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_setEvaluationDate_try(evalDateSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// discountCurveEngine
Rcpp::List discountCurveEngine(Rcpp::List rparams, Rcpp::List tslist, Rcpp::NumericVector times, Rcpp::List legParams);
RcppExport SEXP _RQuantLib_discountCurveEngine(SEXP rparamsSEXP, SEXP tslistSEXP, SEXP timesSEXP, SEXP legParamsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparams(rparamsSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type tslist(tslistSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type times(timesSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type legParams(legParamsSEXP);
    rcpp_result_gen = Rcpp::wrap(discountCurveEngine(rparams, tslist, times, legParams));
    return rcpp_result_gen;
END_RCPP
}
// calibrateHullWhiteUsingCapsEngine
Rcpp::List calibrateHullWhiteUsingCapsEngine(std::vector<QuantLib::Date> termStrcDateVec, std::vector<double> termStrcZeroVec, Rcpp::DataFrame capDF, std::vector<QuantLib::Date> iborDateVec, std::vector<double> iborZeroVec, std::string iborType, QuantLib::Date evalDate);
RcppExport SEXP _RQuantLib_calibrateHullWhiteUsingCapsEngine(SEXP termStrcDateVecSEXP, SEXP termStrcZeroVecSEXP, SEXP capDFSEXP, SEXP iborDateVecSEXP, SEXP iborZeroVecSEXP, SEXP iborTypeSEXP, SEXP evalDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type termStrcDateVec(termStrcDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type termStrcZeroVec(termStrcZeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type capDF(capDFSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type iborDateVec(iborDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type iborZeroVec(iborZeroVecSEXP);
    Rcpp::traits::input_parameter< std::string >::type iborType(iborTypeSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP);
    rcpp_result_gen = Rcpp::wrap(calibrateHullWhiteUsingCapsEngine(termStrcDateVec, termStrcZeroVec, capDF, iborDateVec, iborZeroVec, iborType, evalDate));
    return rcpp_result_gen;
END_RCPP
}
// calibrateHullWhiteUsingSwapsEngine
Rcpp::List calibrateHullWhiteUsingSwapsEngine(std::vector<QuantLib::Date> termStrcDateVec, std::vector<double> termStrcZeroVec, Rcpp::DataFrame swapDF, std::vector<QuantLib::Date> iborDateVec, std::vector<double> iborZeroVec, std::string iborType, QuantLib::Date evalDate);
RcppExport SEXP _RQuantLib_calibrateHullWhiteUsingSwapsEngine(SEXP termStrcDateVecSEXP, SEXP termStrcZeroVecSEXP, SEXP swapDFSEXP, SEXP iborDateVecSEXP, SEXP iborZeroVecSEXP, SEXP iborTypeSEXP, SEXP evalDateSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type termStrcDateVec(termStrcDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type termStrcZeroVec(termStrcZeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::DataFrame >::type swapDF(swapDFSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type iborDateVec(iborDateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type iborZeroVec(iborZeroVecSEXP);
    Rcpp::traits::input_parameter< std::string >::type iborType(iborTypeSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP);
    rcpp_result_gen = Rcpp::wrap(calibrateHullWhiteUsingSwapsEngine(termStrcDateVec, termStrcZeroVec, swapDF, iborDateVec, iborZeroVec, iborType, evalDate));
    return rcpp_result_gen;
END_RCPP
}
// europeanOptionImpliedVolatilityEngine
double europeanOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility);
static SEXP _RQuantLib_europeanOptionImpliedVolatilityEngine_try(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    rcpp_result_gen = Rcpp::wrap(europeanOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volatility));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_europeanOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_europeanOptionImpliedVolatilityEngine_try(typeSEXP, valueSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volatilitySEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// americanOptionImpliedVolatilityEngine
double americanOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volguess, int timesteps, int gridpoints);
static SEXP _RQuantLib_americanOptionImpliedVolatilityEngine_try(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volguessSEXP, SEXP timestepsSEXP, SEXP gridpointsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type value(valueSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volguess(volguessSEXP);
    Rcpp::traits::input_parameter< int >::type timesteps(timestepsSEXP);
    Rcpp::traits::input_parameter< int >::type gridpoints(gridpointsSEXP);
    rcpp_result_gen = Rcpp::wrap(americanOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volguess, timesteps, gridpoints));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_americanOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volguessSEXP, SEXP timestepsSEXP, SEXP gridpointsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_americanOptionImpliedVolatilityEngine_try(typeSEXP, valueSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volguessSEXP, timestepsSEXP, gridpointsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sabrengine
Rcpp::List sabrengine(Rcpp::List rparam, Rcpp::List legParams, std::vector<QuantLib::Date> dateVec, std::vector<double> zeroVec, Rcpp::NumericVector swaptionMat, Rcpp::NumericVector swapLengths, Rcpp::NumericMatrix atmVols, Rcpp::NumericVector strikes, Rcpp::NumericMatrix smirkVols);
RcppExport SEXP _RQuantLib_sabrengine(SEXP rparamSEXP, SEXP legParamsSEXP, SEXP dateVecSEXP, SEXP zeroVecSEXP, SEXP swaptionMatSEXP, SEXP swapLengthsSEXP, SEXP atmVolsSEXP, SEXP strikesSEXP, SEXP smirkVolsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP);
    Rcpp::traits::input_parameter< Rcpp::List >::type legParams(legParamsSEXP);
    Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dateVec(dateVecSEXP);
    Rcpp::traits::input_parameter< std::vector<double> >::type zeroVec(zeroVecSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionMat(swaptionMatSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swapLengths(swapLengthsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type atmVols(atmVolsSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type strikes(strikesSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type smirkVols(smirkVolsSEXP);
    rcpp_result_gen = Rcpp::wrap(sabrengine(rparam, legParams, dateVec, zeroVec, swaptionMat, swapLengths, atmVols, strikes, smirkVols));
    return rcpp_result_gen;
END_RCPP
}
// CreateSchedule
Rcpp::DateVector CreateSchedule(Rcpp::List params);
static SEXP _RQuantLib_CreateSchedule_try(SEXP paramsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::List >::type params(paramsSEXP);
    rcpp_result_gen = Rcpp::wrap(CreateSchedule(params));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_CreateSchedule(SEXP paramsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_CreateSchedule_try(paramsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// getQuantLibVersion
std::string getQuantLibVersion();
static SEXP _RQuantLib_getQuantLibVersion_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(getQuantLibVersion());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_getQuantLibVersion() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_getQuantLibVersion_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// getQuantLibCapabilities
Rcpp::LogicalVector getQuantLibCapabilities();
static SEXP _RQuantLib_getQuantLibCapabilities_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(getQuantLibCapabilities());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_getQuantLibCapabilities() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_getQuantLibCapabilities_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// europeanOptionEngine
Rcpp::List europeanOptionEngine(std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, Rcpp::Nullable<Rcpp::NumericVector> discreteDividends, Rcpp::Nullable<Rcpp::NumericVector> discreteDividendsTimeUntil);
static SEXP _RQuantLib_europeanOptionEngine_try(SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP discreteDividendsSEXP, SEXP discreteDividendsTimeUntilSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<Rcpp::NumericVector> >::type discreteDividends(discreteDividendsSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<Rcpp::NumericVector> >::type discreteDividendsTimeUntil(discreteDividendsTimeUntilSEXP);
    rcpp_result_gen = Rcpp::wrap(europeanOptionEngine(type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, discreteDividends, discreteDividendsTimeUntil));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_europeanOptionEngine(SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP discreteDividendsSEXP, SEXP discreteDividendsTimeUntilSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_europeanOptionEngine_try(typeSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volatilitySEXP, discreteDividendsSEXP, discreteDividendsTimeUntilSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// americanOptionEngine
Rcpp::List americanOptionEngine(std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, int timeSteps, int gridPoints, std::string engine, Rcpp::Nullable<Rcpp::NumericVector> discreteDividends, Rcpp::Nullable<Rcpp::NumericVector> discreteDividendsTimeUntil);
static SEXP _RQuantLib_americanOptionEngine_try(SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP timeStepsSEXP, SEXP gridPointsSEXP, SEXP engineSEXP, SEXP discreteDividendsSEXP, SEXP discreteDividendsTimeUntilSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP);
    Rcpp::traits::input_parameter< double >::type strike(strikeSEXP);
    Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP);
    Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP);
    Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP);
    Rcpp::traits::input_parameter< int >::type timeSteps(timeStepsSEXP);
    Rcpp::traits::input_parameter< int >::type gridPoints(gridPointsSEXP);
    Rcpp::traits::input_parameter< std::string >::type engine(engineSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<Rcpp::NumericVector> >::type discreteDividends(discreteDividendsSEXP);
    Rcpp::traits::input_parameter< Rcpp::Nullable<Rcpp::NumericVector> >::type discreteDividendsTimeUntil(discreteDividendsTimeUntilSEXP);
    rcpp_result_gen = Rcpp::wrap(americanOptionEngine(type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, timeSteps, gridPoints, engine, discreteDividends, discreteDividendsTimeUntil));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_americanOptionEngine(SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP timeStepsSEXP, SEXP gridPointsSEXP, SEXP engineSEXP, SEXP discreteDividendsSEXP, SEXP discreteDividendsTimeUntilSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_americanOptionEngine_try(typeSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volatilitySEXP, timeStepsSEXP, gridPointsSEXP, engineSEXP, discreteDividendsSEXP, discreteDividendsTimeUntilSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// europeanOptionArraysEngine
Rcpp::List europeanOptionArraysEngine(std::string type, Rcpp::NumericMatrix par);
static SEXP _RQuantLib_europeanOptionArraysEngine_try(SEXP typeSEXP, SEXP parSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type type(typeSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type par(parSEXP);
    rcpp_result_gen = Rcpp::wrap(europeanOptionArraysEngine(type, par));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _RQuantLib_europeanOptionArraysEngine(SEXP typeSEXP, SEXP parSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_RQuantLib_europeanOptionArraysEngine_try(typeSEXP, parSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// zeroprice
double zeroprice(double yield, QuantLib::Date maturity, QuantLib::Date settle, int period, int basis);
RcppExport SEXP _RQuantLib_zeroprice(SEXP yieldSEXP, SEXP maturitySEXP, SEXP settleSEXP, SEXP periodSEXP, SEXP basisSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type yield(yieldSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type settle(settleSEXP);
    Rcpp::traits::input_parameter< int >::type period(periodSEXP);
    Rcpp::traits::input_parameter< int >::type basis(basisSEXP);
    rcpp_result_gen = Rcpp::wrap(zeroprice(yield, maturity, settle, period, basis));
    return rcpp_result_gen;
END_RCPP
}
// zeroyield
double zeroyield(double price, QuantLib::Date maturity, QuantLib::Date settle, int period, int basis);
RcppExport SEXP _RQuantLib_zeroyield(SEXP priceSEXP, SEXP maturitySEXP, SEXP settleSEXP, SEXP periodSEXP, SEXP basisSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< double >::type price(priceSEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type maturity(maturitySEXP);
    Rcpp::traits::input_parameter< QuantLib::Date >::type settle(settleSEXP);
    Rcpp::traits::input_parameter< int >::type period(periodSEXP);
    Rcpp::traits::input_parameter< int >::type basis(basisSEXP);
    rcpp_result_gen = Rcpp::wrap(zeroyield(price, maturity, settle, period, basis));
    return rcpp_result_gen;
END_RCPP
}

// validate (ensure exported C++ functions exist before calling them)
static int _RQuantLib_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("double(*zeroPriceByYieldEngine)(double,double,double,double,double,double,QuantLib::Date,QuantLib::Date)");
        signatures.insert("double(*zeroYieldByPriceEngine)(double,double,double,double,double,double,QuantLib::Date,QuantLib::Date)");
        signatures.insert("double(*fixedRateBondYieldByPriceEngine)(double,double,std::string,double,double,double,double,double,double,QuantLib::Date,QuantLib::Date,QuantLib::Date,std::vector<double>)");
        signatures.insert("double(*fixedRateBondPriceByYieldEngine)(double,double,std::string,double,double,double,double,double,double,QuantLib::Date,QuantLib::Date,QuantLib::Date,std::vector<double>)");
        signatures.insert("Rcpp::List(*FloatBond1)(Rcpp::List,std::vector<double>,std::vector<double>,std::vector<double>,std::vector<double>,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List)");
        signatures.insert("Rcpp::List(*FloatBond2)(Rcpp::List,std::vector<double>,std::vector<double>,std::vector<double>,std::vector<double>,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List)");
        signatures.insert("Rcpp::List(*FloatBond3)(Rcpp::List,std::vector<double>,std::vector<double>,std::vector<double>,std::vector<double>,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List)");
        signatures.insert("Rcpp::List(*FloatBond4)(Rcpp::List,std::vector<double>,std::vector<double>,std::vector<double>,std::vector<double>,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List,Rcpp::List)");
        signatures.insert("Rcpp::List(*floatingWithRebuiltCurveEngine)(Rcpp::List,std::vector<double>,std::vector<double>,std::vector<double>,std::vector<double>,Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>,std::vector<QuantLib::Date>,std::vector<double>,Rcpp::List)");
        signatures.insert("Rcpp::List(*FixedRateWithYield)(Rcpp::List,std::vector<double>,Rcpp::List,Rcpp::List,double)");
        signatures.insert("Rcpp::List(*FixedRateWithPrice)(Rcpp::List,std::vector<double>,Rcpp::List,Rcpp::List,double)");
        signatures.insert("Rcpp::List(*FixedRateWithRebuiltCurve)(Rcpp::List,std::vector<double>,Rcpp::List,Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>)");
        signatures.insert("Rcpp::List(*ZeroBondWithRebuiltCurve)(Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>,Rcpp::List)");
        signatures.insert("Rcpp::List(*convertibleZeroBondEngine)(Rcpp::List,Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>,std::vector<QuantLib::Date>,std::vector<double>,Rcpp::DataFrame,Rcpp::DataFrame,Rcpp::List)");
        signatures.insert("Rcpp::List(*convertibleFixedBondEngine)(Rcpp::List,Rcpp::NumericVector,Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>,std::vector<QuantLib::Date>,std::vector<double>,Rcpp::DataFrame,Rcpp::DataFrame,Rcpp::List)");
        signatures.insert("Rcpp::List(*convertibleFloatingBondEngine)(Rcpp::List,Rcpp::List,std::vector<QuantLib::Date>,std::vector<double>,std::vector<QuantLib::Date>,std::vector<double>,std::vector<QuantLib::Date>,std::vector<double>,Rcpp::List,std::vector<double>,Rcpp::DataFrame,Rcpp::DataFrame,Rcpp::List)");
        signatures.insert("Rcpp::List(*callableBondEngine)(Rcpp::List,Rcpp::List,Rcpp::NumericVector,Rcpp::DataFrame,Rcpp::List)");
        signatures.insert("Rcpp::List(*fittedBondCurveEngine)(Rcpp::List,Rcpp::NumericVector,Rcpp::NumericVector,Rcpp::NumericVector,Rcpp::List)");
        signatures.insert("QuantLib::Date(*advanceDate)(QuantLib::Date,int)");
        signatures.insert("std::vector<double>(*dayCount)(std::vector<QuantLib::Date>,std::vector<QuantLib::Date>,std::vector<double>)");
        signatures.insert("std::vector<double>(*yearFraction)(std::vector<QuantLib::Date>,std::vector<QuantLib::Date>,std::vector<double>)");
        signatures.insert("bool(*setEvaluationDate)(QuantLib::Date)");
        signatures.insert("double(*europeanOptionImpliedVolatilityEngine)(std::string,double,double,double,double,double,double,double)");
        signatures.insert("double(*americanOptionImpliedVolatilityEngine)(std::string,double,double,double,double,double,double,double,int,int)");
        signatures.insert("Rcpp::DateVector(*CreateSchedule)(Rcpp::List)");
        signatures.insert("std::string(*getQuantLibVersion)()");
        signatures.insert("Rcpp::LogicalVector(*getQuantLibCapabilities)()");
        signatures.insert("Rcpp::List(*europeanOptionEngine)(std::string,double,double,double,double,double,double,Rcpp::Nullable<Rcpp::NumericVector>,Rcpp::Nullable<Rcpp::NumericVector>)");
        signatures.insert("Rcpp::List(*americanOptionEngine)(std::string,double,double,double,double,double,double,int,int,std::string,Rcpp::Nullable<Rcpp::NumericVector>,Rcpp::Nullable<Rcpp::NumericVector>)");
        signatures.insert("Rcpp::List(*europeanOptionArraysEngine)(std::string,Rcpp::NumericMatrix)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _RQuantLib_RcppExport_registerCCallable() { 
    R_RegisterCCallable("RQuantLib", "_RQuantLib_zeroPriceByYieldEngine", (DL_FUNC)_RQuantLib_zeroPriceByYieldEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_zeroYieldByPriceEngine", (DL_FUNC)_RQuantLib_zeroYieldByPriceEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_fixedRateBondYieldByPriceEngine", (DL_FUNC)_RQuantLib_fixedRateBondYieldByPriceEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_fixedRateBondPriceByYieldEngine", (DL_FUNC)_RQuantLib_fixedRateBondPriceByYieldEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FloatBond1", (DL_FUNC)_RQuantLib_FloatBond1_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FloatBond2", (DL_FUNC)_RQuantLib_FloatBond2_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FloatBond3", (DL_FUNC)_RQuantLib_FloatBond3_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FloatBond4", (DL_FUNC)_RQuantLib_FloatBond4_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_floatingWithRebuiltCurveEngine", (DL_FUNC)_RQuantLib_floatingWithRebuiltCurveEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FixedRateWithYield", (DL_FUNC)_RQuantLib_FixedRateWithYield_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FixedRateWithPrice", (DL_FUNC)_RQuantLib_FixedRateWithPrice_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_FixedRateWithRebuiltCurve", (DL_FUNC)_RQuantLib_FixedRateWithRebuiltCurve_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_ZeroBondWithRebuiltCurve", (DL_FUNC)_RQuantLib_ZeroBondWithRebuiltCurve_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_convertibleZeroBondEngine", (DL_FUNC)_RQuantLib_convertibleZeroBondEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_convertibleFixedBondEngine", (DL_FUNC)_RQuantLib_convertibleFixedBondEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_convertibleFloatingBondEngine", (DL_FUNC)_RQuantLib_convertibleFloatingBondEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_callableBondEngine", (DL_FUNC)_RQuantLib_callableBondEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_fittedBondCurveEngine", (DL_FUNC)_RQuantLib_fittedBondCurveEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_advanceDate", (DL_FUNC)_RQuantLib_advanceDate_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_dayCount", (DL_FUNC)_RQuantLib_dayCount_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_yearFraction", (DL_FUNC)_RQuantLib_yearFraction_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_setEvaluationDate", (DL_FUNC)_RQuantLib_setEvaluationDate_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_europeanOptionImpliedVolatilityEngine", (DL_FUNC)_RQuantLib_europeanOptionImpliedVolatilityEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_americanOptionImpliedVolatilityEngine", (DL_FUNC)_RQuantLib_americanOptionImpliedVolatilityEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_CreateSchedule", (DL_FUNC)_RQuantLib_CreateSchedule_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_getQuantLibVersion", (DL_FUNC)_RQuantLib_getQuantLibVersion_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_getQuantLibCapabilities", (DL_FUNC)_RQuantLib_getQuantLibCapabilities_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_europeanOptionEngine", (DL_FUNC)_RQuantLib_europeanOptionEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_americanOptionEngine", (DL_FUNC)_RQuantLib_americanOptionEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_europeanOptionArraysEngine", (DL_FUNC)_RQuantLib_europeanOptionArraysEngine_try);
    R_RegisterCCallable("RQuantLib", "_RQuantLib_RcppExport_validate", (DL_FUNC)_RQuantLib_RcppExport_validate);
    return R_NilValue;
}

RcppExport SEXP _rcpp_module_boot_BlackMod();
RcppExport SEXP _rcpp_module_boot_BondsMod();

static const R_CallMethodDef CallEntries[] = {
    {"_RQuantLib_affineWithRebuiltCurveEngine", (DL_FUNC) &_RQuantLib_affineWithRebuiltCurveEngine, 7},
    {"_RQuantLib_asianOptionEngine", (DL_FUNC) &_RQuantLib_asianOptionEngine, 11},
    {"_RQuantLib_binaryOptionEngine", (DL_FUNC) &_RQuantLib_binaryOptionEngine, 10},
    {"_RQuantLib_binaryOptionImpliedVolatilityEngine", (DL_FUNC) &_RQuantLib_binaryOptionImpliedVolatilityEngine, 9},
    {"_RQuantLib_barrierOptionEngine", (DL_FUNC) &_RQuantLib_barrierOptionEngine, 10},
    {"_RQuantLib_bermudanFromYieldEngine", (DL_FUNC) &_RQuantLib_bermudanFromYieldEngine, 5},
    {"_RQuantLib_bermudanWithRebuiltCurveEngine", (DL_FUNC) &_RQuantLib_bermudanWithRebuiltCurveEngine, 6},
    {"_RQuantLib_zeroPriceByYieldEngine", (DL_FUNC) &_RQuantLib_zeroPriceByYieldEngine, 8},
    {"_RQuantLib_zeroYieldByPriceEngine", (DL_FUNC) &_RQuantLib_zeroYieldByPriceEngine, 8},
    {"_RQuantLib_fixedRateBondYieldByPriceEngine", (DL_FUNC) &_RQuantLib_fixedRateBondYieldByPriceEngine, 13},
    {"_RQuantLib_fixedRateBondPriceByYieldEngine", (DL_FUNC) &_RQuantLib_fixedRateBondPriceByYieldEngine, 13},
    {"_RQuantLib_FloatBond1", (DL_FUNC) &_RQuantLib_FloatBond1, 9},
    {"_RQuantLib_FloatBond2", (DL_FUNC) &_RQuantLib_FloatBond2, 11},
    {"_RQuantLib_FloatBond3", (DL_FUNC) &_RQuantLib_FloatBond3, 11},
    {"_RQuantLib_FloatBond4", (DL_FUNC) &_RQuantLib_FloatBond4, 13},
    {"_RQuantLib_floatingWithRebuiltCurveEngine", (DL_FUNC) &_RQuantLib_floatingWithRebuiltCurveEngine, 11},
    {"_RQuantLib_FixedRateWithYield", (DL_FUNC) &_RQuantLib_FixedRateWithYield, 5},
    {"_RQuantLib_FixedRateWithPrice", (DL_FUNC) &_RQuantLib_FixedRateWithPrice, 5},
    {"_RQuantLib_FixedRateWithRebuiltCurve", (DL_FUNC) &_RQuantLib_FixedRateWithRebuiltCurve, 6},
    {"_RQuantLib_ZeroBondWithRebuiltCurve", (DL_FUNC) &_RQuantLib_ZeroBondWithRebuiltCurve, 4},
    {"_RQuantLib_convertibleZeroBondEngine", (DL_FUNC) &_RQuantLib_convertibleZeroBondEngine, 9},
    {"_RQuantLib_convertibleFixedBondEngine", (DL_FUNC) &_RQuantLib_convertibleFixedBondEngine, 10},
    {"_RQuantLib_convertibleFloatingBondEngine", (DL_FUNC) &_RQuantLib_convertibleFloatingBondEngine, 13},
    {"_RQuantLib_callableBondEngine", (DL_FUNC) &_RQuantLib_callableBondEngine, 5},
    {"_RQuantLib_fittedBondCurveEngine", (DL_FUNC) &_RQuantLib_fittedBondCurveEngine, 5},
    {"_RQuantLib_setCalendarContext", (DL_FUNC) &_RQuantLib_setCalendarContext, 3},
    {"_RQuantLib_isBusinessDay", (DL_FUNC) &_RQuantLib_isBusinessDay, 2},
    {"_RQuantLib_isHoliday", (DL_FUNC) &_RQuantLib_isHoliday, 2},
    {"_RQuantLib_isWeekend", (DL_FUNC) &_RQuantLib_isWeekend, 2},
    {"_RQuantLib_isEndOfMonth", (DL_FUNC) &_RQuantLib_isEndOfMonth, 2},
    {"_RQuantLib_getEndOfMonth", (DL_FUNC) &_RQuantLib_getEndOfMonth, 2},
    {"_RQuantLib_adjust", (DL_FUNC) &_RQuantLib_adjust, 3},
    {"_RQuantLib_advance1", (DL_FUNC) &_RQuantLib_advance1, 6},
    {"_RQuantLib_advance2", (DL_FUNC) &_RQuantLib_advance2, 5},
    {"_RQuantLib_businessDaysBetween", (DL_FUNC) &_RQuantLib_businessDaysBetween, 5},
    {"_RQuantLib_getHolidayList", (DL_FUNC) &_RQuantLib_getHolidayList, 4},
    {"_RQuantLib_addHolidays", (DL_FUNC) &_RQuantLib_addHolidays, 2},
    {"_RQuantLib_removeHolidays", (DL_FUNC) &_RQuantLib_removeHolidays, 2},
    {"_RQuantLib_advanceDate", (DL_FUNC) &_RQuantLib_advanceDate, 2},
    {"_RQuantLib_dayCount", (DL_FUNC) &_RQuantLib_dayCount, 3},
    {"_RQuantLib_yearFraction", (DL_FUNC) &_RQuantLib_yearFraction, 3},
    {"_RQuantLib_setEvaluationDate", (DL_FUNC) &_RQuantLib_setEvaluationDate, 1},
    {"_RQuantLib_discountCurveEngine", (DL_FUNC) &_RQuantLib_discountCurveEngine, 4},
    {"_RQuantLib_calibrateHullWhiteUsingCapsEngine", (DL_FUNC) &_RQuantLib_calibrateHullWhiteUsingCapsEngine, 7},
    {"_RQuantLib_calibrateHullWhiteUsingSwapsEngine", (DL_FUNC) &_RQuantLib_calibrateHullWhiteUsingSwapsEngine, 7},
    {"_RQuantLib_europeanOptionImpliedVolatilityEngine", (DL_FUNC) &_RQuantLib_europeanOptionImpliedVolatilityEngine, 8},
    {"_RQuantLib_americanOptionImpliedVolatilityEngine", (DL_FUNC) &_RQuantLib_americanOptionImpliedVolatilityEngine, 10},
    {"_RQuantLib_sabrengine", (DL_FUNC) &_RQuantLib_sabrengine, 9},
    {"_RQuantLib_CreateSchedule", (DL_FUNC) &_RQuantLib_CreateSchedule, 1},
    {"_RQuantLib_getQuantLibVersion", (DL_FUNC) &_RQuantLib_getQuantLibVersion, 0},
    {"_RQuantLib_getQuantLibCapabilities", (DL_FUNC) &_RQuantLib_getQuantLibCapabilities, 0},
    {"_RQuantLib_europeanOptionEngine", (DL_FUNC) &_RQuantLib_europeanOptionEngine, 9},
    {"_RQuantLib_americanOptionEngine", (DL_FUNC) &_RQuantLib_americanOptionEngine, 12},
    {"_RQuantLib_europeanOptionArraysEngine", (DL_FUNC) &_RQuantLib_europeanOptionArraysEngine, 2},
    {"_RQuantLib_zeroprice", (DL_FUNC) &_RQuantLib_zeroprice, 5},
    {"_RQuantLib_zeroyield", (DL_FUNC) &_RQuantLib_zeroyield, 5},
    {"_rcpp_module_boot_BlackMod", (DL_FUNC) &_rcpp_module_boot_BlackMod, 0},
    {"_rcpp_module_boot_BondsMod", (DL_FUNC) &_rcpp_module_boot_BondsMod, 0},
    {"_RQuantLib_RcppExport_registerCCallable", (DL_FUNC) &_RQuantLib_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_RQuantLib(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
