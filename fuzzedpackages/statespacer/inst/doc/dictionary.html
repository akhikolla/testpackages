<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Dictionary of statespacer</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>
<style type="text/css">
a.anchor-section {margin-left: 10px; visibility: hidden; color: inherit;}
a.anchor-section::before {content: '#';}
.hasAnchor:hover a.anchor-section {visibility: visible;}
</style>
<script>// Anchor sections v1.0 written by Atsushi Yasumoto on Oct 3rd, 2020.
document.addEventListener('DOMContentLoaded', function() {
  // Do nothing if AnchorJS is used
  if (typeof window.anchors === 'object' && anchors.hasOwnProperty('hasAnchorJSLink')) {
    return;
  }

  const h = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  // Do nothing if sections are already anchored
  if (Array.from(h).some(x => x.classList.contains('hasAnchor'))) {
    return null;
  }

  // Use section id when pandoc runs with --section-divs
  const section_id = function(x) {
    return ((x.classList.contains('section') || (x.tagName === 'SECTION'))
            ? x.id : '');
  };

  // Add anchors
  h.forEach(function(x) {
    const id = x.id || section_id(x.parentElement);
    if (id === '') {
      return null;
    }
    let anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.classList = ['anchor-section'];
    x.classList.add('hasAnchor');
    x.appendChild(anchor);
  });
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>





<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Dictionary of statespacer</h1>



<p>This document provides extensive details about the object that is returned by <code>statespacer()</code>. In order to do so, we start with introducing the form of the general linear Gaussian state space model, following the notation used by <span class="citation">Durbin and Koopman (2012)</span>. Obtaining a grasp of the notation used will help to get the most out of the statespacer package!</p>
<div id="the-general-linear-gaussian-state-space-model" class="section level2">
<h2>The general linear Gaussian state space model</h2>
<p>There are many ways to write down the form of the general linear Gaussian state space model. We use the form used by <span class="citation">Durbin and Koopman (2012)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
 y_t ~ &amp;= ~ Z_t\alpha_t ~ + ~ \varepsilon_t, &amp;\varepsilon_t ~ &amp;\sim ~ N(0, ~ H_t), \\
 \alpha_{t+1} ~ &amp;= ~ T_t\alpha_t ~ + ~ R_t\eta_t, &amp;\eta_t ~ &amp;\sim ~ N(0, ~ Q_t), \\
 &amp; &amp;\alpha_1 ~ &amp;\sim ~ N(a_1, ~ P_1),
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(y_t\)</span> is the <em>observation vector</em>, a <span class="math inline">\(p ~ \times ~ 1\)</span> vector of dependent variables at time <span class="math inline">\(t\)</span>, <span class="math inline">\(\alpha_t\)</span> is the unobserved <em>state vector</em>, a <span class="math inline">\(m ~ \times ~ 1\)</span> vector of state variables at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\varepsilon_t\)</span> and <span class="math inline">\(\eta_t\)</span> are disturbance vectors of respectively the observation equation, and the state equation. To initialise the model, <span class="math inline">\(a_1\)</span> is used as the initial guess of the state vector, and <span class="math inline">\(P_1\)</span> is the corresponding uncertainty of that guess. The matrices <span class="math inline">\(Z_t\)</span>, <span class="math inline">\(H_t\)</span>, <span class="math inline">\(T_t\)</span>, <span class="math inline">\(R_t\)</span>, and <span class="math inline">\(Q_t\)</span> are called the <em>system matrices</em> of the state space model. Different specifications of these system matrices, lead to different interpretations of the model at hand.</p>
</div>
<div id="the-object-as-returned-by-statespacer" class="section level2">
<h2>The object as returned by statespacer</h2>
<p>Having obtained a better understanding of the notation used, it is easier to find our way in the object that is returned by <code>statespacer()</code>. Let’s say we store the object of statespacer in a variable called <code>fit</code>, that is, <code>fit &lt;- statespacer(...)</code>. <code>fit</code> is then a list, containing many items, including other lists. This section describes the items that are included in <code>fit</code> one by one.</p>
<div id="function_call" class="section level3">
<h3>function_call</h3>
<p><code>function_call</code> is a list that contains, as the name suggests, the call to the <code>statespacer()</code> function, including default values for the input arguments that were not specified. For details about the various input arguments, check out <code>?statespacer</code>.</p>
</div>
<div id="system_matrices" class="section level3">
<h3>system_matrices</h3>
<p><code>system_matrices</code> is a list containing all of the system matrices of each of the components. For the variance - covariance matrices <span class="math inline">\(H\)</span> and <span class="math inline">\(Q\)</span>, it also contains 2 decompositions, namely the Cholesky <span class="math inline">\(LDL^{\top}\)</span> decomposition, where <span class="math inline">\(L\)</span> is the loading matrix and <span class="math inline">\(D\)</span> is the diagonal matrix, and the correlation / standard deviation decomposition. The initial guess for the state vector, <code>a1</code>, is also included, together with the corresponding uncertainty split out by its diffuse component, <code>P_inf</code>, and its stationary component <code>P_star</code>. Further, it contains <code>Z_padded</code>, which is a list containing the <span class="math inline">\(Z\)</span> matrices of the components augmented with zeroes, such that its dimension is <span class="math inline">\(p ~ \times ~ m\)</span>. These matrices are useful to extract individual components (which is already done for you), or to extract standard deviations of the components. There’s also a vector called <code>state_label</code>, which labels the state vector to indicate which state parameters belongs to which components. If components are specified that introduce parameters into the system matrices, then these parameters are also included here. At the moment, these parameters are <code>lamba</code> (frequency) and <code>rho</code> (dampening factor) for the cycles, <code>AR</code> and <code>MA</code> for the ARIMA components, <code>SAR</code> and <code>SMA</code> for the SARIMA components, and <code>self_spec</code> for the self specified component. Note that coefficients of explanatory variables are put into the state vector, so these are treated as state parameters, and readily returned by the Kalman filter.</p>
</div>
<div id="predicted" class="section level3">
<h3>predicted</h3>
<p><code>predicted</code> is a list that contains the one-step ahead predicted (predicting time <span class="math inline">\(t\)</span> using data up to time <span class="math inline">\(t ~ - ~ 1\)</span>) objects as returned by the Kalman filter:</p>
<ul>
<li><code>yfit</code> is the predicted value of <span class="math inline">\(y\)</span>.</li>
<li><code>v</code> is the prediction error.</li>
<li><code>Fmat</code> is the uncertainty of the prediction.</li>
<li><code>a</code> is the predicted state.</li>
<li><code>P</code> is the uncertainty of the predicted state.</li>
<li><code>P_inf</code> is the diffuse part of <code>P</code>.</li>
<li><code>P_star</code> is the non-diffuse part of <code>P</code>.</li>
<li><code>a_fc</code> is the predicted state for time <span class="math inline">\(N ~ + ~ 1\)</span> (<span class="math inline">\(N\)</span> being the last observed time point).</li>
<li><code>P_fc</code> is the uncertainty of <code>a_fc</code>.</li>
<li><code>P_inf_fc</code> is the diffuse part of <code>P_fc</code>.</li>
<li><code>P_star_fc</code> is the non-diffuse part of <code>P_fc</code>.</li>
</ul>
<p>Further, the contributions of the components to the predicted values are extracted separately.</p>
</div>
<div id="filtered" class="section level3">
<h3>filtered</h3>
<p><code>filtered</code> is a list that contains the filtered (estimates for time <span class="math inline">\(t\)</span> using data up to time <span class="math inline">\(t\)</span>) objects as returned by the Kalman filter. Here, <code>a</code> is the filtered state, <code>P</code> the uncertainty of the filtered state, <code>P_inf</code> is the diffuse part of <code>P</code>, and <code>P_star</code> is the non-diffuse part of <code>P</code>. Further, the filtered values of the components are extracted separately.</p>
</div>
<div id="smoothed" class="section level3">
<h3>smoothed</h3>
<p><code>smoothed</code> is a list that contains smoothed (estimates for time <span class="math inline">\(t\)</span> using all of the time points) objects as returned by the Kalman smoother:</p>
<ul>
<li><code>a</code> is the smoothed state.</li>
<li><code>V</code> the uncertainty of the smoothed state.</li>
<li><code>eta</code> the smoothed state disturbance.</li>
<li><code>eta_var</code> the uncertainty of <code>eta</code>.</li>
<li><code>epsilon</code> the smoothed observation disturbance.</li>
<li><code>epsilon_var</code> the uncertainty of <code>epsilon</code>.</li>
</ul>
<p>Further, the smoothed values of the components are extracted separately.</p>
</div>
<div id="diagnostics" class="section level3">
<h3>diagnostics</h3>
<p><code>diagnostics</code> is a list that contains items useful for diagnostic tests and model selection:</p>
<ul>
<li><code>initialisation_steps</code> is the number of timesteps required before initialisation was achieved of the diffuse elements of the state vector.</li>
<li><code>loglik</code> is the loglikelihood value at the estimated parameters.</li>
<li><code>AIC</code> is the Akaike Information Criterion for the model.</li>
<li><code>BIC</code> is the Bayesian Information Criterion for the model.</li>
<li><code>r</code> is the scaled smoothed state disturbance.</li>
<li><code>N</code> is the uncertainty of <code>r</code>.</li>
<li><code>param_indices</code> is a list containing the indices of the parameters in the parameter vector for each of the components.</li>
<li><code>hessian</code> is the hessian of the loglikelihood evaluated at the estimated parameters.</li>
</ul>
<p>The following objects are only returned if <code>diagnostics = TRUE</code>:</p>
<ul>
<li><code>e</code> is the smoothing error.</li>
<li><code>D</code> is the uncertainty of <code>e</code>.</li>
<li><code>Tstat_observation</code> is the T-statistic for testing whether deviations from the observation equation are significant.</li>
<li><code>Tstat_state</code> is the T-statistic for testing whether deviations from the state equation are significant.</li>
<li><code>v_normalised</code> is the normalised prediction error.</li>
<li><code>Skewness</code> is the skewness of <code>v_normalised</code>.</li>
<li><code>Kurtosis</code> is the Kurtosis of <code>v_normalised</code>.</li>
<li><code>Jarque_Bera</code> is the Jarque-Bera statistic for testing for normality.</li>
<li><code>Jarque_Bera_criticalvalue</code> is the critical value of the Jarque-Bera test.</li>
<li><code>correlogram</code> is the correlogram of <code>v_normalised</code>.</li>
<li><code>Box_Ljung</code> are the Box-Ljung statistics for testing for serial correlation.</li>
<li><code>Box_Ljung_criticalvalues</code> are the critical values of the Box-Ljung tests.</li>
<li><code>Heteroscedasticity</code> are statistics for testing for heteroscedasticity.</li>
<li><code>Heteroscedasticity_criticalvalues</code> are the critical values of the heteroscedasticity tests.</li>
</ul>
</div>
<div id="optim" class="section level3">
<h3>optim</h3>
<p><code>optim</code> is the list as returned by <code>stats::optim</code> or <code>optimx::optimr</code>, depending on if you have optimx installed. See <code>?stats::optim</code> and <code>?optimx::optimr</code> for details. Only returned if <code>fit = TRUE</code>.</p>
</div>
<div id="loglik_fun" class="section level3">
<h3>loglik_fun</h3>
<p><code>loglik_fun</code> is the loglikelihood function that takes <code>param</code> as its only argument. It returns the loglikelihood at the specified parameters.</p>
</div>
<div id="standard_errors" class="section level3">
<h3>standard_errors</h3>
<p><code>standard_errors</code> is a list that contains the standard errors for the transformed parameters. Its structure mimicks the structure from <code>system_matrices</code>, but only representing those system matrices that depend on the parameters. Only returned if <code>standard_errors = TRUE</code>.</p>
</div>
</div>
<div id="order-of-parameter-input" class="section level2">
<h2>Order of parameter input</h2>
<p>This section provides details about the parameter vector that’s supplied to <code>statespacer()</code>. It clarifies which elements are used for what components.</p>
<p>Most components use a variance - covariance matrix, which are constructed using the Cholesky <span class="math inline">\(LDL^{\top}\)</span> decomposition. The parameters supplied to build the variance - covariance matrix are ordered as follows: First, parameters are used for the Diagonal matrix <span class="math inline">\(D\)</span> and transformed by <span class="math inline">\(exp(2x)\)</span>. Second, the remaining parameters are assigned columnwise to the Loading matrix <span class="math inline">\(L\)</span>, so first the <span class="math inline">\(1_{st}\)</span> column, then the <span class="math inline">\(2_{nd}\)</span> column, and so on.</p>
<p>The parameters are assigned to the components in the following order:</p>
<ol style="list-style-type: decimal">
<li>The variance - covariance matrix, <span class="math inline">\(H\)</span>, of the observation equation. Unless the <span class="math inline">\(H\)</span> matrix is self-specified!</li>
<li>The Local Level component.</li>
<li>The Local Level component + Slope in that order.</li>
<li>The BSM components, in the order of the specified <code>BSM_vec</code>.</li>
<li>Explanatory Variables, if the coefficients are time-varying. The coefficients themselves go into the state vector, so they don’t need any parameters!</li>
<li>Local Level + Explanatory Variables in the Level. First the parameters go to the variance - covariance matrix of the Level, after which the remaining parameters go to the variance - covariance matrix of the Explanatory Variables (if time-varying).</li>
<li>Local Level + Slope + Explanatory Variables in the Level. First the parameters go to the variance - covariance matrix of the Level, then they go to the variance - covariance matrix of the Slope, after which the remaining parameters go to the variance - covariance matrix of the Explanatory Variables (if time-varying).</li>
<li>The Cycle components, in the order of the specified cycles. The first parameter is used for the frequency, <span class="math inline">\(\lambda\)</span>, of the cycle. The second parameter is used for the damping factor, <span class="math inline">\(\rho\)</span>, of the cycle, but only if <code>damping_factor_ind = TRUE</code>. The remaining parameters are used for the variance - covariance matrix.</li>
<li>ARIMA, in the order of the specified ARIMA components. First, the parameters are used for the variance - covariance matrix. Then, the remaining parameters are first used for the AR coefficients, and then the MA coefficients.</li>
<li>SARIMA, in the order of the specified SARIMA components. First, the parameters are used for the variance - covariance matrix. Then, the remaining parameters are used in the order of the specified seasonalities <code>s</code>, first used for the AR coefficients of the first seasonality, and then the MA coefficients of the first seasonality, and so on for the subsequent seasonalities.</li>
<li>The self-specified part.</li>
</ol>
<p>Care should be taken in specifying the initial parameters! Usually, I check out the variances of the dependent variables and then apply the transformation <span class="math inline">\(0.5\log(x)\)</span> to the variances, and specify those as initial values for the parameters that go to the various variance - covariance matrices. For the AR and MA coefficients, it might be beneficial to initialise them close to 0, to prevent them from converging to unit root solutions. Using the information in this section, it should make the trial and error process of finding proper initial parameters less cumbersome!</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references hanging-indent">
<div id="ref-durbin2012time">
<p>Durbin, James, and Siem Jan Koopman. 2012. <em>Time Series Analysis by State Space Methods</em>. Oxford university press.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
