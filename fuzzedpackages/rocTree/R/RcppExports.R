# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

make_mat2 <- function(tk0, Y0, id0, z0) {
    .Call('_rocTree_make_mat2', PACKAGE = 'rocTree', tk0, Y0, id0, z0)
}

make_mat2_t <- function(tk0, Y0, id0, z0) {
    .Call('_rocTree_make_mat2_t', PACKAGE = 'rocTree', tk0, Y0, id0, z0)
}

#' @noRd
rocForest_C <- function(mat1f0, mat1Z0, mat2Zf0, r0, zt0, zy0, e0, spCriterion, numTree, minNode1, minSplit1, maxNode, mtry) {
    .Call('_rocTree_rocForest_C', PACKAGE = 'rocTree', mat1f0, mat1Z0, mat2Zf0, r0, zt0, zy0, e0, spCriterion, numTree, minNode1, minSplit1, maxNode, mtry)
}

predict_rocForest_C <- function(zraw0, y0, e0, forestobj, matX, disc, breaks) {
    .Call('_rocTree_predict_rocForest_C', PACKAGE = 'rocTree', zraw0, y0, e0, forestobj, matX, disc, breaks)
}

#' Main function for tree.
#' Data are prepared outside of the function.
#' 
#' @param mat1f0 is a K x n matrix; K is the number of cutpoint
#'               for i = 1, ..., n, k = 1, ..., K,
#'               the transpose of it has the (i, j)th element of f_i(t_j) 
#' @param mat1Z0 is a n x p matrix; p is the number of covariates
#'               instead of covaraites values, this gives the 'order' that indicates which
#'               time intervals the covaraite values lie in.
#' @param mat2Z0 is a list of length K. The lth list consists of a r x p matrix that
#'               specified the order of covariates for subjects at risk at tk;
#'               r is the number of subjects at risk at t_l.
#' @param r0     is a 2 x p matrix. Each column specified the smallest and the largest intervals
#'               the pth covariates lie in.
#' @param zt0    is a list of length equal to the numbers of events (\sum\Delta).
#'               This is created similar to `mat2Z` but it stores the order of covariates for
#'               subjects at risk at the event times (Y0)
#' @param zy0    is a transpose of a subset of `mat1Z0` on these event times,
#'               e.g., .zy <- t(.mat1Z[.E0 == 1,])
#' @param e0     censoring indicator; 1 = event and 0 = control
#'
#'
#' Tunning parameters
#' @param spCriterion specifies the splitting criterion; 1 = DICON and 0 = ICON
#' @param numFold is the number of fold used in cross-validation
#' @param minNode1 is the minimum number of baseline observations in each terminal node; default = 15
#'                 we used time-invariant tree, so the node size criterion is on the baseline obs.
#' @param minSplit1 is the minimum number of baseline observations in each splitable node; default 30
#' @param maxNode is the maximum number of terminal nodes
#'
#' Returns a list with the following elements
#'   *treeMat - a xx by 5 matrix that consists of 5 columns;
#'     the number of rows depends on how depth the tree is
#'      Column1: Which covariate to split? Index corresponds to the columns in .X
#'      Column2: What value to split? (this is the ranked value; corresponding to which interval.
#'      Column3: Left child node (<= the cut value)
#'      Column4: Right child node (> the cut value)
#'      Column5: Node indicator; 1 = terminal node, 0 = non-terminal node
#'
#'   *nodeLabel - a n-dimensional vector, where n is the number of unique uncensored survival times.
#'
#'   *nodeSize - a xx by n matrix;
#'     the number of rows = number of terminal nodes
#'     the number of columns = number of unique ordered uncensored survival times  (Y0)
#'       This gives node size at each of the terminal nodes at each unique Y0
#' 
#'   *nodeMap - a xx-dimensional vector, where xx is the number of rows in treeMat.
#'     The elements indicates the element in 'nodeSize' to be used as risk set size in survival pred.
#'     Only the elements correspond to terminal nodes (treeMat[,5] == 1) will be used.
#' 
#' @noRd
rocTree_C <- function(mat1f0, mat1Z0, mat2Zf0, r0, zt0, zy0, e0, spCriterion, numFold, minNode1, minSplit1, maxNode) {
    .Call('_rocTree_rocTree_C', PACKAGE = 'rocTree', mat1f0, mat1Z0, mat2Zf0, r0, zt0, zy0, e0, spCriterion, numFold, minNode1, minSplit1, maxNode)
}

#' Main function for survival prediction from a rocTree object
#'
#' @param zraw0 is a matrix consists of new covariates.
#'             The number of columns equal to the total number of unique survival times (n).
#'             The number of rows equal to the number of covariates
#' @param y0 is a n-dimensional vector consists of all survival times 
#' @param e0 is the censoring indicator
#' @param treeobj is the rocTree object
#' @param matX is the original covariate matrix,
#'             the number of rows is equal to the total observed survival times
#' @param disc is a vector with length equal to the number of covariates.
#'             This indicates whether a covariate is continuous (0) or not (1)
#' @param breaks is the cutoff points, e.g., cutoff <- (1:nc) / (nc+1)
#'             This gives the boundaries of intervals
#'
#' @noRd
predict_rocTree_C <- function(zraw0, y0, e0, treeobj, matX, disc, breaks) {
    .Call('_rocTree_predict_rocTree_C', PACKAGE = 'rocTree', zraw0, y0, e0, treeobj, matX, disc, breaks)
}

#' Main function for hazard prediction from a rocTree object
#'
#' Because of smoothing, the hazard estimate is based on fewer time points
#'
#' @param zraw0 is a matrix consists of new covariates.
#'              The number of columns equal to the length of `tg0`
#'              The number of rows equal to the number of covariates
#' @param tg0 is a vector that gives the time points where the prediction takes place.
#'              This corresponds to zraw0
#' @param y0 is a n-dimensional vector consists of all survival times
#' @param e0 is the censoring indicator
#' @param fy20 is a new version of `.mat1f` based on `zraw0` and `tg0`
#' @param h0 is the smoothing parameter
#' @param treeobj is the rocTree object
#' @param matX is the original covariate matrix,
#'             the number of rows is equal to the total observed survival times
#' @param disc is a vector with length equal to the number of covariates.
#'             This indicates whether a covariate is continuous (0) or not (1)
#' @param breaks is the cutoff points, e.g., cutoff <- (1:nc) / (nc+1)
#'             This gives the boundaries of intervals
#'
#' @noRd
predict_rocTreeHZ_C <- function(zraw0, tg0, y0, e0, fy20, h0, treeobj, matX, disc, breaks) {
    .Call('_rocTree_predict_rocTreeHZ_C', PACKAGE = 'rocTree', zraw0, tg0, y0, e0, fy20, h0, treeobj, matX, disc, breaks)
}

#' @noRd
predict_rocForestHZ_C <- function(zraw0, tg0, y0, e0, Kmat0, h0, forestobj, matX, disc, breaks) {
    .Call('_rocTree_predict_rocForestHZ_C', PACKAGE = 'rocTree', zraw0, tg0, y0, e0, Kmat0, h0, forestobj, matX, disc, breaks)
}

